const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["./Cb4wYaKN.js", "./BJxF2Pan.js", "./tbOjCnuf.js", "./ButtonTilt.LhO0V6bW.css", "./CuwB4rDY.js", "./Df6QSTmN.js", "./mFt5ISIH.js", "./BXhdW89J.js", "./PathBackground.7kG6BcV0.css", "./BTXegXU4.js", "./CDtgf0cK.js", "./DiISNzl7.js", "./BorderHover.DW7kzidB.css", "./ContentExpander.DyRjkwat.css", "./linksResolver.CI6wRIV9.css", "./B3X0cXmp.js", "./SiteFooter.DgxBm7Rk.css", "./DYDhTKZo.js", "./DdpkdPkM.js", "./about.D1pNVY42.css", "./DyUXhHQ0.js", "./index.Dmdczd-I.css", "./gHg1li4D.js", "./press.B61vp7VX.css", "./CqoGyOl6.js", "./config.CPLvtMWX.css", "./CkY6zwto.js", "./system.CTpX0nZT.css", "./DXmqWGh7.js", "./8l2BT6fx.js", "./K105tSmJ.js", "./Checkbox.DPiEluAk.css", "./D6Xv85vs.js", "./vERjyvrW.js", "./CrossFlicker.CAQml9P2.css", "./RkfjLTg0.js", "./DSButton.CDEX4zNp.css", "./HeadingContent.yC39PRyF.css", "./careers.CR8DMtg0.css", "./CrDfq5w8.js", "./contact.xCr_ZgtQ.css", "./Budg17VV.js", "./security.Bdas6sPx.css", "./BVB8peBq.js", "./B8MigvAX.js", "./BKgq3HUB.js", "./privacy-policy.Cm1Upcwh.css", "./Cg9iJPL1.js", "./terms-of-service.DA20Ye_Z.css", "./aIp6R3HE.js", "./DSDropdownButton.CvAfSjzU.css", "./DltPStmS.js", "./DesignGrid.Di0usAye.css", "./REf8v6gy.js", "./DSY6LiOS.js", "./Media.BOzEloz4.css", "./BfwGAPrn.js", "./TagButtonList.Dxgeffxm.css", "./DH-1Q7yJ.js", "./TextReveal.CTK1JXTk.css", "./CuR2BBdh.js", "./TextRevealChar.k4zFTZsq.css", "./CSAUWnR2.js", "./AboutLeaders.BGkHGvSM.css", "./K07fp1Ap.js", "./CiyANy4L.js", "./BlogCardSkeleton.Bf5Xlpvs.css", "./TpweVw4E.js", "./AllResources.CiRLUtjS.css", "./BUNtUlDr.js", "./BTKkCQzb.js", "./NotchSection.CmaDBuu9.css", "./BigImageWithContent.CJIqM0wA.css", "./DgAnreGg.js", "./BigText.0JeCNRN4.css", "./CMvzZAs8.js", "./CaseStudy.wpPBBL5k.css", "./B9gymHIf.js", "./ComparisonTable.iEV7Ppsf.css", "./CuLQ2xRM.js", "./ContentExpanderStandAlone.31iPM3MR.css", "./CUin20Dn.js", "./ExpandableFeatureCards.CRm5Weo2.css", "./CY839viz.js", "./FeatureSection.B0YFQ_JC.css", "./DiV6peeD.js", "./FeaturedBlogPosts.Cqc5b9wy.css", "./D8QKpbM8.js", "./CdPqqr9a.js", "./B7BPRo6R.js", "./FeaturesCarousel.BD2Y_59X.css", "./SQ03s_T8.js", "./FeaturesCarouselExpandable.C9XXN22k.css", "./BNXqlk-8.js", "./FeaturesGrid.B6Lz6Ip7.css", "./O9wTcfQ-.js", "./BTmJN-B9.js", "./PaddedCounter.D_9jWspQ.css", "./FeaturesSteps.BVcE7YK6.css", "./Epde3gza.js", "./FormBuilder.iIG_OJx5.css", "./CywgcAEJ.js", "./CezZK4Sj.js", "./FullscreenFeatures.D6ZYpDiv.css", "./75yDIck1.js", "./HeroImage.BthVimVc.css", "./HzBEyAR6.js", "./DFywznAZ.js", "./BackgroundCanvas.Mu1ajYID.css", "./yAOro401.js", "./InfoSection.B8RSaTi3.css", "./R75sOFzz.js", "./B5ylfTjW.js", "./NewsSection.B8_G2Had.css", "./BQHk-wu6.js", "./LinksList.Dn_bPq3O.css", "./AmwY7etT.js", "./LogoGrid.q7LM8J_l.css", "./1u1MFduc.js", "./CIuVaXvz.js", "./SectionIntroduction.B-98zZYX.css", "./Post.uViPkGYd.css", "./Cr_E8Qix.js", "./PressSection.DSVZTmjw.css", "./Ceg0M1cG.js", "./ProofPoints.Ci2yWwFr.css", "./De6l7h9o.js", "./Quote.BktCJoG9.css", "./CBNTcaav.js", "./ResultsSection.CFPh_8W7.css", "./D4WxWABM.js", "./SectionsGrid.D92WyAg7.css", "./CVXjVMRE.js", "./SeparatorNotch.C7lDeGb1.css", "./CV3AvXfp.js", "./BwIldRJy.js", "./get-frames.BEFbNTY1.css", "./SolutionsFeatures.U8Psha3l.css", "./Dw9hZgUs.js", "./SolutionsFull.AV3-HjHL.css", "./BN2tpE7T.js", "./SolutionsValue.BrBjTbyi.css", "./CDegGHr3.js", "./TabbedAccordion.CWtuEFfB.css", "./CnAtRxFS.js", "./VideoCarousel.wiIHwmc0.css", "./DsfgKBdb.js", "./YOSSection.Dhetld54.css", "./BxLGiDcZ.js", "./default.BcKJ6naG.css"]))) => i.map(i => d[i]);
var cm = Object.defineProperty;
var fm = (e, t, n) => t in e ? cm(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n;
var Ct = (e, t, n) => fm(e, typeof t != "symbol" ? t + "" : t, n);
(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const a of s.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function n(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
    }

    function r(i) {
        if (i.ep) return;
        i.ep = !0;
        const s = n(i);
        fetch(i.href, s)
    }
})();
/**
 * @vue/shared v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */
function _c(e) {
    const t = Object.create(null);
    for (const n of e.split(",")) t[n] = 1;
    return n => n in t
}
const $n = {},
    Ma = [],
    vs = () => {},
    hm = () => !1,
    Zl = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
    ph = e => e.startsWith("onUpdate:"),
    cr = Object.assign,
    gh = (e, t) => {
        const n = e.indexOf(t);
        n > -1 && e.splice(n, 1)
    },
    dm = Object.prototype.hasOwnProperty,
    Xn = (e, t) => dm.call(e, t),
    Wt = Array.isArray,
    La = e => Ka(e) === "[object Map]",
    ma = e => Ka(e) === "[object Set]",
    Zh = e => Ka(e) === "[object Date]",
    pm = e => Ka(e) === "[object RegExp]",
    ln = e => typeof e == "function",
    yr = e => typeof e == "string",
    Fs = e => typeof e == "symbol",
    or = e => e !== null && typeof e == "object",
    _h = e => (or(e) || ln(e)) && ln(e.then) && ln(e.catch),
    ng = Object.prototype.toString,
    Ka = e => ng.call(e),
    gm = e => Ka(e).slice(8, -1),
    mc = e => Ka(e) === "[object Object]",
    mh = e => yr(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
    Fa = _c(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    yc = e => {
        const t = Object.create(null);
        return n => t[n] || (t[n] = e(n))
    },
    _m = /-(\w)/g,
    Bi = yc(e => e.replace(_m, (t, n) => n ? n.toUpperCase() : "")),
    mm = /\B([A-Z])/g,
    is = yc(e => e.replace(mm, "-$1").toLowerCase()),
    eu = yc(e => e.charAt(0).toUpperCase() + e.slice(1)),
    Fu = yc(e => e ? `on${eu(e)}` : ""),
    Yi = (e, t) => !Object.is(e, t),
    Ia = (e, ...t) => {
        for (let n = 0; n < e.length; n++) e[n](...t)
    },
    rg = (e, t, n, r = !1) => {
        Object.defineProperty(e, t, {
            configurable: !0,
            enumerable: !1,
            writable: r,
            value: n
        })
    },
    zu = e => {
        const t = parseFloat(e);
        return isNaN(t) ? e : t
    },
    ju = e => {
        const t = yr(e) ? Number(e) : NaN;
        return isNaN(t) ? e : t
    };
let ed;
const vc = () => ed || (ed = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}),
    ym = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol",
    vm = _c(ym);

function bc(e) {
    if (Wt(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n],
                i = yr(r) ? xm(r) : bc(r);
            if (i)
                for (const s in i) t[s] = i[s]
        }
        return t
    } else if (yr(e) || or(e)) return e
}
const bm = /;(?![^(]*\))/g,
    wm = /:([^]+)/,
    Dm = /\/\*[^]*?\*\//g;

function xm(e) {
    const t = {};
    return e.replace(Dm, "").split(bm).forEach(n => {
        if (n) {
            const r = n.split(wm);
            r.length > 1 && (t[r[0].trim()] = r[1].trim())
        }
    }), t
}

function ya(e) {
    let t = "";
    if (yr(e)) t = e;
    else if (Wt(e))
        for (let n = 0; n < e.length; n++) {
            const r = ya(e[n]);
            r && (t += r + " ")
        } else if (or(e))
            for (const n in e) e[n] && (t += n + " ");
    return t.trim()
}

function g2(e) {
    if (!e) return null;
    let {
        class: t,
        style: n
    } = e;
    return t && !yr(t) && (e.class = ya(t)), n && (e.style = bc(n)), e
}
const Em = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    Cm = _c(Em);

function ig(e) {
    return !!e || e === ""
}

function Sm(e, t) {
    if (e.length !== t.length) return !1;
    let n = !0;
    for (let r = 0; n && r < e.length; r++) n = $o(e[r], t[r]);
    return n
}

function $o(e, t) {
    if (e === t) return !0;
    let n = Zh(e),
        r = Zh(t);
    if (n || r) return n && r ? e.getTime() === t.getTime() : !1;
    if (n = Fs(e), r = Fs(t), n || r) return e === t;
    if (n = Wt(e), r = Wt(t), n || r) return n && r ? Sm(e, t) : !1;
    if (n = or(e), r = or(t), n || r) {
        if (!n || !r) return !1;
        const i = Object.keys(e).length,
            s = Object.keys(t).length;
        if (i !== s) return !1;
        for (const a in e) {
            const c = e.hasOwnProperty(a),
                u = t.hasOwnProperty(a);
            if (c && !u || !c && u || !$o(e[a], t[a])) return !1
        }
    }
    return String(e) === String(t)
}

function wc(e, t) {
    return e.findIndex(n => $o(n, t))
}
const sg = e => !!(e && e.__v_isRef === !0),
    Uu = e => yr(e) ? e : e == null ? "" : Wt(e) || or(e) && (e.toString === ng || !ln(e.toString)) ? sg(e) ? Uu(e.value) : JSON.stringify(e, og, 2) : String(e),
    og = (e, t) => sg(t) ? og(e, t.value) : La(t) ? {
        [`Map(${t.size})`]: [...t.entries()].reduce((n, [r, i], s) => (n[qc(r, s) + " =>"] = i, n), {})
    } : ma(t) ? {
        [`Set(${t.size})`]: [...t.values()].map(n => qc(n))
    } : Fs(t) ? qc(t) : or(t) && !Wt(t) && !mc(t) ? String(t) : t,
    qc = (e, t = "") => {
        var n;
        return Fs(e) ? `Symbol(${(n=e.description)!=null?n:t})` : e
    };
/**
 * @vue/reactivity v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let Gi;
class ag {
    constructor(t = !1) {
        this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Gi, !t && Gi && (this.index = (Gi.scopes || (Gi.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    pause() {
        if (this._active) {
            this._isPaused = !0;
            let t, n;
            if (this.scopes)
                for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].pause();
            for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].pause()
        }
    }
    resume() {
        if (this._active && this._isPaused) {
            this._isPaused = !1;
            let t, n;
            if (this.scopes)
                for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].resume();
            for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].resume()
        }
    }
    run(t) {
        if (this._active) {
            const n = Gi;
            try {
                return Gi = this, t()
            } finally {
                Gi = n
            }
        }
    }
    on() {
        Gi = this
    }
    off() {
        Gi = this.parent
    }
    stop(t) {
        if (this._active) {
            this._active = !1;
            let n, r;
            for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
            for (this.effects.length = 0, n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]();
            if (this.cleanups.length = 0, this.scopes) {
                for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0);
                this.scopes.length = 0
            }
            if (!this.detached && this.parent && !t) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index)
            }
            this.parent = void 0
        }
    }
}

function go(e) {
    return new ag(e)
}

function Uo() {
    return Gi
}

function fs(e, t = !1) {
    Gi && Gi.cleanups.push(e)
}
let _r;
const Gc = new WeakSet;
class Wu {
    constructor(t) {
        this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Gi && Gi.active && Gi.effects.push(this)
    }
    pause() {
        this.flags |= 64
    }
    resume() {
        this.flags & 64 && (this.flags &= -65, Gc.has(this) && (Gc.delete(this), this.trigger()))
    }
    notify() {
        this.flags & 2 && !(this.flags & 32) || this.flags & 8 || ug(this)
    }
    run() {
        if (!(this.flags & 1)) return this.fn();
        this.flags |= 2, td(this), cg(this);
        const t = _r,
            n = Ls;
        _r = this, Ls = !0;
        try {
            return this.fn()
        } finally {
            fg(this), _r = t, Ls = n, this.flags &= -3
        }
    }
    stop() {
        if (this.flags & 1) {
            for (let t = this.deps; t; t = t.nextDep) bh(t);
            this.deps = this.depsTail = void 0, td(this), this.onStop && this.onStop(), this.flags &= -2
        }
    }
    trigger() {
        this.flags & 64 ? Gc.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
    }
    runIfDirty() {
        Df(this) && this.run()
    }
    get dirty() {
        return Df(this)
    }
}
let lg = 0,
    Tl, Pl;

function ug(e, t = !1) {
    if (e.flags |= 8, t) {
        e.next = Pl, Pl = e;
        return
    }
    e.next = Tl, Tl = e
}

function yh() {
    lg++
}

function vh() {
    if (--lg > 0) return;
    if (Pl) {
        let t = Pl;
        for (Pl = void 0; t;) {
            const n = t.next;
            t.next = void 0, t.flags &= -9, t = n
        }
    }
    let e;
    for (; Tl;) {
        let t = Tl;
        for (Tl = void 0; t;) {
            const n = t.next;
            if (t.next = void 0, t.flags &= -9, t.flags & 1) try {
                t.trigger()
            } catch (r) {
                e || (e = r)
            }
            t = n
        }
    }
    if (e) throw e
}

function cg(e) {
    for (let t = e.deps; t; t = t.nextDep) t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t
}

function fg(e) {
    let t, n = e.depsTail,
        r = n;
    for (; r;) {
        const i = r.prevDep;
        r.version === -1 ? (r === n && (n = i), bh(r), Tm(r)) : t = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = i
    }
    e.deps = t, e.depsTail = n
}

function Df(e) {
    for (let t = e.deps; t; t = t.nextDep)
        if (t.dep.version !== t.version || t.dep.computed && (hg(t.dep.computed) || t.dep.version !== t.version)) return !0;
    return !!e._dirty
}

function hg(e) {
    if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === $l)) return;
    e.globalVersion = $l;
    const t = e.dep;
    if (e.flags |= 2, t.version > 0 && !e.isSSR && e.deps && !Df(e)) {
        e.flags &= -3;
        return
    }
    const n = _r,
        r = Ls;
    _r = e, Ls = !0;
    try {
        cg(e);
        const i = e.fn(e._value);
        (t.version === 0 || Yi(i, e._value)) && (e._value = i, t.version++)
    } catch (i) {
        throw t.version++, i
    } finally {
        _r = n, Ls = r, fg(e), e.flags &= -3
    }
}

function bh(e, t = !1) {
    const {
        dep: n,
        prevSub: r,
        nextSub: i
    } = e;
    if (r && (r.nextSub = i, e.prevSub = void 0), i && (i.prevSub = r, e.nextSub = void 0), n.subs === e && (n.subs = r, !r && n.computed)) {
        n.computed.flags &= -5;
        for (let s = n.computed.deps; s; s = s.nextDep) bh(s, !0)
    }!t && !--n.sc && n.map && n.map.delete(n.key)
}

function Tm(e) {
    const {
        prevDep: t,
        nextDep: n
    } = e;
    t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0)
}

function _2(e, t) {
    e.effect instanceof Wu && (e = e.effect.fn);
    const n = new Wu(e);
    t && cr(n, t);
    try {
        n.run()
    } catch (i) {
        throw n.stop(), i
    }
    const r = n.run.bind(n);
    return r.effect = n, r
}

function m2(e) {
    e.effect.stop()
}
let Ls = !0;
const dg = [];

function Wo() {
    dg.push(Ls), Ls = !1
}

function qo() {
    const e = dg.pop();
    Ls = e === void 0 ? !0 : e
}

function td(e) {
    const {
        cleanup: t
    } = e;
    if (e.cleanup = void 0, t) {
        const n = _r;
        _r = void 0;
        try {
            t()
        } finally {
            _r = n
        }
    }
}
let $l = 0;
class Pm {
    constructor(t, n) {
        this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
    }
}
class Dc {
    constructor(t) {
        this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0
    }
    track(t) {
        if (!_r || !Ls || _r === this.computed) return;
        let n = this.activeLink;
        if (n === void 0 || n.sub !== _r) n = this.activeLink = new Pm(_r, this), _r.deps ? (n.prevDep = _r.depsTail, _r.depsTail.nextDep = n, _r.depsTail = n) : _r.deps = _r.depsTail = n, pg(n);
        else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
            const r = n.nextDep;
            r.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = r), n.prevDep = _r.depsTail, n.nextDep = void 0, _r.depsTail.nextDep = n, _r.depsTail = n, _r.deps === n && (_r.deps = r)
        }
        return n
    }
    trigger(t) {
        this.version++, $l++, this.notify(t)
    }
    notify(t) {
        yh();
        try {
            for (let n = this.subs; n; n = n.prevSub) n.sub.notify() && n.sub.dep.notify()
        } finally {
            vh()
        }
    }
}

function pg(e) {
    if (e.dep.sc++, e.sub.flags & 4) {
        const t = e.dep.computed;
        if (t && !e.dep.subs) {
            t.flags |= 20;
            for (let r = t.deps; r; r = r.nextDep) pg(r)
        }
        const n = e.dep.subs;
        n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e
    }
}
const qu = new WeakMap,
    ca = Symbol(""),
    xf = Symbol(""),
    Hl = Symbol("");

function Fi(e, t, n) {
    if (Ls && _r) {
        let r = qu.get(e);
        r || qu.set(e, r = new Map);
        let i = r.get(n);
        i || (r.set(n, i = new Dc), i.map = r, i.key = n), i.track()
    }
}

function fo(e, t, n, r, i, s) {
    const a = qu.get(e);
    if (!a) {
        $l++;
        return
    }
    const c = u => {
        u && u.trigger()
    };
    if (yh(), t === "clear") a.forEach(c);
    else {
        const u = Wt(e),
            p = u && mh(n);
        if (u && n === "length") {
            const d = Number(r);
            a.forEach((g, m) => {
                (m === "length" || m === Hl || !Fs(m) && m >= d) && c(g)
            })
        } else switch ((n !== void 0 || a.has(void 0)) && c(a.get(n)), p && c(a.get(Hl)), t) {
            case "add":
                u ? p && c(a.get("length")) : (c(a.get(ca)), La(e) && c(a.get(xf)));
                break;
            case "delete":
                u || (c(a.get(ca)), La(e) && c(a.get(xf)));
                break;
            case "set":
                La(e) && c(a.get(ca));
                break
        }
    }
    vh()
}

function km(e, t) {
    const n = qu.get(e);
    return n && n.get(t)
}

function Ca(e) {
    const t = Bn(e);
    return t === e ? t : (Fi(t, "iterate", Hl), bs(e) ? t : t.map(Ii))
}

function xc(e) {
    return Fi(e = Bn(e), "iterate", Hl), e
}
const Am = {
    __proto__: null,
    [Symbol.iterator]() {
        return Yc(this, Symbol.iterator, Ii)
    },
    concat(...e) {
        return Ca(this).concat(...e.map(t => Wt(t) ? Ca(t) : t))
    },
    entries() {
        return Yc(this, "entries", e => (e[1] = Ii(e[1]), e))
    },
    every(e, t) {
        return ao(this, "every", e, t, void 0, arguments)
    },
    filter(e, t) {
        return ao(this, "filter", e, t, n => n.map(Ii), arguments)
    },
    find(e, t) {
        return ao(this, "find", e, t, Ii, arguments)
    },
    findIndex(e, t) {
        return ao(this, "findIndex", e, t, void 0, arguments)
    },
    findLast(e, t) {
        return ao(this, "findLast", e, t, Ii, arguments)
    },
    findLastIndex(e, t) {
        return ao(this, "findLastIndex", e, t, void 0, arguments)
    },
    forEach(e, t) {
        return ao(this, "forEach", e, t, void 0, arguments)
    },
    includes(...e) {
        return Xc(this, "includes", e)
    },
    indexOf(...e) {
        return Xc(this, "indexOf", e)
    },
    join(e) {
        return Ca(this).join(e)
    },
    lastIndexOf(...e) {
        return Xc(this, "lastIndexOf", e)
    },
    map(e, t) {
        return ao(this, "map", e, t, void 0, arguments)
    },
    pop() {
        return ul(this, "pop")
    },
    push(...e) {
        return ul(this, "push", e)
    },
    reduce(e, ...t) {
        return nd(this, "reduce", e, t)
    },
    reduceRight(e, ...t) {
        return nd(this, "reduceRight", e, t)
    },
    shift() {
        return ul(this, "shift")
    },
    some(e, t) {
        return ao(this, "some", e, t, void 0, arguments)
    },
    splice(...e) {
        return ul(this, "splice", e)
    },
    toReversed() {
        return Ca(this).toReversed()
    },
    toSorted(e) {
        return Ca(this).toSorted(e)
    },
    toSpliced(...e) {
        return Ca(this).toSpliced(...e)
    },
    unshift(...e) {
        return ul(this, "unshift", e)
    },
    values() {
        return Yc(this, "values", Ii)
    }
};

function Yc(e, t, n) {
    const r = xc(e),
        i = r[t]();
    return r !== e && !bs(e) && (i._next = i.next, i.next = () => {
        const s = i._next();
        return s.value && (s.value = n(s.value)), s
    }), i
}
const Rm = Array.prototype;

function ao(e, t, n, r, i, s) {
    const a = xc(e),
        c = a !== e && !bs(e),
        u = a[t];
    if (u !== Rm[t]) {
        const g = u.apply(e, s);
        return c ? Ii(g) : g
    }
    let p = n;
    a !== e && (c ? p = function(g, m) {
        return n.call(this, Ii(g), m, e)
    } : n.length > 2 && (p = function(g, m) {
        return n.call(this, g, m, e)
    }));
    const d = u.call(a, p, r);
    return c && i ? i(d) : d
}

function nd(e, t, n, r) {
    const i = xc(e);
    let s = n;
    return i !== e && (bs(e) ? n.length > 3 && (s = function(a, c, u) {
        return n.call(this, a, c, u, e)
    }) : s = function(a, c, u) {
        return n.call(this, a, Ii(c), u, e)
    }), i[t](s, ...r)
}

function Xc(e, t, n) {
    const r = Bn(e);
    Fi(r, "iterate", Hl);
    const i = r[t](...n);
    return (i === -1 || i === !1) && wh(n[0]) ? (n[0] = Bn(n[0]), r[t](...n)) : i
}

function ul(e, t, n = []) {
    Wo(), yh();
    const r = Bn(e)[t].apply(e, n);
    return vh(), qo(), r
}
const Om = _c("__proto__,__v_isRef,__isVue"),
    gg = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Fs));

function Mm(e) {
    Fs(e) || (e = String(e));
    const t = Bn(this);
    return Fi(t, "has", e), t.hasOwnProperty(e)
}
class _g {
    constructor(t = !1, n = !1) {
        this._isReadonly = t, this._isShallow = n
    }
    get(t, n, r) {
        if (n === "__v_skip") return t.__v_skip;
        const i = this._isReadonly,
            s = this._isShallow;
        if (n === "__v_isReactive") return !i;
        if (n === "__v_isReadonly") return i;
        if (n === "__v_isShallow") return s;
        if (n === "__v_raw") return r === (i ? s ? Dg : wg : s ? bg : vg).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(r) ? t : void 0;
        const a = Wt(t);
        if (!i) {
            let u;
            if (a && (u = Am[n])) return u;
            if (n === "hasOwnProperty") return Mm
        }
        const c = Reflect.get(t, n, mr(t) ? t : r);
        return (Fs(n) ? gg.has(n) : Om(n)) || (i || Fi(t, "get", n), s) ? c : mr(c) ? a && mh(n) ? c : c.value : or(c) ? i ? xg(c) : mi(c) : c
    }
}
class mg extends _g {
    constructor(t = !1) {
        super(!1, t)
    }
    set(t, n, r, i) {
        let s = t[n];
        if (!this._isShallow) {
            const u = Ho(s);
            if (!bs(r) && !Ho(r) && (s = Bn(s), r = Bn(r)), !Wt(t) && mr(s) && !mr(r)) return u ? !1 : (s.value = r, !0)
        }
        const a = Wt(t) && mh(n) ? Number(n) < t.length : Xn(t, n),
            c = Reflect.set(t, n, r, mr(t) ? t : i);
        return t === Bn(i) && (a ? Yi(r, s) && fo(t, "set", n, r) : fo(t, "add", n, r)), c
    }
    deleteProperty(t, n) {
        const r = Xn(t, n);
        t[n];
        const i = Reflect.deleteProperty(t, n);
        return i && r && fo(t, "delete", n, void 0), i
    }
    has(t, n) {
        const r = Reflect.has(t, n);
        return (!Fs(n) || !gg.has(n)) && Fi(t, "has", n), r
    }
    ownKeys(t) {
        return Fi(t, "iterate", Wt(t) ? "length" : ca), Reflect.ownKeys(t)
    }
}
class yg extends _g {
    constructor(t = !1) {
        super(!0, t)
    }
    set(t, n) {
        return !0
    }
    deleteProperty(t, n) {
        return !0
    }
}
const Lm = new mg,
    Fm = new yg,
    Im = new mg(!0),
    Nm = new yg(!0),
    Ef = e => e,
    _u = e => Reflect.getPrototypeOf(e);

function Bm(e, t, n) {
    return function(...r) {
        const i = this.__v_raw,
            s = Bn(i),
            a = La(s),
            c = e === "entries" || e === Symbol.iterator && a,
            u = e === "keys" && a,
            p = i[e](...r),
            d = n ? Ef : t ? Cf : Ii;
        return !t && Fi(s, "iterate", u ? xf : ca), {
            next() {
                const {
                    value: g,
                    done: m
                } = p.next();
                return m ? {
                    value: g,
                    done: m
                } : {
                    value: c ? [d(g[0]), d(g[1])] : d(g),
                    done: m
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function mu(e) {
    return function(...t) {
        return e === "delete" ? !1 : e === "clear" ? void 0 : this
    }
}

function $m(e, t) {
    const n = {
        get(i) {
            const s = this.__v_raw,
                a = Bn(s),
                c = Bn(i);
            e || (Yi(i, c) && Fi(a, "get", i), Fi(a, "get", c));
            const {
                has: u
            } = _u(a), p = t ? Ef : e ? Cf : Ii;
            if (u.call(a, i)) return p(s.get(i));
            if (u.call(a, c)) return p(s.get(c));
            s !== a && s.get(i)
        },
        get size() {
            const i = this.__v_raw;
            return !e && Fi(Bn(i), "iterate", ca), Reflect.get(i, "size", i)
        },
        has(i) {
            const s = this.__v_raw,
                a = Bn(s),
                c = Bn(i);
            return e || (Yi(i, c) && Fi(a, "has", i), Fi(a, "has", c)), i === c ? s.has(i) : s.has(i) || s.has(c)
        },
        forEach(i, s) {
            const a = this,
                c = a.__v_raw,
                u = Bn(c),
                p = t ? Ef : e ? Cf : Ii;
            return !e && Fi(u, "iterate", ca), c.forEach((d, g) => i.call(s, p(d), p(g), a))
        }
    };
    return cr(n, e ? {
        add: mu("add"),
        set: mu("set"),
        delete: mu("delete"),
        clear: mu("clear")
    } : {
        add(i) {
            !t && !bs(i) && !Ho(i) && (i = Bn(i));
            const s = Bn(this);
            return _u(s).has.call(s, i) || (s.add(i), fo(s, "add", i, i)), this
        },
        set(i, s) {
            !t && !bs(s) && !Ho(s) && (s = Bn(s));
            const a = Bn(this),
                {
                    has: c,
                    get: u
                } = _u(a);
            let p = c.call(a, i);
            p || (i = Bn(i), p = c.call(a, i));
            const d = u.call(a, i);
            return a.set(i, s), p ? Yi(s, d) && fo(a, "set", i, s) : fo(a, "add", i, s), this
        },
        delete(i) {
            const s = Bn(this),
                {
                    has: a,
                    get: c
                } = _u(s);
            let u = a.call(s, i);
            u || (i = Bn(i), u = a.call(s, i)), c && c.call(s, i);
            const p = s.delete(i);
            return u && fo(s, "delete", i, void 0), p
        },
        clear() {
            const i = Bn(this),
                s = i.size !== 0,
                a = i.clear();
            return s && fo(i, "clear", void 0, void 0), a
        }
    }), ["keys", "values", "entries", Symbol.iterator].forEach(i => {
        n[i] = Bm(i, e, t)
    }), n
}

function Ec(e, t) {
    const n = $m(e, t);
    return (r, i, s) => i === "__v_isReactive" ? !e : i === "__v_isReadonly" ? e : i === "__v_raw" ? r : Reflect.get(Xn(n, i) && i in r ? n : r, i, s)
}
const Hm = {
        get: Ec(!1, !1)
    },
    Vm = {
        get: Ec(!1, !0)
    },
    zm = {
        get: Ec(!0, !1)
    },
    jm = {
        get: Ec(!0, !0)
    },
    vg = new WeakMap,
    bg = new WeakMap,
    wg = new WeakMap,
    Dg = new WeakMap;

function Um(e) {
    switch (e) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function Wm(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : Um(gm(e))
}

function mi(e) {
    return Ho(e) ? e : Cc(e, !1, Lm, Hm, vg)
}

function Ms(e) {
    return Cc(e, !1, Im, Vm, bg)
}

function xg(e) {
    return Cc(e, !0, Fm, zm, wg)
}

function la(e) {
    return Cc(e, !0, Nm, jm, Dg)
}

function Cc(e, t, n, r, i) {
    if (!or(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;
    const s = i.get(e);
    if (s) return s;
    const a = Wm(e);
    if (a === 0) return e;
    const c = new Proxy(e, a === 2 ? r : n);
    return i.set(e, c), c
}

function mo(e) {
    return Ho(e) ? mo(e.__v_raw) : !!(e && e.__v_isReactive)
}

function Ho(e) {
    return !!(e && e.__v_isReadonly)
}

function bs(e) {
    return !!(e && e.__v_isShallow)
}

function wh(e) {
    return e ? !!e.__v_raw : !1
}

function Bn(e) {
    const t = e && e.__v_raw;
    return t ? Bn(t) : e
}

function Dh(e) {
    return !Xn(e, "__v_skip") && Object.isExtensible(e) && rg(e, "__v_skip", !0), e
}
const Ii = e => or(e) ? mi(e) : e,
    Cf = e => or(e) ? xg(e) : e;

function mr(e) {
    return e ? e.__v_isRef === !0 : !1
}

function kn(e) {
    return Eg(e, !1)
}

function Ur(e) {
    return Eg(e, !0)
}

function Eg(e, t) {
    return mr(e) ? e : new qm(e, t)
}
class qm {
    constructor(t, n) {
        this.dep = new Dc, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : Bn(t), this._value = n ? t : Ii(t), this.__v_isShallow = n
    }
    get value() {
        return this.dep.track(), this._value
    }
    set value(t) {
        const n = this._rawValue,
            r = this.__v_isShallow || bs(t) || Ho(t);
        t = r ? t : Bn(t), Yi(t, n) && (this._rawValue = t, this._value = r ? t : Ii(t), this.dep.trigger())
    }
}

function y2(e) {
    e.dep && e.dep.trigger()
}

function Kt(e) {
    return mr(e) ? e.value : e
}

function pa(e) {
    return ln(e) ? e() : Kt(e)
}
const Gm = {
    get: (e, t, n) => t === "__v_raw" ? e : Kt(Reflect.get(e, t, n)),
    set: (e, t, n, r) => {
        const i = e[t];
        return mr(i) && !mr(n) ? (i.value = n, !0) : Reflect.set(e, t, n, r)
    }
};

function Cg(e) {
    return mo(e) ? e : new Proxy(e, Gm)
}
class Ym {
    constructor(t) {
        this.__v_isRef = !0, this._value = void 0;
        const n = this.dep = new Dc,
            {
                get: r,
                set: i
            } = t(n.track.bind(n), n.trigger.bind(n));
        this._get = r, this._set = i
    }
    get value() {
        return this._value = this._get()
    }
    set value(t) {
        this._set(t)
    }
}

function Sg(e) {
    return new Ym(e)
}

function Xm(e) {
    const t = Wt(e) ? new Array(e.length) : {};
    for (const n in e) t[n] = Tg(e, n);
    return t
}
class Km {
    constructor(t, n, r) {
        this._object = t, this._key = n, this._defaultValue = r, this.__v_isRef = !0, this._value = void 0
    }
    get value() {
        const t = this._object[this._key];
        return this._value = t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
    get dep() {
        return km(Bn(this._object), this._key)
    }
}
class Qm {
    constructor(t) {
        this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0
    }
    get value() {
        return this._value = this._getter()
    }
}

function Na(e, t, n) {
    return mr(e) ? e : ln(e) ? new Qm(e) : or(e) && arguments.length > 1 ? Tg(e, t, n) : kn(e)
}

function Tg(e, t, n) {
    const r = e[t];
    return mr(r) ? r : new Km(e, t, n)
}
class Jm {
    constructor(t, n, r) {
        this.fn = t, this.setter = n, this._value = void 0, this.dep = new Dc(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = $l - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = r
    }
    notify() {
        if (this.flags |= 16, !(this.flags & 8) && _r !== this) return ug(this, !0), !0
    }
    get value() {
        const t = this.dep.track();
        return hg(this), t && (t.version = this.dep.version), this._value
    }
    set value(t) {
        this.setter && this.setter(t)
    }
}

function Zm(e, t, n = !1) {
    let r, i;
    return ln(e) ? r = e : (r = e.get, i = e.set), new Jm(r, i, n)
}
const v2 = {
        GET: "get",
        HAS: "has",
        ITERATE: "iterate"
    },
    b2 = {
        SET: "set",
        ADD: "add",
        DELETE: "delete",
        CLEAR: "clear"
    },
    yu = {},
    Gu = new WeakMap;
let Ao;

function ey() {
    return Ao
}

function za(e, t = !1, n = Ao) {
    if (n) {
        let r = Gu.get(n);
        r || Gu.set(n, r = []), r.push(e)
    }
}

function ty(e, t, n = $n) {
    const {
        immediate: r,
        deep: i,
        once: s,
        scheduler: a,
        augmentJob: c,
        call: u
    } = n, p = k => i ? k : bs(k) || i === !1 || i === 0 ? ho(k, 1) : ho(k);
    let d, g, m, E, L = !1,
        b = !1;
    if (mr(e) ? (g = () => e.value, L = bs(e)) : mo(e) ? (g = () => p(e), L = !0) : Wt(e) ? (b = !0, L = e.some(k => mo(k) || bs(k)), g = () => e.map(k => {
            if (mr(k)) return k.value;
            if (mo(k)) return p(k);
            if (ln(k)) return u ? u(k, 2) : k()
        })) : ln(e) ? t ? g = u ? () => u(e, 2) : e : g = () => {
            if (m) {
                Wo();
                try {
                    m()
                } finally {
                    qo()
                }
            }
            const k = Ao;
            Ao = d;
            try {
                return u ? u(e, 3, [E]) : e(E)
            } finally {
                Ao = k
            }
        } : g = vs, t && i) {
        const k = g,
            S = i === !0 ? 1 / 0 : i;
        g = () => ho(k(), S)
    }
    const j = Uo(),
        A = () => {
            d.stop(), j && j.active && gh(j.effects, d)
        };
    if (s && t) {
        const k = t;
        t = (...S) => {
            k(...S), A()
        }
    }
    let $ = b ? new Array(e.length).fill(yu) : yu;
    const w = k => {
        if (!(!(d.flags & 1) || !d.dirty && !k))
            if (t) {
                const S = d.run();
                if (i || L || (b ? S.some((X, J) => Yi(X, $[J])) : Yi(S, $))) {
                    m && m();
                    const X = Ao;
                    Ao = d;
                    try {
                        const J = [S, $ === yu ? void 0 : b && $[0] === yu ? [] : $, E];
                        u ? u(t, 3, J) : t(...J), $ = S
                    } finally {
                        Ao = X
                    }
                }
            } else d.run()
    };
    return c && c(w), d = new Wu(g), d.scheduler = a ? () => a(w, !1) : w, E = k => za(k, !1, d), m = d.onStop = () => {
        const k = Gu.get(d);
        if (k) {
            if (u) u(k, 4);
            else
                for (const S of k) S();
            Gu.delete(d)
        }
    }, t ? r ? w(!0) : $ = d.run() : a ? a(w.bind(null, !0), !0) : d.run(), A.pause = d.pause.bind(d), A.resume = d.resume.bind(d), A.stop = A, A
}

function ho(e, t = 1 / 0, n) {
    if (t <= 0 || !or(e) || e.__v_skip || (n = n || new Set, n.has(e))) return e;
    if (n.add(e), t--, mr(e)) ho(e.value, t, n);
    else if (Wt(e))
        for (let r = 0; r < e.length; r++) ho(e[r], t, n);
    else if (ma(e) || La(e)) e.forEach(r => {
        ho(r, t, n)
    });
    else if (mc(e)) {
        for (const r in e) ho(e[r], t, n);
        for (const r of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, r) && ho(e[r], t, n)
    }
    return e
}
/**
 * @vue/runtime-core v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const Pg = [];

function ny(e) {
    Pg.push(e)
}

function ry() {
    Pg.pop()
}

function w2(e, t) {}
const D2 = {
        SETUP_FUNCTION: 0,
        0: "SETUP_FUNCTION",
        RENDER_FUNCTION: 1,
        1: "RENDER_FUNCTION",
        NATIVE_EVENT_HANDLER: 5,
        5: "NATIVE_EVENT_HANDLER",
        COMPONENT_EVENT_HANDLER: 6,
        6: "COMPONENT_EVENT_HANDLER",
        VNODE_HOOK: 7,
        7: "VNODE_HOOK",
        DIRECTIVE_HOOK: 8,
        8: "DIRECTIVE_HOOK",
        TRANSITION_HOOK: 9,
        9: "TRANSITION_HOOK",
        APP_ERROR_HANDLER: 10,
        10: "APP_ERROR_HANDLER",
        APP_WARN_HANDLER: 11,
        11: "APP_WARN_HANDLER",
        FUNCTION_REF: 12,
        12: "FUNCTION_REF",
        ASYNC_COMPONENT_LOADER: 13,
        13: "ASYNC_COMPONENT_LOADER",
        SCHEDULER: 14,
        14: "SCHEDULER",
        COMPONENT_UPDATE: 15,
        15: "COMPONENT_UPDATE",
        APP_UNMOUNT_CLEANUP: 16,
        16: "APP_UNMOUNT_CLEANUP"
    },
    iy = {
        sp: "serverPrefetch hook",
        bc: "beforeCreate hook",
        c: "created hook",
        bm: "beforeMount hook",
        m: "mounted hook",
        bu: "beforeUpdate hook",
        u: "updated",
        bum: "beforeUnmount hook",
        um: "unmounted hook",
        a: "activated hook",
        da: "deactivated hook",
        ec: "errorCaptured hook",
        rtc: "renderTracked hook",
        rtg: "renderTriggered hook",
        0: "setup function",
        1: "render function",
        2: "watcher getter",
        3: "watcher callback",
        4: "watcher cleanup function",
        5: "native event handler",
        6: "component event handler",
        7: "vnode hook",
        8: "directive hook",
        9: "transition hook",
        10: "app errorHandler",
        11: "app warnHandler",
        12: "ref function",
        13: "async component loader",
        14: "scheduler flush",
        15: "component update",
        16: "app unmount cleanup function"
    };

function tu(e, t, n, r) {
    try {
        return r ? e(...r) : e()
    } catch (i) {
        Qa(i, t, n)
    }
}

function Is(e, t, n, r) {
    if (ln(e)) {
        const i = tu(e, t, n, r);
        return i && _h(i) && i.catch(s => {
            Qa(s, t, n)
        }), i
    }
    if (Wt(e)) {
        const i = [];
        for (let s = 0; s < e.length; s++) i.push(Is(e[s], t, n, r));
        return i
    }
}

function Qa(e, t, n, r = !0) {
    const i = t ? t.vnode : null,
        {
            errorHandler: s,
            throwUnhandledErrorInProduction: a
        } = t && t.appContext.config || $n;
    if (t) {
        let c = t.parent;
        const u = t.proxy,
            p = `https://vuejs.org/error-reference/#runtime-${n}`;
        for (; c;) {
            const d = c.ec;
            if (d) {
                for (let g = 0; g < d.length; g++)
                    if (d[g](e, u, p) === !1) return
            }
            c = c.parent
        }
        if (s) {
            Wo(), tu(s, null, 10, [e, u, p]), qo();
            return
        }
    }
    sy(e, n, i, r, a)
}

function sy(e, t, n, r = !0, i = !1) {
    if (i) throw e;
    console.error(e)
}
const Xi = [];
let Ys = -1;
const Ba = [];
let Ro = null,
    ka = 0;
const kg = Promise.resolve();
let Yu = null;

function ss(e) {
    const t = Yu || kg;
    return e ? t.then(this ? e.bind(this) : e) : t
}

function oy(e) {
    let t = Ys + 1,
        n = Xi.length;
    for (; t < n;) {
        const r = t + n >>> 1,
            i = Xi[r],
            s = Vl(i);
        s < e || s === e && i.flags & 2 ? t = r + 1 : n = r
    }
    return t
}

function xh(e) {
    if (!(e.flags & 1)) {
        const t = Vl(e),
            n = Xi[Xi.length - 1];
        !n || !(e.flags & 2) && t >= Vl(n) ? Xi.push(e) : Xi.splice(oy(t), 0, e), e.flags |= 1, Ag()
    }
}

function Ag() {
    Yu || (Yu = kg.then(Rg))
}

function Xu(e) {
    Wt(e) ? Ba.push(...e) : Ro && e.id === -1 ? Ro.splice(ka + 1, 0, e) : e.flags & 1 || (Ba.push(e), e.flags |= 1), Ag()
}

function rd(e, t, n = Ys + 1) {
    for (; n < Xi.length; n++) {
        const r = Xi[n];
        if (r && r.flags & 2) {
            if (e && r.id !== e.uid) continue;
            Xi.splice(n, 1), n--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2)
        }
    }
}

function Ku(e) {
    if (Ba.length) {
        const t = [...new Set(Ba)].sort((n, r) => Vl(n) - Vl(r));
        if (Ba.length = 0, Ro) {
            Ro.push(...t);
            return
        }
        for (Ro = t, ka = 0; ka < Ro.length; ka++) {
            const n = Ro[ka];
            n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2
        }
        Ro = null, ka = 0
    }
}
const Vl = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;

function Rg(e) {
    try {
        for (Ys = 0; Ys < Xi.length; Ys++) {
            const t = Xi[Ys];
            t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), tu(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2))
        }
    } finally {
        for (; Ys < Xi.length; Ys++) {
            const t = Xi[Ys];
            t && (t.flags &= -2)
        }
        Ys = -1, Xi.length = 0, Ku(), Yu = null, (Xi.length || Ba.length) && Rg()
    }
}
let Aa, vu = [];

function Og(e, t) {
    var n, r;
    Aa = e, Aa ? (Aa.enabled = !0, vu.forEach(({
        event: i,
        args: s
    }) => Aa.emit(i, ...s)), vu = []) : typeof window < "u" && window.HTMLElement && !((r = (n = window.navigator) == null ? void 0 : n.userAgent) != null && r.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(s => {
        Og(s, t)
    }), setTimeout(() => {
        Aa || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, vu = [])
    }, 3e3)) : vu = []
}
let _i = null,
    Sc = null;

function zl(e) {
    const t = _i;
    return _i = e, Sc = e && e.type.__scopeId || null, t
}

function x2(e) {
    Sc = e
}

function E2() {
    Sc = null
}
const C2 = e => Ki;

function Ki(e, t = _i, n) {
    if (!t || e._n) return e;
    const r = (...i) => {
        r._d && yd(-1);
        const s = zl(t);
        let a;
        try {
            a = e(...i)
        } finally {
            zl(s), r._d && yd(1)
        }
        return a
    };
    return r._n = !0, r._c = !0, r._d = !0, r
}

function S2(e, t) {
    if (_i === null) return e;
    const n = iu(_i),
        r = e.dirs || (e.dirs = []);
    for (let i = 0; i < t.length; i++) {
        let [s, a, c, u = $n] = t[i];
        s && (ln(s) && (s = {
            mounted: s,
            updated: s
        }), s.deep && ho(a), r.push({
            dir: s,
            instance: n,
            value: a,
            oldValue: void 0,
            arg: c,
            modifiers: u
        }))
    }
    return e
}

function Xs(e, t, n, r) {
    const i = e.dirs,
        s = t && t.dirs;
    for (let a = 0; a < i.length; a++) {
        const c = i[a];
        s && (c.oldValue = s[a].value);
        let u = c.dir[r];
        u && (Wo(), Is(u, n, 8, [e.el, c, e, t]), qo())
    }
}
const Mg = Symbol("_vte"),
    Lg = e => e.__isTeleport,
    kl = e => e && (e.disabled || e.disabled === ""),
    id = e => e && (e.defer || e.defer === ""),
    sd = e => typeof SVGElement < "u" && e instanceof SVGElement,
    od = e => typeof MathMLElement == "function" && e instanceof MathMLElement,
    Sf = (e, t) => {
        const n = e && e.to;
        return yr(n) ? t ? t(n) : null : n
    },
    Fg = {
        name: "Teleport",
        __isTeleport: !0,
        process(e, t, n, r, i, s, a, c, u, p) {
            const {
                mc: d,
                pc: g,
                pbc: m,
                o: {
                    insert: E,
                    querySelector: L,
                    createText: b,
                    createComment: j
                }
            } = p, A = kl(t.props);
            let {
                shapeFlag: $,
                children: w,
                dynamicChildren: k
            } = t;
            if (e == null) {
                const S = t.el = b(""),
                    X = t.anchor = b("");
                E(S, n, r), E(X, n, r);
                const J = (he, me) => {
                        $ & 16 && (i && i.isCE && (i.ce._teleportTarget = he), d(w, he, me, i, s, a, c, u))
                    },
                    xe = () => {
                        const he = t.target = Sf(t.props, L),
                            me = Ig(he, t, b, E);
                        he && (a !== "svg" && sd(he) ? a = "svg" : a !== "mathml" && od(he) && (a = "mathml"), A || (J(he, me), Iu(t, !1)))
                    };
                A && (J(n, X), Iu(t, !0)), id(t.props) ? di(() => {
                    xe(), t.el.__isMounted = !0
                }, s) : xe()
            } else {
                if (id(t.props) && !e.el.__isMounted) {
                    di(() => {
                        Fg.process(e, t, n, r, i, s, a, c, u, p), delete e.el.__isMounted
                    }, s);
                    return
                }
                t.el = e.el, t.targetStart = e.targetStart;
                const S = t.anchor = e.anchor,
                    X = t.target = e.target,
                    J = t.targetAnchor = e.targetAnchor,
                    xe = kl(e.props),
                    he = xe ? n : X,
                    me = xe ? S : J;
                if (a === "svg" || sd(X) ? a = "svg" : (a === "mathml" || od(X)) && (a = "mathml"), k ? (m(e.dynamicChildren, k, he, i, s, a, c), Oh(e, t, !0)) : u || g(e, t, he, me, i, s, a, c, !1), A) xe ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : bu(t, n, S, p, 1);
                else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                    const Q = t.target = Sf(t.props, L);
                    Q && bu(t, Q, null, p, 0)
                } else xe && bu(t, X, J, p, 1);
                Iu(t, A)
            }
        },
        remove(e, t, n, {
            um: r,
            o: {
                remove: i
            }
        }, s) {
            const {
                shapeFlag: a,
                children: c,
                anchor: u,
                targetStart: p,
                targetAnchor: d,
                target: g,
                props: m
            } = e;
            if (g && (i(p), i(d)), s && i(u), a & 16) {
                const E = s || !kl(m);
                for (let L = 0; L < c.length; L++) {
                    const b = c[L];
                    r(b, t, n, E, !!b.dynamicChildren)
                }
            }
        },
        move: bu,
        hydrate: ay
    };

function bu(e, t, n, {
    o: {
        insert: r
    },
    m: i
}, s = 2) {
    s === 0 && r(e.targetAnchor, t, n);
    const {
        el: a,
        anchor: c,
        shapeFlag: u,
        children: p,
        props: d
    } = e, g = s === 2;
    if (g && r(a, t, n), (!g || kl(d)) && u & 16)
        for (let m = 0; m < p.length; m++) i(p[m], t, n, 2);
    g && r(c, t, n)
}

function ay(e, t, n, r, i, s, {
    o: {
        nextSibling: a,
        parentNode: c,
        querySelector: u,
        insert: p,
        createText: d
    }
}, g) {
    const m = t.target = Sf(t.props, u);
    if (m) {
        const E = kl(t.props),
            L = m._lpa || m.firstChild;
        if (t.shapeFlag & 16)
            if (E) t.anchor = g(a(e), t, c(e), n, r, i, s), t.targetStart = L, t.targetAnchor = L && a(L);
            else {
                t.anchor = a(e);
                let b = L;
                for (; b;) {
                    if (b && b.nodeType === 8) {
                        if (b.data === "teleport start anchor") t.targetStart = b;
                        else if (b.data === "teleport anchor") {
                            t.targetAnchor = b, m._lpa = t.targetAnchor && a(t.targetAnchor);
                            break
                        }
                    }
                    b = a(b)
                }
                t.targetAnchor || Ig(m, t, d, p), g(L && a(L), t, m, n, r, i, s)
            } Iu(t, E)
    }
    return t.anchor && a(t.anchor)
}
const T2 = Fg;

function Iu(e, t) {
    const n = e.ctx;
    if (n && n.ut) {
        let r, i;
        for (t ? (r = e.el, i = e.anchor) : (r = e.targetStart, i = e.targetAnchor); r && r !== i;) r.nodeType === 1 && r.setAttribute("data-v-owner", n.uid), r = r.nextSibling;
        n.ut()
    }
}

function Ig(e, t, n, r) {
    const i = t.targetStart = n(""),
        s = t.targetAnchor = n("");
    return i[Mg] = s, e && (r(i, e), r(s, e)), s
}
const Oo = Symbol("_leaveCb"),
    wu = Symbol("_enterCb");

function Ng() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return $i(() => {
        e.isMounted = !0
    }), va(() => {
        e.isUnmounting = !0
    }), e
}
const _s = [Function, Array],
    Bg = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: _s,
        onEnter: _s,
        onAfterEnter: _s,
        onEnterCancelled: _s,
        onBeforeLeave: _s,
        onLeave: _s,
        onAfterLeave: _s,
        onLeaveCancelled: _s,
        onBeforeAppear: _s,
        onAppear: _s,
        onAfterAppear: _s,
        onAppearCancelled: _s
    },
    $g = e => {
        const t = e.subTree;
        return t.component ? $g(t.component) : t
    },
    ly = {
        name: "BaseTransition",
        props: Bg,
        setup(e, {
            slots: t
        }) {
            const n = wi(),
                r = Ng();
            return () => {
                const i = t.default && Eh(t.default(), !0);
                if (!i || !i.length) return;
                const s = Hg(i),
                    a = Bn(e),
                    {
                        mode: c
                    } = a;
                if (r.isLeaving) return Kc(s);
                const u = ad(s);
                if (!u) return Kc(s);
                let p = jl(u, a, r, n, g => p = g);
                u.type !== pi && Vo(u, p);
                let d = n.subTree && ad(n.subTree);
                if (d && d.type !== pi && !Os(u, d) && $g(n).type !== pi) {
                    let g = jl(d, a, r, n);
                    if (Vo(d, g), c === "out-in" && u.type !== pi) return r.isLeaving = !0, g.afterLeave = () => {
                        r.isLeaving = !1, n.job.flags & 8 || n.update(), delete g.afterLeave, d = void 0
                    }, Kc(s);
                    c === "in-out" && u.type !== pi ? g.delayLeave = (m, E, L) => {
                        const b = Vg(r, d);
                        b[String(d.key)] = d, m[Oo] = () => {
                            E(), m[Oo] = void 0, delete p.delayedLeave, d = void 0
                        }, p.delayedLeave = () => {
                            L(), delete p.delayedLeave, d = void 0
                        }
                    } : d = void 0
                } else d && (d = void 0);
                return s
            }
        }
    };

function Hg(e) {
    let t = e[0];
    if (e.length > 1) {
        for (const n of e)
            if (n.type !== pi) {
                t = n;
                break
            }
    }
    return t
}
const uy = ly;

function Vg(e, t) {
    const {
        leavingVNodes: n
    } = e;
    let r = n.get(t.type);
    return r || (r = Object.create(null), n.set(t.type, r)), r
}

function jl(e, t, n, r, i) {
    const {
        appear: s,
        mode: a,
        persisted: c = !1,
        onBeforeEnter: u,
        onEnter: p,
        onAfterEnter: d,
        onEnterCancelled: g,
        onBeforeLeave: m,
        onLeave: E,
        onAfterLeave: L,
        onLeaveCancelled: b,
        onBeforeAppear: j,
        onAppear: A,
        onAfterAppear: $,
        onAppearCancelled: w
    } = t, k = String(e.key), S = Vg(n, e), X = (he, me) => {
        he && Is(he, r, 9, me)
    }, J = (he, me) => {
        const Q = me[1];
        X(he, me), Wt(he) ? he.every(ne => ne.length <= 1) && Q() : he.length <= 1 && Q()
    }, xe = {
        mode: a,
        persisted: c,
        beforeEnter(he) {
            let me = u;
            if (!n.isMounted)
                if (s) me = j || u;
                else return;
            he[Oo] && he[Oo](!0);
            const Q = S[k];
            Q && Os(e, Q) && Q.el[Oo] && Q.el[Oo](), X(me, [he])
        },
        enter(he) {
            let me = p,
                Q = d,
                ne = g;
            if (!n.isMounted)
                if (s) me = A || p, Q = $ || d, ne = w || g;
                else return;
            let re = !1;
            const K = he[wu] = te => {
                re || (re = !0, te ? X(ne, [he]) : X(Q, [he]), xe.delayedLeave && xe.delayedLeave(), he[wu] = void 0)
            };
            me ? J(me, [he, K]) : K()
        },
        leave(he, me) {
            const Q = String(e.key);
            if (he[wu] && he[wu](!0), n.isUnmounting) return me();
            X(m, [he]);
            let ne = !1;
            const re = he[Oo] = K => {
                ne || (ne = !0, me(), K ? X(b, [he]) : X(L, [he]), he[Oo] = void 0, S[Q] === e && delete S[Q])
            };
            S[Q] = e, E ? J(E, [he, re]) : re()
        },
        clone(he) {
            const me = jl(he, t, n, r, i);
            return i && i(me), me
        }
    };
    return xe
}

function Kc(e) {
    if (nu(e)) return e = yo(e), e.children = null, e
}

function ad(e) {
    if (!nu(e)) return Lg(e.type) && e.children ? Hg(e.children) : e;
    const {
        shapeFlag: t,
        children: n
    } = e;
    if (n) {
        if (t & 16) return n[0];
        if (t & 32 && ln(n.default)) return n.default()
    }
}

function Vo(e, t) {
    e.shapeFlag & 6 && e.component ? (e.transition = t, Vo(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}

function Eh(e, t = !1, n) {
    let r = [],
        i = 0;
    for (let s = 0; s < e.length; s++) {
        let a = e[s];
        const c = n == null ? a.key : String(n) + String(a.key != null ? a.key : s);
        a.type === zr ? (a.patchFlag & 128 && i++, r = r.concat(Eh(a.children, t, c))) : (t || a.type !== pi) && r.push(c != null ? yo(a, {
            key: c
        }) : a)
    }
    if (i > 1)
        for (let s = 0; s < r.length; s++) r[s].patchFlag = -2;
    return r
} /*! #__NO_SIDE_EFFECTS__ */
function Jr(e, t) {
    return ln(e) ? cr({
        name: e.name
    }, t, {
        setup: e
    }) : e
}

function cy() {
    const e = wi();
    return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : ""
}

function Ch(e) {
    e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0]
}

function Wn(e) {
    const t = wi(),
        n = Ur(null);
    if (t) {
        const i = t.refs === $n ? t.refs = {} : t.refs;
        Object.defineProperty(i, e, {
            enumerable: !0,
            get: () => n.value,
            set: s => n.value = s
        })
    }
    return n
}

function Ul(e, t, n, r, i = !1) {
    if (Wt(e)) {
        e.forEach((L, b) => Ul(L, t && (Wt(t) ? t[b] : t), n, r, i));
        return
    }
    if (No(r) && !i) {
        r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && Ul(e, t, n, r.component.subTree);
        return
    }
    const s = r.shapeFlag & 4 ? iu(r.component) : r.el,
        a = i ? null : s,
        {
            i: c,
            r: u
        } = e,
        p = t && t.r,
        d = c.refs === $n ? c.refs = {} : c.refs,
        g = c.setupState,
        m = Bn(g),
        E = g === $n ? () => !1 : L => Xn(m, L);
    if (p != null && p !== u && (yr(p) ? (d[p] = null, E(p) && (g[p] = null)) : mr(p) && (p.value = null)), ln(u)) tu(u, c, 12, [a, d]);
    else {
        const L = yr(u),
            b = mr(u);
        if (L || b) {
            const j = () => {
                if (e.f) {
                    const A = L ? E(u) ? g[u] : d[u] : u.value;
                    i ? Wt(A) && gh(A, s) : Wt(A) ? A.includes(s) || A.push(s) : L ? (d[u] = [s], E(u) && (g[u] = d[u])) : (u.value = [s], e.k && (d[e.k] = u.value))
                } else L ? (d[u] = a, E(u) && (g[u] = a)) : b && (u.value = a, e.k && (d[e.k] = a))
            };
            a ? (j.id = -1, di(j, n)) : j()
        }
    }
}
let ld = !1;
const Sa = () => {
        ld || (console.error("Hydration completed but contains mismatches."), ld = !0)
    },
    fy = e => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject",
    hy = e => e.namespaceURI.includes("MathML"),
    Du = e => {
        if (e.nodeType === 1) {
            if (fy(e)) return "svg";
            if (hy(e)) return "mathml"
        }
    },
    Oa = e => e.nodeType === 8;

function dy(e) {
    const {
        mt: t,
        p: n,
        o: {
            patchProp: r,
            createText: i,
            nextSibling: s,
            parentNode: a,
            remove: c,
            insert: u,
            createComment: p
        }
    } = e, d = (w, k) => {
        if (!k.hasChildNodes()) {
            n(null, w, k), Ku(), k._vnode = w;
            return
        }
        g(k.firstChild, w, null, null, null), Ku(), k._vnode = w
    }, g = (w, k, S, X, J, xe = !1) => {
        xe = xe || !!k.dynamicChildren;
        const he = Oa(w) && w.data === "[",
            me = () => b(w, k, S, X, J, he),
            {
                type: Q,
                ref: ne,
                shapeFlag: re,
                patchFlag: K
            } = k;
        let te = w.nodeType;
        k.el = w, K === -2 && (xe = !1, k.dynamicChildren = null);
        let G = null;
        switch (Q) {
            case ha:
                te !== 3 ? k.children === "" ? (u(k.el = i(""), a(w), w), G = w) : G = me() : (w.data !== k.children && (Sa(), w.data = k.children), G = s(w));
                break;
            case pi:
                $(w) ? (G = s(w), A(k.el = w.content.firstChild, w, S)) : te !== 8 || he ? G = me() : G = s(w);
                break;
            case Ha:
                if (he && (w = s(w), te = w.nodeType), te === 1 || te === 3) {
                    G = w;
                    const ce = !k.children.length;
                    for (let le = 0; le < k.staticCount; le++) ce && (k.children += G.nodeType === 1 ? G.outerHTML : G.data), le === k.staticCount - 1 && (k.anchor = G), G = s(G);
                    return he ? s(G) : G
                } else me();
                break;
            case zr:
                he ? G = L(w, k, S, X, J, xe) : G = me();
                break;
            default:
                if (re & 1)(te !== 1 || k.type.toLowerCase() !== w.tagName.toLowerCase()) && !$(w) ? G = me() : G = m(w, k, S, X, J, xe);
                else if (re & 6) {
                    k.slotScopeIds = J;
                    const ce = a(w);
                    if (he ? G = j(w) : Oa(w) && w.data === "teleport start" ? G = j(w, w.data, "teleport end") : G = s(w), t(k, ce, null, S, X, Du(ce), xe), No(k) && !k.type.__asyncResolved) {
                        let le;
                        he ? (le = wn(zr), le.anchor = G ? G.previousSibling : ce.lastChild) : le = w.nodeType === 3 ? Gl("") : wn("div"), le.el = w, k.component.subTree = le
                    }
                } else re & 64 ? te !== 8 ? G = me() : G = k.type.hydrate(w, k, S, X, J, xe, e, E) : re & 128 && (G = k.type.hydrate(w, k, S, X, Du(a(w)), J, xe, e, g))
        }
        return ne != null && Ul(ne, null, X, k), G
    }, m = (w, k, S, X, J, xe) => {
        xe = xe || !!k.dynamicChildren;
        const {
            type: he,
            props: me,
            patchFlag: Q,
            shapeFlag: ne,
            dirs: re,
            transition: K
        } = k, te = he === "input" || he === "option";
        if (te || Q !== -1) {
            re && Xs(k, null, S, "created");
            let G = !1;
            if ($(w)) {
                G = u_(null, K) && S && S.vnode.props && S.vnode.props.appear;
                const le = w.content.firstChild;
                G && K.beforeEnter(le), A(le, w, S), k.el = w = le
            }
            if (ne & 16 && !(me && (me.innerHTML || me.textContent))) {
                let le = E(w.firstChild, k, w, S, X, J, xe);
                for (; le;) {
                    xu(w, 1) || Sa();
                    const ve = le;
                    le = le.nextSibling, c(ve)
                }
            } else if (ne & 8) {
                let le = k.children;
                le[0] === `
` && (w.tagName === "PRE" || w.tagName === "TEXTAREA") && (le = le.slice(1)), w.textContent !== le && (xu(w, 0) || Sa(), w.textContent = k.children)
            }
            if (me) {
                if (te || !xe || Q & 48) {
                    const le = w.tagName.includes("-");
                    for (const ve in me)(te && (ve.endsWith("value") || ve === "indeterminate") || Zl(ve) && !Fa(ve) || ve[0] === "." || le) && r(w, ve, null, me[ve], void 0, S)
                } else if (me.onClick) r(w, "onClick", null, me.onClick, void 0, S);
                else if (Q & 4 && mo(me.style))
                    for (const le in me.style) me.style[le]
            }
            let ce;
            (ce = me && me.onVnodeBeforeMount) && ns(ce, S, k), re && Xs(k, null, S, "beforeMount"), ((ce = me && me.onVnodeMounted) || re || G) && g_(() => {
                ce && ns(ce, S, k), G && K.enter(w), re && Xs(k, null, S, "mounted")
            }, X)
        }
        return w.nextSibling
    }, E = (w, k, S, X, J, xe, he) => {
        he = he || !!k.dynamicChildren;
        const me = k.children,
            Q = me.length;
        for (let ne = 0; ne < Q; ne++) {
            const re = he ? me[ne] : me[ne] = rs(me[ne]),
                K = re.type === ha;
            w ? (K && !he && ne + 1 < Q && rs(me[ne + 1]).type === ha && (u(i(w.data.slice(re.children.length)), S, s(w)), w.data = re.children), w = g(w, re, X, J, xe, he)) : K && !re.children ? u(re.el = i(""), S) : (xu(S, 1) || Sa(), n(null, re, S, null, X, J, Du(S), xe))
        }
        return w
    }, L = (w, k, S, X, J, xe) => {
        const {
            slotScopeIds: he
        } = k;
        he && (J = J ? J.concat(he) : he);
        const me = a(w),
            Q = E(s(w), k, me, S, X, J, xe);
        return Q && Oa(Q) && Q.data === "]" ? s(k.anchor = Q) : (Sa(), u(k.anchor = p("]"), me, Q), Q)
    }, b = (w, k, S, X, J, xe) => {
        if (xu(w.parentElement, 1) || Sa(), k.el = null, xe) {
            const Q = j(w);
            for (;;) {
                const ne = s(w);
                if (ne && ne !== Q) c(ne);
                else break
            }
        }
        const he = s(w),
            me = a(w);
        return c(w), n(null, k, me, he, S, X, Du(me), J), S && (S.vnode.el = k.el, Ac(S, k.el)), he
    }, j = (w, k = "[", S = "]") => {
        let X = 0;
        for (; w;)
            if (w = s(w), w && Oa(w) && (w.data === k && X++, w.data === S)) {
                if (X === 0) return s(w);
                X--
            } return w
    }, A = (w, k, S) => {
        const X = k.parentNode;
        X && X.replaceChild(w, k);
        let J = S;
        for (; J;) J.vnode.el === k && (J.vnode.el = J.subTree.el = w), J = J.parent
    }, $ = w => w.nodeType === 1 && w.tagName === "TEMPLATE";
    return [d, g]
}
const ud = "data-allow-mismatch",
    py = {
        0: "text",
        1: "children",
        2: "class",
        3: "style",
        4: "attribute"
    };

function xu(e, t) {
    if (t === 0 || t === 1)
        for (; e && !e.hasAttribute(ud);) e = e.parentElement;
    const n = e && e.getAttribute(ud);
    if (n == null) return !1;
    if (n === "") return !0;
    {
        const r = n.split(",");
        return t === 0 && r.includes("children") ? !0 : n.split(",").includes(py[t])
    }
}
const gy = vc().requestIdleCallback || (e => setTimeout(e, 1)),
    _y = vc().cancelIdleCallback || (e => clearTimeout(e)),
    P2 = (e = 1e4) => t => {
        const n = gy(t, {
            timeout: e
        });
        return () => _y(n)
    };

function my(e) {
    const {
        top: t,
        left: n,
        bottom: r,
        right: i
    } = e.getBoundingClientRect(), {
        innerHeight: s,
        innerWidth: a
    } = window;
    return (t > 0 && t < s || r > 0 && r < s) && (n > 0 && n < a || i > 0 && i < a)
}
const k2 = e => (t, n) => {
        const r = new IntersectionObserver(i => {
            for (const s of i)
                if (s.isIntersecting) {
                    r.disconnect(), t();
                    break
                }
        }, e);
        return n(i => {
            if (i instanceof Element) {
                if (my(i)) return t(), r.disconnect(), !1;
                r.observe(i)
            }
        }), () => r.disconnect()
    },
    A2 = e => t => {
        if (e) {
            const n = matchMedia(e);
            if (n.matches) t();
            else return n.addEventListener("change", t, {
                once: !0
            }), () => n.removeEventListener("change", t)
        }
    },
    R2 = (e = []) => (t, n) => {
        yr(e) && (e = [e]);
        let r = !1;
        const i = a => {
                r || (r = !0, s(), t(), a.target.dispatchEvent(new a.constructor(a.type, a)))
            },
            s = () => {
                n(a => {
                    for (const c of e) a.removeEventListener(c, i)
                })
            };
        return n(a => {
            for (const c of e) a.addEventListener(c, i, {
                once: !0
            })
        }), s
    };

function yy(e, t) {
    if (Oa(e) && e.data === "[") {
        let n = 1,
            r = e.nextSibling;
        for (; r;) {
            if (r.nodeType === 1) {
                if (t(r) === !1) break
            } else if (Oa(r))
                if (r.data === "]") {
                    if (--n === 0) break
                } else r.data === "[" && n++;
            r = r.nextSibling
        }
    } else t(e)
}
const No = e => !!e.type.__asyncLoader; /*! #__NO_SIDE_EFFECTS__ */
function Qt(e) {
    ln(e) && (e = {
        loader: e
    });
    const {
        loader: t,
        loadingComponent: n,
        errorComponent: r,
        delay: i = 200,
        hydrate: s,
        timeout: a,
        suspensible: c = !0,
        onError: u
    } = e;
    let p = null,
        d, g = 0;
    const m = () => (g++, p = null, E()),
        E = () => {
            let L;
            return p || (L = p = t().catch(b => {
                if (b = b instanceof Error ? b : new Error(String(b)), u) return new Promise((j, A) => {
                    u(b, () => j(m()), () => A(b), g + 1)
                });
                throw b
            }).then(b => L !== p && p ? p : (b && (b.__esModule || b[Symbol.toStringTag] === "Module") && (b = b.default), d = b, b)))
        };
    return Jr({
        name: "AsyncComponentWrapper",
        __asyncLoader: E,
        __asyncHydrate(L, b, j) {
            const A = s ? () => {
                const $ = s(j, w => yy(L, w));
                $ && (b.bum || (b.bum = [])).push($)
            } : j;
            d ? A() : E().then(() => !b.isUnmounted && A())
        },
        get __asyncResolved() {
            return d
        },
        setup() {
            const L = gi;
            if (Ch(L), d) return () => Qc(d, L);
            const b = w => {
                p = null, Qa(w, L, 13, !r)
            };
            if (c && L.suspense || ja) return E().then(w => () => Qc(w, L)).catch(w => (b(w), () => r ? wn(r, {
                error: w
            }) : null));
            const j = kn(!1),
                A = kn(),
                $ = kn(!!i);
            return i && setTimeout(() => {
                $.value = !1
            }, i), a != null && setTimeout(() => {
                if (!j.value && !A.value) {
                    const w = new Error(`Async component timed out after ${a}ms.`);
                    b(w), A.value = w
                }
            }, a), E().then(() => {
                j.value = !0, L.parent && nu(L.parent.vnode) && L.parent.update()
            }).catch(w => {
                b(w), A.value = w
            }), () => {
                if (j.value && d) return Qc(d, L);
                if (A.value && r) return wn(r, {
                    error: A.value
                });
                if (n && !$.value) return wn(n)
            }
        }
    })
}

function Qc(e, t) {
    const {
        ref: n,
        props: r,
        children: i,
        ce: s
    } = t.vnode, a = wn(e, r, i);
    return a.ref = n, a.ce = s, delete t.vnode.ce, a
}
const nu = e => e.type.__isKeepAlive,
    vy = {
        name: "KeepAlive",
        __isKeepAlive: !0,
        props: {
            include: [String, RegExp, Array],
            exclude: [String, RegExp, Array],
            max: [String, Number]
        },
        setup(e, {
            slots: t
        }) {
            const n = wi(),
                r = n.ctx;
            if (!r.renderer) return () => {
                const $ = t.default && t.default();
                return $ && $.length === 1 ? $[0] : $
            };
            const i = new Map,
                s = new Set;
            let a = null;
            const c = n.suspense,
                {
                    renderer: {
                        p: u,
                        m: p,
                        um: d,
                        o: {
                            createElement: g
                        }
                    }
                } = r,
                m = g("div");
            r.activate = ($, w, k, S, X) => {
                const J = $.component;
                p($, w, k, 0, c), u(J.vnode, $, w, k, J, c, S, $.slotScopeIds, X), di(() => {
                    J.isDeactivated = !1, J.a && Ia(J.a);
                    const xe = $.props && $.props.onVnodeMounted;
                    xe && ns(xe, J.parent, $)
                }, c)
            }, r.deactivate = $ => {
                const w = $.component;
                Zu(w.m), Zu(w.a), p($, m, null, 1, c), di(() => {
                    w.da && Ia(w.da);
                    const k = $.props && $.props.onVnodeUnmounted;
                    k && ns(k, w.parent, $), w.isDeactivated = !0
                }, c)
            };

            function E($) {
                Jc($), d($, n, c, !0)
            }

            function L($) {
                i.forEach((w, k) => {
                    const S = Nf(w.type);
                    S && !$(S) && b(k)
                })
            }

            function b($) {
                const w = i.get($);
                w && (!a || !Os(w, a)) ? E(w) : a && Jc(a), i.delete($), s.delete($)
            }
            Qr(() => [e.include, e.exclude], ([$, w]) => {
                $ && L(k => gl($, k)), w && L(k => !gl(w, k))
            }, {
                flush: "post",
                deep: !0
            });
            let j = null;
            const A = () => {
                j != null && (ec(n.subTree.type) ? di(() => {
                    i.set(j, Eu(n.subTree))
                }, n.subTree.suspense) : i.set(j, Eu(n.subTree)))
            };
            return $i(A), Sh(A), va(() => {
                i.forEach($ => {
                    const {
                        subTree: w,
                        suspense: k
                    } = n, S = Eu(w);
                    if ($.type === S.type && $.key === S.key) {
                        Jc(S);
                        const X = S.component.da;
                        X && di(X, k);
                        return
                    }
                    E($)
                })
            }), () => {
                if (j = null, !t.default) return a = null;
                const $ = t.default(),
                    w = $[0];
                if ($.length > 1) return a = null, $;
                if (!zo(w) || !(w.shapeFlag & 4) && !(w.shapeFlag & 128)) return a = null, w;
                let k = Eu(w);
                if (k.type === pi) return a = null, k;
                const S = k.type,
                    X = Nf(No(k) ? k.type.__asyncResolved || {} : S),
                    {
                        include: J,
                        exclude: xe,
                        max: he
                    } = e;
                if (J && (!X || !gl(J, X)) || xe && X && gl(xe, X)) return k.shapeFlag &= -257, a = k, w;
                const me = k.key == null ? S : k.key,
                    Q = i.get(me);
                return k.el && (k = yo(k), w.shapeFlag & 128 && (w.ssContent = k)), j = me, Q ? (k.el = Q.el, k.component = Q.component, k.transition && Vo(k, k.transition), k.shapeFlag |= 512, s.delete(me), s.add(me)) : (s.add(me), he && s.size > parseInt(he, 10) && b(s.values().next().value)), k.shapeFlag |= 256, a = k, ec(w.type) ? w : k
            }
        }
    },
    by = vy;

function gl(e, t) {
    return Wt(e) ? e.some(n => gl(n, t)) : yr(e) ? e.split(",").includes(t) : pm(e) ? (e.lastIndex = 0, e.test(t)) : !1
}

function zg(e, t) {
    Ug(e, "a", t)
}

function jg(e, t) {
    Ug(e, "da", t)
}

function Ug(e, t, n = gi) {
    const r = e.__wdc || (e.__wdc = () => {
        let i = n;
        for (; i;) {
            if (i.isDeactivated) return;
            i = i.parent
        }
        return e()
    });
    if (Tc(t, r, n), n) {
        let i = n.parent;
        for (; i && i.parent;) nu(i.parent.vnode) && wy(r, t, n, i), i = i.parent
    }
}

function wy(e, t, n, r) {
    const i = Tc(t, e, r, !0);
    Pc(() => {
        gh(r[t], i)
    }, n)
}

function Jc(e) {
    e.shapeFlag &= -257, e.shapeFlag &= -513
}

function Eu(e) {
    return e.shapeFlag & 128 ? e.ssContent : e
}

function Tc(e, t, n = gi, r = !1) {
    if (n) {
        const i = n[e] || (n[e] = []),
            s = t.__weh || (t.__weh = (...a) => {
                Wo();
                const c = _a(n),
                    u = Is(t, n, e, a);
                return c(), qo(), u
            });
        return r ? i.unshift(s) : i.push(s), s
    }
}
const vo = e => (t, n = gi) => {
        (!ja || e === "sp") && Tc(e, (...r) => t(...r), n)
    },
    Wg = vo("bm"),
    $i = vo("m"),
    qg = vo("bu"),
    Sh = vo("u"),
    va = vo("bum"),
    Pc = vo("um"),
    Dy = vo("sp"),
    xy = vo("rtg"),
    Ey = vo("rtc");

function Gg(e, t = gi) {
    Tc("ec", e, t)
}
const Th = "components",
    Cy = "directives";

function cd(e, t) {
    return Ph(Th, e, !0, t) || e
}
const Yg = Symbol.for("v-ndc");

function Al(e) {
    return yr(e) ? Ph(Th, e, !1) || e : e || Yg
}

function O2(e) {
    return Ph(Cy, e)
}

function Ph(e, t, n = !0, r = !1) {
    const i = _i || gi;
    if (i) {
        const s = i.type;
        if (e === Th) {
            const c = Nf(s, !1);
            if (c && (c === t || c === Bi(t) || c === eu(Bi(t)))) return s
        }
        const a = fd(i[e] || s[e], t) || fd(i.appContext[e], t);
        return !a && r ? s : a
    }
}

function fd(e, t) {
    return e && (e[t] || e[Bi(t)] || e[eu(Bi(t))])
}

function Qu(e, t, n, r) {
    let i;
    const s = n && n[r],
        a = Wt(e);
    if (a || yr(e)) {
        const c = a && mo(e);
        let u = !1;
        c && (u = !bs(e), e = xc(e)), i = new Array(e.length);
        for (let p = 0, d = e.length; p < d; p++) i[p] = t(u ? Ii(e[p]) : e[p], p, void 0, s && s[p])
    } else if (typeof e == "number") {
        i = new Array(e);
        for (let c = 0; c < e; c++) i[c] = t(c + 1, c, void 0, s && s[c])
    } else if (or(e))
        if (e[Symbol.iterator]) i = Array.from(e, (c, u) => t(c, u, void 0, s && s[u]));
        else {
            const c = Object.keys(e);
            i = new Array(c.length);
            for (let u = 0, p = c.length; u < p; u++) {
                const d = c[u];
                i[u] = t(e[d], d, u, s && s[u])
            }
        }
    else i = [];
    return n && (n[r] = i), i
}

function M2(e, t) {
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (Wt(r))
            for (let i = 0; i < r.length; i++) e[r[i].name] = r[i].fn;
        else r && (e[r.name] = r.key ? (...i) => {
            const s = r.fn(...i);
            return s && (s.key = r.key), s
        } : r.fn)
    }
    return e
}

function Xg(e, t, n = {}, r, i) {
    if (_i.ce || _i.parent && No(_i.parent) && _i.parent.ce) return t !== "default" && (n.name = t), Mn(), cs(zr, null, [wn("slot", n, r && r())], 64);
    let s = e[t];
    s && s._c && (s._d = !1), Mn();
    const a = s && kh(s(n)),
        c = n.key || a && a.key,
        u = cs(zr, {
            key: (c && !Fs(c) ? c : `_${t}`) + (!a && r ? "_fb" : "")
        }, a || (r ? r() : []), a && e._ === 1 ? 64 : -2);
    return !i && u.scopeId && (u.slotScopeIds = [u.scopeId + "-s"]), s && s._c && (s._d = !0), u
}

function kh(e) {
    return e.some(t => zo(t) ? !(t.type === pi || t.type === zr && !kh(t.children)) : !0) ? e : null
}

function L2(e, t) {
    const n = {};
    for (const r in e) n[t && /[A-Z]/.test(r) ? `on:${r}` : Fu(r)] = e[r];
    return n
}
const Tf = e => e ? D_(e) ? iu(e) : Tf(e.parent) : null,
    Rl = cr(Object.create(null), {
        $: e => e,
        $el: e => e.vnode.el,
        $data: e => e.data,
        $props: e => e.props,
        $attrs: e => e.attrs,
        $slots: e => e.slots,
        $refs: e => e.refs,
        $parent: e => Tf(e.parent),
        $root: e => Tf(e.root),
        $host: e => e.ce,
        $emit: e => e.emit,
        $options: e => Ah(e),
        $forceUpdate: e => e.f || (e.f = () => {
            xh(e.update)
        }),
        $nextTick: e => e.n || (e.n = ss.bind(e.proxy)),
        $watch: e => Gy.bind(e)
    }),
    Zc = (e, t) => e !== $n && !e.__isScriptSetup && Xn(e, t),
    Pf = {
        get({
            _: e
        }, t) {
            if (t === "__v_skip") return !0;
            const {
                ctx: n,
                setupState: r,
                data: i,
                props: s,
                accessCache: a,
                type: c,
                appContext: u
            } = e;
            let p;
            if (t[0] !== "$") {
                const E = a[t];
                if (E !== void 0) switch (E) {
                    case 1:
                        return r[t];
                    case 2:
                        return i[t];
                    case 4:
                        return n[t];
                    case 3:
                        return s[t]
                } else {
                    if (Zc(r, t)) return a[t] = 1, r[t];
                    if (i !== $n && Xn(i, t)) return a[t] = 2, i[t];
                    if ((p = e.propsOptions[0]) && Xn(p, t)) return a[t] = 3, s[t];
                    if (n !== $n && Xn(n, t)) return a[t] = 4, n[t];
                    kf && (a[t] = 0)
                }
            }
            const d = Rl[t];
            let g, m;
            if (d) return t === "$attrs" && Fi(e.attrs, "get", ""), d(e);
            if ((g = c.__cssModules) && (g = g[t])) return g;
            if (n !== $n && Xn(n, t)) return a[t] = 4, n[t];
            if (m = u.config.globalProperties, Xn(m, t)) return m[t]
        },
        set({
            _: e
        }, t, n) {
            const {
                data: r,
                setupState: i,
                ctx: s
            } = e;
            return Zc(i, t) ? (i[t] = n, !0) : r !== $n && Xn(r, t) ? (r[t] = n, !0) : Xn(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (s[t] = n, !0)
        },
        has({
            _: {
                data: e,
                setupState: t,
                accessCache: n,
                ctx: r,
                appContext: i,
                propsOptions: s
            }
        }, a) {
            let c;
            return !!n[a] || e !== $n && Xn(e, a) || Zc(t, a) || (c = s[0]) && Xn(c, a) || Xn(r, a) || Xn(Rl, a) || Xn(i.config.globalProperties, a)
        },
        defineProperty(e, t, n) {
            return n.get != null ? e._.accessCache[t] = 0 : Xn(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n)
        }
    },
    Sy = cr({}, Pf, {
        get(e, t) {
            if (t !== Symbol.unscopables) return Pf.get(e, t, e)
        },
        has(e, t) {
            return t[0] !== "_" && !vm(t)
        }
    });

function F2() {
    return null
}

function I2() {
    return null
}

function N2(e) {}

function B2(e) {}

function $2() {
    return null
}

function H2() {}

function V2(e, t) {
    return null
}

function z2() {
    return Kg().slots
}

function j2() {
    return Kg().attrs
}

function Kg() {
    const e = wi();
    return e.setupContext || (e.setupContext = C_(e))
}

function Wl(e) {
    return Wt(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e
}

function U2(e, t) {
    const n = Wl(e);
    for (const r in t) {
        if (r.startsWith("__skip")) continue;
        let i = n[r];
        i ? Wt(i) || ln(i) ? i = n[r] = {
            type: i,
            default: t[r]
        } : i.default = t[r] : i === null && (i = n[r] = {
            default: t[r]
        }), i && t[`__skip_${r}`] && (i.skipFactory = !0)
    }
    return n
}

function W2(e, t) {
    return !e || !t ? e || t : Wt(e) && Wt(t) ? e.concat(t) : cr({}, Wl(e), Wl(t))
}

function q2(e, t) {
    const n = {};
    for (const r in e) t.includes(r) || Object.defineProperty(n, r, {
        enumerable: !0,
        get: () => e[r]
    });
    return n
}

function Ty(e) {
    const t = wi();
    let n = e();
    return Lf(), _h(n) && (n = n.catch(r => {
        throw _a(t), r
    })), [n, () => _a(t)]
}
let kf = !0;

function Py(e) {
    const t = Ah(e),
        n = e.proxy,
        r = e.ctx;
    kf = !1, t.beforeCreate && hd(t.beforeCreate, e, "bc");
    const {
        data: i,
        computed: s,
        methods: a,
        watch: c,
        provide: u,
        inject: p,
        created: d,
        beforeMount: g,
        mounted: m,
        beforeUpdate: E,
        updated: L,
        activated: b,
        deactivated: j,
        beforeDestroy: A,
        beforeUnmount: $,
        destroyed: w,
        unmounted: k,
        render: S,
        renderTracked: X,
        renderTriggered: J,
        errorCaptured: xe,
        serverPrefetch: he,
        expose: me,
        inheritAttrs: Q,
        components: ne,
        directives: re,
        filters: K
    } = t;
    if (p && ky(p, r, null), a)
        for (const ce in a) {
            const le = a[ce];
            ln(le) && (r[ce] = le.bind(n))
        }
    if (i) {
        const ce = i.call(n, n);
        or(ce) && (e.data = mi(ce))
    }
    if (kf = !0, s)
        for (const ce in s) {
            const le = s[ce],
                ve = ln(le) ? le.bind(n, n) : ln(le.get) ? le.get.bind(n, n) : vs,
                tt = !ln(le) && ln(le.set) ? le.set.bind(n) : vs,
                ht = xn({
                    get: ve,
                    set: tt
                });
            Object.defineProperty(r, ce, {
                enumerable: !0,
                configurable: !0,
                get: () => ht.value,
                set: lt => ht.value = lt
            })
        }
    if (c)
        for (const ce in c) Qg(c[ce], r, n, ce);
    if (u) {
        const ce = ln(u) ? u.call(n) : u;
        Reflect.ownKeys(ce).forEach(le => {
            ws(le, ce[le])
        })
    }
    d && hd(d, e, "c");

    function G(ce, le) {
        Wt(le) ? le.forEach(ve => ce(ve.bind(n))) : le && ce(le.bind(n))
    }
    if (G(Wg, g), G($i, m), G(qg, E), G(Sh, L), G(zg, b), G(jg, j), G(Gg, xe), G(Ey, X), G(xy, J), G(va, $), G(Pc, k), G(Dy, he), Wt(me))
        if (me.length) {
            const ce = e.exposed || (e.exposed = {});
            me.forEach(le => {
                Object.defineProperty(ce, le, {
                    get: () => n[le],
                    set: ve => n[le] = ve
                })
            })
        } else e.exposed || (e.exposed = {});
    S && e.render === vs && (e.render = S), Q != null && (e.inheritAttrs = Q), ne && (e.components = ne), re && (e.directives = re), he && Ch(e)
}

function ky(e, t, n = vs) {
    Wt(e) && (e = Af(e));
    for (const r in e) {
        const i = e[r];
        let s;
        or(i) ? "default" in i ? s = Er(i.from || r, i.default, !0) : s = Er(i.from || r) : s = Er(i), mr(s) ? Object.defineProperty(t, r, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: a => s.value = a
        }) : t[r] = s
    }
}

function hd(e, t, n) {
    Is(Wt(e) ? e.map(r => r.bind(t.proxy)) : e.bind(t.proxy), t, n)
}

function Qg(e, t, n, r) {
    let i = r.includes(".") ? f_(n, r) : () => n[r];
    if (yr(e)) {
        const s = t[e];
        ln(s) && Qr(i, s)
    } else if (ln(e)) Qr(i, e.bind(n));
    else if (or(e))
        if (Wt(e)) e.forEach(s => Qg(s, t, n, r));
        else {
            const s = ln(e.handler) ? e.handler.bind(n) : t[e.handler];
            ln(s) && Qr(i, s, e)
        }
}

function Ah(e) {
    const t = e.type,
        {
            mixins: n,
            extends: r
        } = t,
        {
            mixins: i,
            optionsCache: s,
            config: {
                optionMergeStrategies: a
            }
        } = e.appContext,
        c = s.get(t);
    let u;
    return c ? u = c : !i.length && !n && !r ? u = t : (u = {}, i.length && i.forEach(p => Ju(u, p, a, !0)), Ju(u, t, a)), or(t) && s.set(t, u), u
}

function Ju(e, t, n, r = !1) {
    const {
        mixins: i,
        extends: s
    } = t;
    s && Ju(e, s, n, !0), i && i.forEach(a => Ju(e, a, n, !0));
    for (const a in t)
        if (!(r && a === "expose")) {
            const c = Ay[a] || n && n[a];
            e[a] = c ? c(e[a], t[a]) : t[a]
        } return e
}
const Ay = {
    data: dd,
    props: pd,
    emits: pd,
    methods: _l,
    computed: _l,
    beforeCreate: qi,
    created: qi,
    beforeMount: qi,
    mounted: qi,
    beforeUpdate: qi,
    updated: qi,
    beforeDestroy: qi,
    beforeUnmount: qi,
    destroyed: qi,
    unmounted: qi,
    activated: qi,
    deactivated: qi,
    errorCaptured: qi,
    serverPrefetch: qi,
    components: _l,
    directives: _l,
    watch: Oy,
    provide: dd,
    inject: Ry
};

function dd(e, t) {
    return t ? e ? function() {
        return cr(ln(e) ? e.call(this, this) : e, ln(t) ? t.call(this, this) : t)
    } : t : e
}

function Ry(e, t) {
    return _l(Af(e), Af(t))
}

function Af(e) {
    if (Wt(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
        return t
    }
    return e
}

function qi(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}

function _l(e, t) {
    return e ? cr(Object.create(null), e, t) : t
}

function pd(e, t) {
    return e ? Wt(e) && Wt(t) ? [...new Set([...e, ...t])] : cr(Object.create(null), Wl(e), Wl(t ?? {})) : t
}

function Oy(e, t) {
    if (!e) return t;
    if (!t) return e;
    const n = cr(Object.create(null), e);
    for (const r in t) n[r] = qi(e[r], t[r]);
    return n
}

function Jg() {
    return {
        app: null,
        config: {
            isNativeTag: hm,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let My = 0;

function Ly(e, t) {
    return function(r, i = null) {
        ln(r) || (r = cr({}, r)), i != null && !or(i) && (i = null);
        const s = Jg(),
            a = new WeakSet,
            c = [];
        let u = !1;
        const p = s.app = {
            _uid: My++,
            _component: r,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: d1,
            get config() {
                return s.config
            },
            set config(d) {},
            use(d, ...g) {
                return a.has(d) || (d && ln(d.install) ? (a.add(d), d.install(p, ...g)) : ln(d) && (a.add(d), d(p, ...g))), p
            },
            mixin(d) {
                return s.mixins.includes(d) || s.mixins.push(d), p
            },
            component(d, g) {
                return g ? (s.components[d] = g, p) : s.components[d]
            },
            directive(d, g) {
                return g ? (s.directives[d] = g, p) : s.directives[d]
            },
            mount(d, g, m) {
                if (!u) {
                    const E = p._ceVNode || wn(r, i);
                    return E.appContext = s, m === !0 ? m = "svg" : m === !1 && (m = void 0), g && t ? t(E, d) : e(E, d, m), u = !0, p._container = d, d.__vue_app__ = p, iu(E.component)
                }
            },
            onUnmount(d) {
                c.push(d)
            },
            unmount() {
                u && (Is(c, p._instance, 16), e(null, p._container), delete p._container.__vue_app__)
            },
            provide(d, g) {
                return s.provides[d] = g, p
            },
            runWithContext(d) {
                const g = fa;
                fa = p;
                try {
                    return d()
                } finally {
                    fa = g
                }
            }
        };
        return p
    }
}
let fa = null;

function ws(e, t) {
    if (gi) {
        let n = gi.provides;
        const r = gi.parent && gi.parent.provides;
        r === n && (n = gi.provides = Object.create(r)), n[e] = t
    }
}

function Er(e, t, n = !1) {
    const r = gi || _i;
    if (r || fa) {
        const i = fa ? fa._context.provides : r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
        if (i && e in i) return i[e];
        if (arguments.length > 1) return n && ln(t) ? t.call(r && r.proxy) : t
    }
}

function Ja() {
    return !!(gi || _i || fa)
}
const Zg = {},
    e_ = () => Object.create(Zg),
    t_ = e => Object.getPrototypeOf(e) === Zg;

function Fy(e, t, n, r = !1) {
    const i = {},
        s = e_();
    e.propsDefaults = Object.create(null), n_(e, t, i, s);
    for (const a in e.propsOptions[0]) a in i || (i[a] = void 0);
    n ? e.props = r ? i : Ms(i) : e.type.props ? e.props = i : e.props = s, e.attrs = s
}

function Iy(e, t, n, r) {
    const {
        props: i,
        attrs: s,
        vnode: {
            patchFlag: a
        }
    } = e, c = Bn(i), [u] = e.propsOptions;
    let p = !1;
    if ((r || a > 0) && !(a & 16)) {
        if (a & 8) {
            const d = e.vnode.dynamicProps;
            for (let g = 0; g < d.length; g++) {
                let m = d[g];
                if (kc(e.emitsOptions, m)) continue;
                const E = t[m];
                if (u)
                    if (Xn(s, m)) E !== s[m] && (s[m] = E, p = !0);
                    else {
                        const L = Bi(m);
                        i[L] = Rf(u, c, L, E, e, !1)
                    }
                else E !== s[m] && (s[m] = E, p = !0)
            }
        }
    } else {
        n_(e, t, i, s) && (p = !0);
        let d;
        for (const g in c)(!t || !Xn(t, g) && ((d = is(g)) === g || !Xn(t, d))) && (u ? n && (n[g] !== void 0 || n[d] !== void 0) && (i[g] = Rf(u, c, g, void 0, e, !0)) : delete i[g]);
        if (s !== c)
            for (const g in s)(!t || !Xn(t, g)) && (delete s[g], p = !0)
    }
    p && fo(e.attrs, "set", "")
}

function n_(e, t, n, r) {
    const [i, s] = e.propsOptions;
    let a = !1,
        c;
    if (t)
        for (let u in t) {
            if (Fa(u)) continue;
            const p = t[u];
            let d;
            i && Xn(i, d = Bi(u)) ? !s || !s.includes(d) ? n[d] = p : (c || (c = {}))[d] = p : kc(e.emitsOptions, u) || (!(u in r) || p !== r[u]) && (r[u] = p, a = !0)
        }
    if (s) {
        const u = Bn(n),
            p = c || $n;
        for (let d = 0; d < s.length; d++) {
            const g = s[d];
            n[g] = Rf(i, u, g, p[g], e, !Xn(p, g))
        }
    }
    return a
}

function Rf(e, t, n, r, i, s) {
    const a = e[n];
    if (a != null) {
        const c = Xn(a, "default");
        if (c && r === void 0) {
            const u = a.default;
            if (a.type !== Function && !a.skipFactory && ln(u)) {
                const {
                    propsDefaults: p
                } = i;
                if (n in p) r = p[n];
                else {
                    const d = _a(i);
                    r = p[n] = u.call(null, t), d()
                }
            } else r = u;
            i.ce && i.ce._setProp(n, r)
        }
        a[0] && (s && !c ? r = !1 : a[1] && (r === "" || r === is(n)) && (r = !0))
    }
    return r
}
const Ny = new WeakMap;

function r_(e, t, n = !1) {
    const r = n ? Ny : t.propsCache,
        i = r.get(e);
    if (i) return i;
    const s = e.props,
        a = {},
        c = [];
    let u = !1;
    if (!ln(e)) {
        const d = g => {
            u = !0;
            const [m, E] = r_(g, t, !0);
            cr(a, m), E && c.push(...E)
        };
        !n && t.mixins.length && t.mixins.forEach(d), e.extends && d(e.extends), e.mixins && e.mixins.forEach(d)
    }
    if (!s && !u) return or(e) && r.set(e, Ma), Ma;
    if (Wt(s))
        for (let d = 0; d < s.length; d++) {
            const g = Bi(s[d]);
            gd(g) && (a[g] = $n)
        } else if (s)
            for (const d in s) {
                const g = Bi(d);
                if (gd(g)) {
                    const m = s[d],
                        E = a[g] = Wt(m) || ln(m) ? {
                            type: m
                        } : cr({}, m),
                        L = E.type;
                    let b = !1,
                        j = !0;
                    if (Wt(L))
                        for (let A = 0; A < L.length; ++A) {
                            const $ = L[A],
                                w = ln($) && $.name;
                            if (w === "Boolean") {
                                b = !0;
                                break
                            } else w === "String" && (j = !1)
                        } else b = ln(L) && L.name === "Boolean";
                    E[0] = b, E[1] = j, (b || Xn(E, "default")) && c.push(g)
                }
            }
    const p = [a, c];
    return or(e) && r.set(e, p), p
}

function gd(e) {
    return e[0] !== "$" && !Fa(e)
}
const i_ = e => e[0] === "_" || e === "$stable",
    Rh = e => Wt(e) ? e.map(rs) : [rs(e)],
    By = (e, t, n) => {
        if (t._n) return t;
        const r = Ki((...i) => Rh(t(...i)), n);
        return r._c = !1, r
    },
    s_ = (e, t, n) => {
        const r = e._ctx;
        for (const i in e) {
            if (i_(i)) continue;
            const s = e[i];
            if (ln(s)) t[i] = By(i, s, r);
            else if (s != null) {
                const a = Rh(s);
                t[i] = () => a
            }
        }
    },
    o_ = (e, t) => {
        const n = Rh(t);
        e.slots.default = () => n
    },
    a_ = (e, t, n) => {
        for (const r in t)(n || r !== "_") && (e[r] = t[r])
    },
    $y = (e, t, n) => {
        const r = e.slots = e_();
        if (e.vnode.shapeFlag & 32) {
            const i = t._;
            i ? (a_(r, t, n), n && rg(r, "_", i, !0)) : s_(t, r)
        } else t && o_(e, t)
    },
    Hy = (e, t, n) => {
        const {
            vnode: r,
            slots: i
        } = e;
        let s = !0,
            a = $n;
        if (r.shapeFlag & 32) {
            const c = t._;
            c ? n && c === 1 ? s = !1 : a_(i, t, n) : (s = !t.$stable, s_(t, i)), a = t
        } else t && (o_(e, t), a = {
            default: 1
        });
        if (s)
            for (const c in i) !i_(c) && a[c] == null && delete i[c]
    },
    di = g_;

function Vy(e) {
    return l_(e)
}

function zy(e) {
    return l_(e, dy)
}

function l_(e, t) {
    const n = vc();
    n.__VUE__ = !0;
    const {
        insert: r,
        remove: i,
        patchProp: s,
        createElement: a,
        createText: c,
        createComment: u,
        setText: p,
        setElementText: d,
        parentNode: g,
        nextSibling: m,
        setScopeId: E = vs,
        insertStaticContent: L
    } = e, b = (M, I, fe, Oe = null, Te = null, Ie = null, st = void 0, nt = null, je = !!I.dynamicChildren) => {
        if (M === I) return;
        M && !Os(M, I) && (Oe = de(M), lt(M, Te, Ie, !0), M = null), I.patchFlag === -2 && (je = !1, I.dynamicChildren = null);
        const {
            type: We,
            ref: bt,
            shapeFlag: Ze
        } = I;
        switch (We) {
            case ha:
                j(M, I, fe, Oe);
                break;
            case pi:
                A(M, I, fe, Oe);
                break;
            case Ha:
                M == null && $(I, fe, Oe, st);
                break;
            case zr:
                ne(M, I, fe, Oe, Te, Ie, st, nt, je);
                break;
            default:
                Ze & 1 ? S(M, I, fe, Oe, Te, Ie, st, nt, je) : Ze & 6 ? re(M, I, fe, Oe, Te, Ie, st, nt, je) : (Ze & 64 || Ze & 128) && We.process(M, I, fe, Oe, Te, Ie, st, nt, je, ze)
        }
        bt != null && Te && Ul(bt, M && M.ref, Ie, I || M, !I)
    }, j = (M, I, fe, Oe) => {
        if (M == null) r(I.el = c(I.children), fe, Oe);
        else {
            const Te = I.el = M.el;
            I.children !== M.children && p(Te, I.children)
        }
    }, A = (M, I, fe, Oe) => {
        M == null ? r(I.el = u(I.children || ""), fe, Oe) : I.el = M.el
    }, $ = (M, I, fe, Oe) => {
        [M.el, M.anchor] = L(M.children, I, fe, Oe, M.el, M.anchor)
    }, w = ({
        el: M,
        anchor: I
    }, fe, Oe) => {
        let Te;
        for (; M && M !== I;) Te = m(M), r(M, fe, Oe), M = Te;
        r(I, fe, Oe)
    }, k = ({
        el: M,
        anchor: I
    }) => {
        let fe;
        for (; M && M !== I;) fe = m(M), i(M), M = fe;
        i(I)
    }, S = (M, I, fe, Oe, Te, Ie, st, nt, je) => {
        I.type === "svg" ? st = "svg" : I.type === "math" && (st = "mathml"), M == null ? X(I, fe, Oe, Te, Ie, st, nt, je) : he(M, I, Te, Ie, st, nt, je)
    }, X = (M, I, fe, Oe, Te, Ie, st, nt) => {
        let je, We;
        const {
            props: bt,
            shapeFlag: Ze,
            transition: wt,
            dirs: Et
        } = M;
        if (je = M.el = a(M.type, Ie, bt && bt.is, bt), Ze & 8 ? d(je, M.children) : Ze & 16 && xe(M.children, je, null, Oe, Te, ef(M, Ie), st, nt), Et && Xs(M, null, Oe, "created"), J(je, M, M.scopeId, st, Oe), bt) {
            for (const qt in bt) qt !== "value" && !Fa(qt) && s(je, qt, null, bt[qt], Ie, Oe);
            "value" in bt && s(je, "value", null, bt.value, Ie), (We = bt.onVnodeBeforeMount) && ns(We, Oe, M)
        }
        Et && Xs(M, null, Oe, "beforeMount");
        const Ot = u_(Te, wt);
        Ot && wt.beforeEnter(je), r(je, I, fe), ((We = bt && bt.onVnodeMounted) || Ot || Et) && di(() => {
            We && ns(We, Oe, M), Ot && wt.enter(je), Et && Xs(M, null, Oe, "mounted")
        }, Te)
    }, J = (M, I, fe, Oe, Te) => {
        if (fe && E(M, fe), Oe)
            for (let Ie = 0; Ie < Oe.length; Ie++) E(M, Oe[Ie]);
        if (Te) {
            let Ie = Te.subTree;
            if (I === Ie || ec(Ie.type) && (Ie.ssContent === I || Ie.ssFallback === I)) {
                const st = Te.vnode;
                J(M, st, st.scopeId, st.slotScopeIds, Te.parent)
            }
        }
    }, xe = (M, I, fe, Oe, Te, Ie, st, nt, je = 0) => {
        for (let We = je; We < M.length; We++) {
            const bt = M[We] = nt ? Mo(M[We]) : rs(M[We]);
            b(null, bt, I, fe, Oe, Te, Ie, st, nt)
        }
    }, he = (M, I, fe, Oe, Te, Ie, st) => {
        const nt = I.el = M.el;
        let {
            patchFlag: je,
            dynamicChildren: We,
            dirs: bt
        } = I;
        je |= M.patchFlag & 16;
        const Ze = M.props || $n,
            wt = I.props || $n;
        let Et;
        if (fe && ia(fe, !1), (Et = wt.onVnodeBeforeUpdate) && ns(Et, fe, I, M), bt && Xs(I, M, fe, "beforeUpdate"), fe && ia(fe, !0), (Ze.innerHTML && wt.innerHTML == null || Ze.textContent && wt.textContent == null) && d(nt, ""), We ? me(M.dynamicChildren, We, nt, fe, Oe, ef(I, Te), Ie) : st || le(M, I, nt, null, fe, Oe, ef(I, Te), Ie, !1), je > 0) {
            if (je & 16) Q(nt, Ze, wt, fe, Te);
            else if (je & 2 && Ze.class !== wt.class && s(nt, "class", null, wt.class, Te), je & 4 && s(nt, "style", Ze.style, wt.style, Te), je & 8) {
                const Ot = I.dynamicProps;
                for (let qt = 0; qt < Ot.length; qt++) {
                    const an = Ot[qt],
                        Rn = Ze[an],
                        un = wt[an];
                    (un !== Rn || an === "value") && s(nt, an, Rn, un, Te, fe)
                }
            }
            je & 1 && M.children !== I.children && d(nt, I.children)
        } else !st && We == null && Q(nt, Ze, wt, fe, Te);
        ((Et = wt.onVnodeUpdated) || bt) && di(() => {
            Et && ns(Et, fe, I, M), bt && Xs(I, M, fe, "updated")
        }, Oe)
    }, me = (M, I, fe, Oe, Te, Ie, st) => {
        for (let nt = 0; nt < I.length; nt++) {
            const je = M[nt],
                We = I[nt],
                bt = je.el && (je.type === zr || !Os(je, We) || je.shapeFlag & 70) ? g(je.el) : fe;
            b(je, We, bt, null, Oe, Te, Ie, st, !0)
        }
    }, Q = (M, I, fe, Oe, Te) => {
        if (I !== fe) {
            if (I !== $n)
                for (const Ie in I) !Fa(Ie) && !(Ie in fe) && s(M, Ie, I[Ie], null, Te, Oe);
            for (const Ie in fe) {
                if (Fa(Ie)) continue;
                const st = fe[Ie],
                    nt = I[Ie];
                st !== nt && Ie !== "value" && s(M, Ie, nt, st, Te, Oe)
            }
            "value" in fe && s(M, "value", I.value, fe.value, Te)
        }
    }, ne = (M, I, fe, Oe, Te, Ie, st, nt, je) => {
        const We = I.el = M ? M.el : c(""),
            bt = I.anchor = M ? M.anchor : c("");
        let {
            patchFlag: Ze,
            dynamicChildren: wt,
            slotScopeIds: Et
        } = I;
        Et && (nt = nt ? nt.concat(Et) : Et), M == null ? (r(We, fe, Oe), r(bt, fe, Oe), xe(I.children || [], fe, bt, Te, Ie, st, nt, je)) : Ze > 0 && Ze & 64 && wt && M.dynamicChildren ? (me(M.dynamicChildren, wt, fe, Te, Ie, st, nt), (I.key != null || Te && I === Te.subTree) && Oh(M, I, !0)) : le(M, I, fe, bt, Te, Ie, st, nt, je)
    }, re = (M, I, fe, Oe, Te, Ie, st, nt, je) => {
        I.slotScopeIds = nt, M == null ? I.shapeFlag & 512 ? Te.ctx.activate(I, fe, Oe, st, je) : K(I, fe, Oe, Te, Ie, st, je) : te(M, I, je)
    }, K = (M, I, fe, Oe, Te, Ie, st) => {
        const nt = M.component = w_(M, Oe, Te);
        if (nu(M) && (nt.ctx.renderer = ze), x_(nt, !1, st), nt.asyncDep) {
            if (Te && Te.registerDep(nt, G, st), !M.el) {
                const je = nt.subTree = wn(pi);
                A(null, je, I, fe)
            }
        } else G(nt, M, I, fe, Te, Ie, st)
    }, te = (M, I, fe) => {
        const Oe = I.component = M.component;
        if (Jy(M, I, fe))
            if (Oe.asyncDep && !Oe.asyncResolved) {
                ce(Oe, I, fe);
                return
            } else Oe.next = I, Oe.update();
        else I.el = M.el, Oe.vnode = I
    }, G = (M, I, fe, Oe, Te, Ie, st) => {
        const nt = () => {
            if (M.isMounted) {
                let {
                    next: Ze,
                    bu: wt,
                    u: Et,
                    parent: Ot,
                    vnode: qt
                } = M;
                {
                    const Un = c_(M);
                    if (Un) {
                        Ze && (Ze.el = qt.el, ce(M, Ze, st)), Un.asyncDep.then(() => {
                            M.isUnmounted || nt()
                        });
                        return
                    }
                }
                let an = Ze,
                    Rn;
                ia(M, !1), Ze ? (Ze.el = qt.el, ce(M, Ze, st)) : Ze = qt, wt && Ia(wt), (Rn = Ze.props && Ze.props.onVnodeBeforeUpdate) && ns(Rn, Ot, Ze, qt), ia(M, !0);
                const un = Nu(M),
                    An = M.subTree;
                M.subTree = un, b(An, un, g(An.el), de(An), M, Te, Ie), Ze.el = un.el, an === null && Ac(M, un.el), Et && di(Et, Te), (Rn = Ze.props && Ze.props.onVnodeUpdated) && di(() => ns(Rn, Ot, Ze, qt), Te)
            } else {
                let Ze;
                const {
                    el: wt,
                    props: Et
                } = I, {
                    bm: Ot,
                    m: qt,
                    parent: an,
                    root: Rn,
                    type: un
                } = M, An = No(I);
                if (ia(M, !1), Ot && Ia(Ot), !An && (Ze = Et && Et.onVnodeBeforeMount) && ns(Ze, an, I), ia(M, !0), wt && Ke) {
                    const Un = () => {
                        M.subTree = Nu(M), Ke(wt, M.subTree, M, Te, null)
                    };
                    An && un.__asyncHydrate ? un.__asyncHydrate(wt, M, Un) : Un()
                } else {
                    Rn.ce && Rn.ce._injectChildStyle(un);
                    const Un = M.subTree = Nu(M);
                    b(null, Un, fe, Oe, M, Te, Ie), I.el = Un.el
                }
                if (qt && di(qt, Te), !An && (Ze = Et && Et.onVnodeMounted)) {
                    const Un = I;
                    di(() => ns(Ze, an, Un), Te)
                }(I.shapeFlag & 256 || an && No(an.vnode) && an.vnode.shapeFlag & 256) && M.a && di(M.a, Te), M.isMounted = !0, I = fe = Oe = null
            }
        };
        M.scope.on();
        const je = M.effect = new Wu(nt);
        M.scope.off();
        const We = M.update = je.run.bind(je),
            bt = M.job = je.runIfDirty.bind(je);
        bt.i = M, bt.id = M.uid, je.scheduler = () => xh(bt), ia(M, !0), We()
    }, ce = (M, I, fe) => {
        I.component = M;
        const Oe = M.vnode.props;
        M.vnode = I, M.next = null, Iy(M, I.props, Oe, fe), Hy(M, I.children, fe), Wo(), rd(M), qo()
    }, le = (M, I, fe, Oe, Te, Ie, st, nt, je = !1) => {
        const We = M && M.children,
            bt = M ? M.shapeFlag : 0,
            Ze = I.children,
            {
                patchFlag: wt,
                shapeFlag: Et
            } = I;
        if (wt > 0) {
            if (wt & 128) {
                tt(We, Ze, fe, Oe, Te, Ie, st, nt, je);
                return
            } else if (wt & 256) {
                ve(We, Ze, fe, Oe, Te, Ie, st, nt, je);
                return
            }
        }
        Et & 8 ? (bt & 16 && St(We, Te, Ie), Ze !== We && d(fe, Ze)) : bt & 16 ? Et & 16 ? tt(We, Ze, fe, Oe, Te, Ie, st, nt, je) : St(We, Te, Ie, !0) : (bt & 8 && d(fe, ""), Et & 16 && xe(Ze, fe, Oe, Te, Ie, st, nt, je))
    }, ve = (M, I, fe, Oe, Te, Ie, st, nt, je) => {
        M = M || Ma, I = I || Ma;
        const We = M.length,
            bt = I.length,
            Ze = Math.min(We, bt);
        let wt;
        for (wt = 0; wt < Ze; wt++) {
            const Et = I[wt] = je ? Mo(I[wt]) : rs(I[wt]);
            b(M[wt], Et, fe, null, Te, Ie, st, nt, je)
        }
        We > bt ? St(M, Te, Ie, !0, !1, Ze) : xe(I, fe, Oe, Te, Ie, st, nt, je, Ze)
    }, tt = (M, I, fe, Oe, Te, Ie, st, nt, je) => {
        let We = 0;
        const bt = I.length;
        let Ze = M.length - 1,
            wt = bt - 1;
        for (; We <= Ze && We <= wt;) {
            const Et = M[We],
                Ot = I[We] = je ? Mo(I[We]) : rs(I[We]);
            if (Os(Et, Ot)) b(Et, Ot, fe, null, Te, Ie, st, nt, je);
            else break;
            We++
        }
        for (; We <= Ze && We <= wt;) {
            const Et = M[Ze],
                Ot = I[wt] = je ? Mo(I[wt]) : rs(I[wt]);
            if (Os(Et, Ot)) b(Et, Ot, fe, null, Te, Ie, st, nt, je);
            else break;
            Ze--, wt--
        }
        if (We > Ze) {
            if (We <= wt) {
                const Et = wt + 1,
                    Ot = Et < bt ? I[Et].el : Oe;
                for (; We <= wt;) b(null, I[We] = je ? Mo(I[We]) : rs(I[We]), fe, Ot, Te, Ie, st, nt, je), We++
            }
        } else if (We > wt)
            for (; We <= Ze;) lt(M[We], Te, Ie, !0), We++;
        else {
            const Et = We,
                Ot = We,
                qt = new Map;
            for (We = Ot; We <= wt; We++) {
                const Y = I[We] = je ? Mo(I[We]) : rs(I[We]);
                Y.key != null && qt.set(Y.key, We)
            }
            let an, Rn = 0;
            const un = wt - Ot + 1;
            let An = !1,
                Un = 0;
            const er = new Array(un);
            for (We = 0; We < un; We++) er[We] = 0;
            for (We = Et; We <= Ze; We++) {
                const Y = M[We];
                if (Rn >= un) {
                    lt(Y, Te, Ie, !0);
                    continue
                }
                let ie;
                if (Y.key != null) ie = qt.get(Y.key);
                else
                    for (an = Ot; an <= wt; an++)
                        if (er[an - Ot] === 0 && Os(Y, I[an])) {
                            ie = an;
                            break
                        } ie === void 0 ? lt(Y, Te, Ie, !0) : (er[ie - Ot] = We + 1, ie >= Un ? Un = ie : An = !0, b(Y, I[ie], fe, null, Te, Ie, st, nt, je), Rn++)
            }
            const ft = An ? jy(er) : Ma;
            for (an = ft.length - 1, We = un - 1; We >= 0; We--) {
                const Y = Ot + We,
                    ie = I[Y],
                    ge = Y + 1 < bt ? I[Y + 1].el : Oe;
                er[We] === 0 ? b(null, ie, fe, ge, Te, Ie, st, nt, je) : An && (an < 0 || We !== ft[an] ? ht(ie, fe, ge, 2) : an--)
            }
        }
    }, ht = (M, I, fe, Oe, Te = null) => {
        const {
            el: Ie,
            type: st,
            transition: nt,
            children: je,
            shapeFlag: We
        } = M;
        if (We & 6) {
            ht(M.component.subTree, I, fe, Oe);
            return
        }
        if (We & 128) {
            M.suspense.move(I, fe, Oe);
            return
        }
        if (We & 64) {
            st.move(M, I, fe, ze);
            return
        }
        if (st === zr) {
            r(Ie, I, fe);
            for (let Ze = 0; Ze < je.length; Ze++) ht(je[Ze], I, fe, Oe);
            r(M.anchor, I, fe);
            return
        }
        if (st === Ha) {
            w(M, I, fe);
            return
        }
        if (Oe !== 2 && We & 1 && nt)
            if (Oe === 0) nt.beforeEnter(Ie), r(Ie, I, fe), di(() => nt.enter(Ie), Te);
            else {
                const {
                    leave: Ze,
                    delayLeave: wt,
                    afterLeave: Et
                } = nt, Ot = () => r(Ie, I, fe), qt = () => {
                    Ze(Ie, () => {
                        Ot(), Et && Et()
                    })
                };
                wt ? wt(Ie, Ot, qt) : qt()
            }
        else r(Ie, I, fe)
    }, lt = (M, I, fe, Oe = !1, Te = !1) => {
        const {
            type: Ie,
            props: st,
            ref: nt,
            children: je,
            dynamicChildren: We,
            shapeFlag: bt,
            patchFlag: Ze,
            dirs: wt,
            cacheIndex: Et
        } = M;
        if (Ze === -2 && (Te = !1), nt != null && Ul(nt, null, fe, M, !0), Et != null && (I.renderCache[Et] = void 0), bt & 256) {
            I.ctx.deactivate(M);
            return
        }
        const Ot = bt & 1 && wt,
            qt = !No(M);
        let an;
        if (qt && (an = st && st.onVnodeBeforeUnmount) && ns(an, I, M), bt & 6) Pt(M.component, fe, Oe);
        else {
            if (bt & 128) {
                M.suspense.unmount(fe, Oe);
                return
            }
            Ot && Xs(M, null, I, "beforeUnmount"), bt & 64 ? M.type.remove(M, I, fe, ze, Oe) : We && !We.hasOnce && (Ie !== zr || Ze > 0 && Ze & 64) ? St(We, I, fe, !1, !0) : (Ie === zr && Ze & 384 || !Te && bt & 16) && St(je, I, fe), Oe && _t(M)
        }(qt && (an = st && st.onVnodeUnmounted) || Ot) && di(() => {
            an && ns(an, I, M), Ot && Xs(M, null, I, "unmounted")
        }, fe)
    }, _t = M => {
        const {
            type: I,
            el: fe,
            anchor: Oe,
            transition: Te
        } = M;
        if (I === zr) {
            mt(fe, Oe);
            return
        }
        if (I === Ha) {
            k(M);
            return
        }
        const Ie = () => {
            i(fe), Te && !Te.persisted && Te.afterLeave && Te.afterLeave()
        };
        if (M.shapeFlag & 1 && Te && !Te.persisted) {
            const {
                leave: st,
                delayLeave: nt
            } = Te, je = () => st(fe, Ie);
            nt ? nt(M.el, Ie, je) : je()
        } else Ie()
    }, mt = (M, I) => {
        let fe;
        for (; M !== I;) fe = m(M), i(M), M = fe;
        i(I)
    }, Pt = (M, I, fe) => {
        const {
            bum: Oe,
            scope: Te,
            job: Ie,
            subTree: st,
            um: nt,
            m: je,
            a: We
        } = M;
        Zu(je), Zu(We), Oe && Ia(Oe), Te.stop(), Ie && (Ie.flags |= 8, lt(st, M, I, fe)), nt && di(nt, I), di(() => {
            M.isUnmounted = !0
        }, I), I && I.pendingBranch && !I.isUnmounted && M.asyncDep && !M.asyncResolved && M.suspenseId === I.pendingId && (I.deps--, I.deps === 0 && I.resolve())
    }, St = (M, I, fe, Oe = !1, Te = !1, Ie = 0) => {
        for (let st = Ie; st < M.length; st++) lt(M[st], I, fe, Oe, Te)
    }, de = M => {
        if (M.shapeFlag & 6) return de(M.component.subTree);
        if (M.shapeFlag & 128) return M.suspense.next();
        const I = m(M.anchor || M.el),
            fe = I && I[Mg];
        return fe ? m(fe) : I
    };
    let ye = !1;
    const oe = (M, I, fe) => {
            M == null ? I._vnode && lt(I._vnode, null, null, !0) : b(I._vnode || null, M, I, null, null, null, fe), I._vnode = M, ye || (ye = !0, rd(), Ku(), ye = !1)
        },
        ze = {
            p: b,
            um: lt,
            m: ht,
            r: _t,
            mt: K,
            mc: xe,
            pc: le,
            pbc: me,
            n: de,
            o: e
        };
    let Se, Ke;
    return t && ([Se, Ke] = t(ze)), {
        render: oe,
        hydrate: Se,
        createApp: Ly(oe, Se)
    }
}

function ef({
    type: e,
    props: t
}, n) {
    return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n
}

function ia({
    effect: e,
    job: t
}, n) {
    n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5)
}

function u_(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted
}

function Oh(e, t, n = !1) {
    const r = e.children,
        i = t.children;
    if (Wt(r) && Wt(i))
        for (let s = 0; s < r.length; s++) {
            const a = r[s];
            let c = i[s];
            c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = i[s] = Mo(i[s]), c.el = a.el), !n && c.patchFlag !== -2 && Oh(a, c)), c.type === ha && (c.el = a.el)
        }
}

function jy(e) {
    const t = e.slice(),
        n = [0];
    let r, i, s, a, c;
    const u = e.length;
    for (r = 0; r < u; r++) {
        const p = e[r];
        if (p !== 0) {
            if (i = n[n.length - 1], e[i] < p) {
                t[r] = i, n.push(r);
                continue
            }
            for (s = 0, a = n.length - 1; s < a;) c = s + a >> 1, e[n[c]] < p ? s = c + 1 : a = c;
            p < e[n[s]] && (s > 0 && (t[r] = n[s - 1]), n[s] = r)
        }
    }
    for (s = n.length, a = n[s - 1]; s-- > 0;) n[s] = a, a = t[a];
    return n
}

function c_(e) {
    const t = e.subTree.component;
    if (t) return t.asyncDep && !t.asyncResolved ? t : c_(t)
}

function Zu(e) {
    if (e)
        for (let t = 0; t < e.length; t++) e[t].flags |= 8
}
const Uy = Symbol.for("v-scx"),
    Wy = () => Er(Uy);

function Ol(e, t) {
    return ru(e, null, t)
}

function G2(e, t) {
    return ru(e, null, {
        flush: "post"
    })
}

function qy(e, t) {
    return ru(e, null, {
        flush: "sync"
    })
}

function Qr(e, t, n) {
    return ru(e, t, n)
}

function ru(e, t, n = $n) {
    const {
        immediate: r,
        deep: i,
        flush: s,
        once: a
    } = n, c = cr({}, n), u = t && r || !t && s !== "post";
    let p;
    if (ja) {
        if (s === "sync") {
            const E = Wy();
            p = E.__watcherHandles || (E.__watcherHandles = [])
        } else if (!u) {
            const E = () => {};
            return E.stop = vs, E.resume = vs, E.pause = vs, E
        }
    }
    const d = gi;
    c.call = (E, L, b) => Is(E, d, L, b);
    let g = !1;
    s === "post" ? c.scheduler = E => {
        di(E, d && d.suspense)
    } : s !== "sync" && (g = !0, c.scheduler = (E, L) => {
        L ? E() : xh(E)
    }), c.augmentJob = E => {
        t && (E.flags |= 4), g && (E.flags |= 2, d && (E.id = d.uid, E.i = d))
    };
    const m = ty(e, t, c);
    return ja && (p ? p.push(m) : u && m()), m
}

function Gy(e, t, n) {
    const r = this.proxy,
        i = yr(e) ? e.includes(".") ? f_(r, e) : () => r[e] : e.bind(r, r);
    let s;
    ln(t) ? s = t : (s = t.handler, n = t);
    const a = _a(this),
        c = ru(i, s.bind(r), n);
    return a(), c
}

function f_(e, t) {
    const n = t.split(".");
    return () => {
        let r = e;
        for (let i = 0; i < n.length && r; i++) r = r[n[i]];
        return r
    }
}

function Y2(e, t, n = $n) {
    const r = wi(),
        i = Bi(t),
        s = is(t),
        a = h_(e, i),
        c = Sg((u, p) => {
            let d, g = $n,
                m;
            return qy(() => {
                const E = e[i];
                Yi(d, E) && (d = E, p())
            }), {
                get() {
                    return u(), n.get ? n.get(d) : d
                },
                set(E) {
                    const L = n.set ? n.set(E) : E;
                    if (!Yi(L, d) && !(g !== $n && Yi(E, g))) return;
                    const b = r.vnode.props;
                    b && (t in b || i in b || s in b) && (`onUpdate:${t}` in b || `onUpdate:${i}` in b || `onUpdate:${s}` in b) || (d = E, p()), r.emit(`update:${t}`, L), Yi(E, L) && Yi(E, g) && !Yi(L, m) && p(), g = E, m = L
                }
            }
        });
    return c[Symbol.iterator] = () => {
        let u = 0;
        return {
            next() {
                return u < 2 ? {
                    value: u++ ? a || $n : c,
                    done: !1
                } : {
                    done: !0
                }
            }
        }
    }, c
}
const h_ = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${Bi(t)}Modifiers`] || e[`${is(t)}Modifiers`];

function Yy(e, t, ...n) {
    if (e.isUnmounted) return;
    const r = e.vnode.props || $n;
    let i = n;
    const s = t.startsWith("update:"),
        a = s && h_(r, t.slice(7));
    a && (a.trim && (i = n.map(d => yr(d) ? d.trim() : d)), a.number && (i = n.map(zu)));
    let c, u = r[c = Fu(t)] || r[c = Fu(Bi(t))];
    !u && s && (u = r[c = Fu(is(t))]), u && Is(u, e, 6, i);
    const p = r[c + "Once"];
    if (p) {
        if (!e.emitted) e.emitted = {};
        else if (e.emitted[c]) return;
        e.emitted[c] = !0, Is(p, e, 6, i)
    }
}

function d_(e, t, n = !1) {
    const r = t.emitsCache,
        i = r.get(e);
    if (i !== void 0) return i;
    const s = e.emits;
    let a = {},
        c = !1;
    if (!ln(e)) {
        const u = p => {
            const d = d_(p, t, !0);
            d && (c = !0, cr(a, d))
        };
        !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u)
    }
    return !s && !c ? (or(e) && r.set(e, null), null) : (Wt(s) ? s.forEach(u => a[u] = null) : cr(a, s), or(e) && r.set(e, a), a)
}

function kc(e, t) {
    return !e || !Zl(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Xn(e, t[0].toLowerCase() + t.slice(1)) || Xn(e, is(t)) || Xn(e, t))
}

function Nu(e) {
    const {
        type: t,
        vnode: n,
        proxy: r,
        withProxy: i,
        propsOptions: [s],
        slots: a,
        attrs: c,
        emit: u,
        render: p,
        renderCache: d,
        props: g,
        data: m,
        setupState: E,
        ctx: L,
        inheritAttrs: b
    } = e, j = zl(e);
    let A, $;
    try {
        if (n.shapeFlag & 4) {
            const k = i || r,
                S = k;
            A = rs(p.call(S, k, d, g, E, m, L)), $ = c
        } else {
            const k = t;
            A = rs(k.length > 1 ? k(g, {
                attrs: c,
                slots: a,
                emit: u
            }) : k(g, null)), $ = t.props ? c : Ky(c)
        }
    } catch (k) {
        Ml.length = 0, Qa(k, e, 1), A = wn(pi)
    }
    let w = A;
    if ($ && b !== !1) {
        const k = Object.keys($),
            {
                shapeFlag: S
            } = w;
        k.length && S & 7 && (s && k.some(ph) && ($ = Qy($, s)), w = yo(w, $, !1, !0))
    }
    return n.dirs && (w = yo(w, null, !1, !0), w.dirs = w.dirs ? w.dirs.concat(n.dirs) : n.dirs), n.transition && Vo(w, n.transition), A = w, zl(j), A
}

function Xy(e, t = !0) {
    let n;
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        if (zo(i)) {
            if (i.type !== pi || i.children === "v-if") {
                if (n) return;
                n = i
            }
        } else return
    }
    return n
}
const Ky = e => {
        let t;
        for (const n in e)(n === "class" || n === "style" || Zl(n)) && ((t || (t = {}))[n] = e[n]);
        return t
    },
    Qy = (e, t) => {
        const n = {};
        for (const r in e)(!ph(r) || !(r.slice(9) in t)) && (n[r] = e[r]);
        return n
    };

function Jy(e, t, n) {
    const {
        props: r,
        children: i,
        component: s
    } = e, {
        props: a,
        children: c,
        patchFlag: u
    } = t, p = s.emitsOptions;
    if (t.dirs || t.transition) return !0;
    if (n && u >= 0) {
        if (u & 1024) return !0;
        if (u & 16) return r ? _d(r, a, p) : !!a;
        if (u & 8) {
            const d = t.dynamicProps;
            for (let g = 0; g < d.length; g++) {
                const m = d[g];
                if (a[m] !== r[m] && !kc(p, m)) return !0
            }
        }
    } else return (i || c) && (!c || !c.$stable) ? !0 : r === a ? !1 : r ? a ? _d(r, a, p) : !0 : !!a;
    return !1
}

function _d(e, t, n) {
    const r = Object.keys(t);
    if (r.length !== Object.keys(e).length) return !0;
    for (let i = 0; i < r.length; i++) {
        const s = r[i];
        if (t[s] !== e[s] && !kc(n, s)) return !0
    }
    return !1
}

function Ac({
    vnode: e,
    parent: t
}, n) {
    for (; t;) {
        const r = t.subTree;
        if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el), r === e)(e = t.vnode).el = n, t = t.parent;
        else break
    }
}
const ec = e => e.__isSuspense;
let Of = 0;
const Zy = {
        name: "Suspense",
        __isSuspense: !0,
        process(e, t, n, r, i, s, a, c, u, p) {
            if (e == null) e1(t, n, r, i, s, a, c, u, p);
            else {
                if (s && s.deps > 0 && !e.suspense.isInFallback) {
                    t.suspense = e.suspense, t.suspense.vnode = t, t.el = e.el;
                    return
                }
                t1(e, t, n, r, i, a, c, u, p)
            }
        },
        hydrate: n1,
        normalize: r1
    },
    Mh = Zy;

function ql(e, t) {
    const n = e.props && e.props[t];
    ln(n) && n()
}

function e1(e, t, n, r, i, s, a, c, u) {
    const {
        p,
        o: {
            createElement: d
        }
    } = u, g = d("div"), m = e.suspense = p_(e, i, r, t, g, n, s, a, c, u);
    p(null, m.pendingBranch = e.ssContent, g, null, r, m, s, a), m.deps > 0 ? (ql(e, "onPending"), ql(e, "onFallback"), p(null, e.ssFallback, t, n, r, null, s, a), $a(m, e.ssFallback)) : m.resolve(!1, !0)
}

function t1(e, t, n, r, i, s, a, c, {
    p: u,
    um: p,
    o: {
        createElement: d
    }
}) {
    const g = t.suspense = e.suspense;
    g.vnode = t, t.el = e.el;
    const m = t.ssContent,
        E = t.ssFallback,
        {
            activeBranch: L,
            pendingBranch: b,
            isInFallback: j,
            isHydrating: A
        } = g;
    if (b) g.pendingBranch = m, Os(m, b) ? (u(b, m, g.hiddenContainer, null, i, g, s, a, c), g.deps <= 0 ? g.resolve() : j && (A || (u(L, E, n, r, i, null, s, a, c), $a(g, E)))) : (g.pendingId = Of++, A ? (g.isHydrating = !1, g.activeBranch = b) : p(b, i, g), g.deps = 0, g.effects.length = 0, g.hiddenContainer = d("div"), j ? (u(null, m, g.hiddenContainer, null, i, g, s, a, c), g.deps <= 0 ? g.resolve() : (u(L, E, n, r, i, null, s, a, c), $a(g, E))) : L && Os(m, L) ? (u(L, m, n, r, i, g, s, a, c), g.resolve(!0)) : (u(null, m, g.hiddenContainer, null, i, g, s, a, c), g.deps <= 0 && g.resolve()));
    else if (L && Os(m, L)) u(L, m, n, r, i, g, s, a, c), $a(g, m);
    else if (ql(t, "onPending"), g.pendingBranch = m, m.shapeFlag & 512 ? g.pendingId = m.component.suspenseId : g.pendingId = Of++, u(null, m, g.hiddenContainer, null, i, g, s, a, c), g.deps <= 0) g.resolve();
    else {
        const {
            timeout: $,
            pendingId: w
        } = g;
        $ > 0 ? setTimeout(() => {
            g.pendingId === w && g.fallback(E)
        }, $) : $ === 0 && g.fallback(E)
    }
}

function p_(e, t, n, r, i, s, a, c, u, p, d = !1) {
    const {
        p: g,
        m,
        um: E,
        n: L,
        o: {
            parentNode: b,
            remove: j
        }
    } = p;
    let A;
    const $ = i1(e);
    $ && t && t.pendingBranch && (A = t.pendingId, t.deps++);
    const w = e.props ? ju(e.props.timeout) : void 0,
        k = s,
        S = {
            vnode: e,
            parent: t,
            parentComponent: n,
            namespace: a,
            container: r,
            hiddenContainer: i,
            deps: 0,
            pendingId: Of++,
            timeout: typeof w == "number" ? w : -1,
            activeBranch: null,
            pendingBranch: null,
            isInFallback: !d,
            isHydrating: d,
            isUnmounted: !1,
            effects: [],
            resolve(X = !1, J = !1) {
                const {
                    vnode: xe,
                    activeBranch: he,
                    pendingBranch: me,
                    pendingId: Q,
                    effects: ne,
                    parentComponent: re,
                    container: K
                } = S;
                let te = !1;
                S.isHydrating ? S.isHydrating = !1 : X || (te = he && me.transition && me.transition.mode === "out-in", te && (he.transition.afterLeave = () => {
                    Q === S.pendingId && (m(me, K, s === k ? L(he) : s, 0), Xu(ne))
                }), he && (b(he.el) === K && (s = L(he)), E(he, re, S, !0)), te || m(me, K, s, 0)), $a(S, me), S.pendingBranch = null, S.isInFallback = !1;
                let G = S.parent,
                    ce = !1;
                for (; G;) {
                    if (G.pendingBranch) {
                        G.effects.push(...ne), ce = !0;
                        break
                    }
                    G = G.parent
                }!ce && !te && Xu(ne), S.effects = [], $ && t && t.pendingBranch && A === t.pendingId && (t.deps--, t.deps === 0 && !J && t.resolve()), ql(xe, "onResolve")
            },
            fallback(X) {
                if (!S.pendingBranch) return;
                const {
                    vnode: J,
                    activeBranch: xe,
                    parentComponent: he,
                    container: me,
                    namespace: Q
                } = S;
                ql(J, "onFallback");
                const ne = L(xe),
                    re = () => {
                        S.isInFallback && (g(null, X, me, ne, he, null, Q, c, u), $a(S, X))
                    },
                    K = X.transition && X.transition.mode === "out-in";
                K && (xe.transition.afterLeave = re), S.isInFallback = !0, E(xe, he, null, !0), K || re()
            },
            move(X, J, xe) {
                S.activeBranch && m(S.activeBranch, X, J, xe), S.container = X
            },
            next() {
                return S.activeBranch && L(S.activeBranch)
            },
            registerDep(X, J, xe) {
                const he = !!S.pendingBranch;
                he && S.deps++;
                const me = X.vnode.el;
                X.asyncDep.catch(Q => {
                    Qa(Q, X, 0)
                }).then(Q => {
                    if (X.isUnmounted || S.isUnmounted || S.pendingId !== X.suspenseId) return;
                    X.asyncResolved = !0;
                    const {
                        vnode: ne
                    } = X;
                    Ff(X, Q, !1), me && (ne.el = me);
                    const re = !me && X.subTree.el;
                    J(X, ne, b(me || X.subTree.el), me ? null : L(X.subTree), S, a, xe), re && j(re), Ac(X, ne.el), he && --S.deps === 0 && S.resolve()
                })
            },
            unmount(X, J) {
                S.isUnmounted = !0, S.activeBranch && E(S.activeBranch, n, X, J), S.pendingBranch && E(S.pendingBranch, n, X, J)
            }
        };
    return S
}

function n1(e, t, n, r, i, s, a, c, u) {
    const p = t.suspense = p_(t, r, n, e.parentNode, document.createElement("div"), null, i, s, a, c, !0),
        d = u(e, p.pendingBranch = t.ssContent, n, p, s, a);
    return p.deps === 0 && p.resolve(!1, !0), d
}

function r1(e) {
    const {
        shapeFlag: t,
        children: n
    } = e, r = t & 32;
    e.ssContent = md(r ? n.default : n), e.ssFallback = r ? md(n.fallback) : wn(pi)
}

function md(e) {
    let t;
    if (ln(e)) {
        const n = ga && e._c;
        n && (e._d = !1, Mn()), e = e(), n && (e._d = !0, t = Ni, __())
    }
    return Wt(e) && (e = Xy(e)), e = rs(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter(n => n !== e)), e
}

function g_(e, t) {
    t && t.pendingBranch ? Wt(e) ? t.effects.push(...e) : t.effects.push(e) : Xu(e)
}

function $a(e, t) {
    e.activeBranch = t;
    const {
        vnode: n,
        parentComponent: r
    } = e;
    let i = t.el;
    for (; !i && t.component;) t = t.component.subTree, i = t.el;
    n.el = i, r && r.subTree === n && (r.vnode.el = i, Ac(r, i))
}

function i1(e) {
    const t = e.props && e.props.suspensible;
    return t != null && t !== !1
}
const zr = Symbol.for("v-fgt"),
    ha = Symbol.for("v-txt"),
    pi = Symbol.for("v-cmt"),
    Ha = Symbol.for("v-stc"),
    Ml = [];
let Ni = null;

function Mn(e = !1) {
    Ml.push(Ni = e ? null : [])
}

function __() {
    Ml.pop(), Ni = Ml[Ml.length - 1] || null
}
let ga = 1;

function yd(e, t = !1) {
    ga += e, e < 0 && Ni && t && (Ni.hasOnce = !0)
}

function m_(e) {
    return e.dynamicChildren = ga > 0 ? Ni || Ma : null, __(), ga > 0 && Ni && Ni.push(e), e
}

function Br(e, t, n, r, i, s) {
    return m_(Xt(e, t, n, r, i, s, !0))
}

function cs(e, t, n, r, i) {
    return m_(wn(e, t, n, r, i, !0))
}

function zo(e) {
    return e ? e.__v_isVNode === !0 : !1
}

function Os(e, t) {
    return e.type === t.type && e.key === t.key
}

function X2(e) {}
const y_ = ({
        key: e
    }) => e ?? null,
    Bu = ({
        ref: e,
        ref_key: t,
        ref_for: n
    }) => (typeof e == "number" && (e = "" + e), e != null ? yr(e) || mr(e) || ln(e) ? {
        i: _i,
        r: e,
        k: t,
        f: !!n
    } : e : null);

function Xt(e, t = null, n = null, r = 0, i = null, s = e === zr ? 0 : 1, a = !1, c = !1) {
    const u = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && y_(t),
        ref: t && Bu(t),
        scopeId: Sc,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: r,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
        ctx: _i
    };
    return c ? (Lh(u, n), s & 128 && e.normalize(u)) : n && (u.shapeFlag |= yr(n) ? 8 : 16), ga > 0 && !a && Ni && (u.patchFlag > 0 || s & 6) && u.patchFlag !== 32 && Ni.push(u), u
}
const wn = s1;

function s1(e, t = null, n = null, r = 0, i = null, s = !1) {
    if ((!e || e === Yg) && (e = pi), zo(e)) {
        const c = yo(e, t, !0);
        return n && Lh(c, n), ga > 0 && !s && Ni && (c.shapeFlag & 6 ? Ni[Ni.indexOf(e)] = c : Ni.push(c)), c.patchFlag = -2, c
    }
    if (f1(e) && (e = e.__vccOpts), t) {
        t = o1(t);
        let {
            class: c,
            style: u
        } = t;
        c && !yr(c) && (t.class = ya(c)), or(u) && (wh(u) && !Wt(u) && (u = cr({}, u)), t.style = bc(u))
    }
    const a = yr(e) ? 1 : ec(e) ? 128 : Lg(e) ? 64 : or(e) ? 4 : ln(e) ? 2 : 0;
    return Xt(e, t, n, r, i, a, s, !0)
}

function o1(e) {
    return e ? wh(e) || t_(e) ? cr({}, e) : e : null
}

function yo(e, t, n = !1, r = !1) {
    const {
        props: i,
        ref: s,
        patchFlag: a,
        children: c,
        transition: u
    } = e, p = t ? Fh(i || {}, t) : i, d = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: p,
        key: p && y_(p),
        ref: t && t.ref ? n && s ? Wt(s) ? s.concat(Bu(t)) : [s, Bu(t)] : Bu(t) : s,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: c,
        target: e.target,
        targetStart: e.targetStart,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== zr ? a === -1 ? 16 : a | 16 : a,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: u,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && yo(e.ssContent),
        ssFallback: e.ssFallback && yo(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    };
    return u && r && Vo(d, u.clone(d)), d
}

function Gl(e = " ", t = 0) {
    return wn(ha, null, e, t)
}

function v_(e, t) {
    const n = wn(Ha, null, e);
    return n.staticCount = t, n
}

function b_(e = "", t = !1) {
    return t ? (Mn(), cs(pi, null, e)) : wn(pi, null, e)
}

function rs(e) {
    return e == null || typeof e == "boolean" ? wn(pi) : Wt(e) ? wn(zr, null, e.slice()) : zo(e) ? Mo(e) : wn(ha, null, String(e))
}

function Mo(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : yo(e)
}

function Lh(e, t) {
    let n = 0;
    const {
        shapeFlag: r
    } = e;
    if (t == null) t = null;
    else if (Wt(t)) n = 16;
    else if (typeof t == "object")
        if (r & 65) {
            const i = t.default;
            i && (i._c && (i._d = !1), Lh(e, i()), i._c && (i._d = !0));
            return
        } else {
            n = 32;
            const i = t._;
            !i && !t_(t) ? t._ctx = _i : i === 3 && _i && (_i.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024))
        }
    else ln(t) ? (t = {
        default: t,
        _ctx: _i
    }, n = 32) : (t = String(t), r & 64 ? (n = 16, t = [Gl(t)]) : n = 8);
    e.children = t, e.shapeFlag |= n
}

function Fh(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        for (const i in r)
            if (i === "class") t.class !== r.class && (t.class = ya([t.class, r.class]));
            else if (i === "style") t.style = bc([t.style, r.style]);
        else if (Zl(i)) {
            const s = t[i],
                a = r[i];
            a && s !== a && !(Wt(s) && s.includes(a)) && (t[i] = s ? [].concat(s, a) : a)
        } else i !== "" && (t[i] = r[i])
    }
    return t
}

function ns(e, t, n, r = null) {
    Is(e, t, 7, [n, r])
}
const a1 = Jg();
let l1 = 0;

function w_(e, t, n) {
    const r = e.type,
        i = (t ? t.appContext : e.appContext) || a1,
        s = {
            uid: l1++,
            vnode: e,
            type: r,
            parent: t,
            appContext: i,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            job: null,
            scope: new ag(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: t ? t.provides : Object.create(i.provides),
            ids: t ? t.ids : ["", 0, 0],
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: r_(r, i),
            emitsOptions: d_(r, i),
            emit: null,
            emitted: null,
            propsDefaults: $n,
            inheritAttrs: r.inheritAttrs,
            ctx: $n,
            data: $n,
            props: $n,
            attrs: $n,
            slots: $n,
            refs: $n,
            setupState: $n,
            setupContext: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return s.ctx = {
        _: s
    }, s.root = t ? t.root : s, s.emit = Yy.bind(null, s), e.ce && e.ce(s), s
}
let gi = null;
const wi = () => gi || _i;
let tc, Mf;
{
    const e = vc(),
        t = (n, r) => {
            let i;
            return (i = e[n]) || (i = e[n] = []), i.push(r), s => {
                i.length > 1 ? i.forEach(a => a(s)) : i[0](s)
            }
        };
    tc = t("__VUE_INSTANCE_SETTERS__", n => gi = n), Mf = t("__VUE_SSR_SETTERS__", n => ja = n)
}
const _a = e => {
        const t = gi;
        return tc(e), e.scope.on(), () => {
            e.scope.off(), tc(t)
        }
    },
    Lf = () => {
        gi && gi.scope.off(), tc(null)
    };

function D_(e) {
    return e.vnode.shapeFlag & 4
}
let ja = !1;

function x_(e, t = !1, n = !1) {
    t && Mf(t);
    const {
        props: r,
        children: i
    } = e.vnode, s = D_(e);
    Fy(e, r, s, t), $y(e, i, n);
    const a = s ? u1(e, t) : void 0;
    return t && Mf(!1), a
}

function u1(e, t) {
    const n = e.type;
    e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Pf);
    const {
        setup: r
    } = n;
    if (r) {
        Wo();
        const i = e.setupContext = r.length > 1 ? C_(e) : null,
            s = _a(e),
            a = tu(r, e, 0, [e.props, i]),
            c = _h(a);
        if (qo(), s(), (c || e.sp) && !No(e) && Ch(e), c) {
            if (a.then(Lf, Lf), t) return a.then(u => {
                Ff(e, u, t)
            }).catch(u => {
                Qa(u, e, 0)
            });
            e.asyncDep = a
        } else Ff(e, a, t)
    } else E_(e, t)
}

function Ff(e, t, n) {
    ln(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : or(t) && (e.setupState = Cg(t)), E_(e, n)
}
let nc, If;

function K2(e) {
    nc = e, If = t => {
        t.render._rc && (t.withProxy = new Proxy(t.ctx, Sy))
    }
}
const Q2 = () => !nc;

function E_(e, t, n) {
    const r = e.type;
    if (!e.render) {
        if (!t && nc && !r.render) {
            const i = r.template || Ah(e).template;
            if (i) {
                const {
                    isCustomElement: s,
                    compilerOptions: a
                } = e.appContext.config, {
                    delimiters: c,
                    compilerOptions: u
                } = r, p = cr(cr({
                    isCustomElement: s,
                    delimiters: c
                }, a), u);
                r.render = nc(i, p)
            }
        }
        e.render = r.render || vs, If && If(e)
    } {
        const i = _a(e);
        Wo();
        try {
            Py(e)
        } finally {
            qo(), i()
        }
    }
}
const c1 = {
    get(e, t) {
        return Fi(e, "get", ""), e[t]
    }
};

function C_(e) {
    const t = n => {
        e.exposed = n || {}
    };
    return {
        attrs: new Proxy(e.attrs, c1),
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}

function iu(e) {
    return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Cg(Dh(e.exposed)), {
        get(t, n) {
            if (n in t) return t[n];
            if (n in Rl) return Rl[n](e)
        },
        has(t, n) {
            return n in t || n in Rl
        }
    })) : e.proxy
}

function Nf(e, t = !0) {
    return ln(e) ? e.displayName || e.name : e.name || t && e.__name
}

function f1(e) {
    return ln(e) && "__vccOpts" in e
}
const xn = (e, t) => Zm(e, t, ja);

function jr(e, t, n) {
    const r = arguments.length;
    return r === 2 ? or(t) && !Wt(t) ? zo(t) ? wn(e, null, [t]) : wn(e, t) : wn(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && zo(n) && (n = [n]), wn(e, t, n))
}

function J2() {}

function Z2(e, t, n, r) {
    const i = n[r];
    if (i && h1(i, e)) return i;
    const s = t();
    return s.memo = e.slice(), s.cacheIndex = r, n[r] = s
}

function h1(e, t) {
    const n = e.memo;
    if (n.length != t.length) return !1;
    for (let r = 0; r < n.length; r++)
        if (Yi(n[r], t[r])) return !1;
    return ga > 0 && Ni && Ni.push(e), !0
}
const d1 = "3.5.13",
    eP = vs,
    tP = iy,
    nP = Aa,
    rP = Og,
    p1 = {
        createComponentInstance: w_,
        setupComponent: x_,
        renderComponentRoot: Nu,
        setCurrentRenderingInstance: zl,
        isVNode: zo,
        normalizeVNode: rs,
        getComponentPublicInstance: iu,
        ensureValidVNode: kh,
        pushWarningContext: ny,
        popWarningContext: ry
    },
    iP = p1,
    sP = null,
    oP = null,
    aP = null;
/**
 * @vue/runtime-dom v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let Bf;
const vd = typeof window < "u" && window.trustedTypes;
if (vd) try {
    Bf = vd.createPolicy("vue", {
        createHTML: e => e
    })
} catch {}
const S_ = Bf ? e => Bf.createHTML(e) : e => e,
    g1 = "http://www.w3.org/2000/svg",
    _1 = "http://www.w3.org/1998/Math/MathML",
    co = typeof document < "u" ? document : null,
    bd = co && co.createElement("template"),
    m1 = {
        insert: (e, t, n) => {
            t.insertBefore(e, n || null)
        },
        remove: e => {
            const t = e.parentNode;
            t && t.removeChild(e)
        },
        createElement: (e, t, n, r) => {
            const i = t === "svg" ? co.createElementNS(g1, e) : t === "mathml" ? co.createElementNS(_1, e) : n ? co.createElement(e, {
                is: n
            }) : co.createElement(e);
            return e === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple), i
        },
        createText: e => co.createTextNode(e),
        createComment: e => co.createComment(e),
        setText: (e, t) => {
            e.nodeValue = t
        },
        setElementText: (e, t) => {
            e.textContent = t
        },
        parentNode: e => e.parentNode,
        nextSibling: e => e.nextSibling,
        querySelector: e => co.querySelector(e),
        setScopeId(e, t) {
            e.setAttribute(t, "")
        },
        insertStaticContent(e, t, n, r, i, s) {
            const a = n ? n.previousSibling : t.lastChild;
            if (i && (i === s || i.nextSibling))
                for (; t.insertBefore(i.cloneNode(!0), n), !(i === s || !(i = i.nextSibling)););
            else {
                bd.innerHTML = S_(r === "svg" ? `<svg>${e}</svg>` : r === "mathml" ? `<math>${e}</math>` : e);
                const c = bd.content;
                if (r === "svg" || r === "mathml") {
                    const u = c.firstChild;
                    for (; u.firstChild;) c.appendChild(u.firstChild);
                    c.removeChild(u)
                }
                t.insertBefore(c, n)
            }
            return [a ? a.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
        }
    },
    xo = "transition",
    cl = "animation",
    Ua = Symbol("_vtc"),
    T_ = {
        name: String,
        type: String,
        css: {
            type: Boolean,
            default: !0
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
    },
    P_ = cr({}, Bg, T_),
    y1 = e => (e.displayName = "Transition", e.props = P_, e),
    v1 = y1((e, {
        slots: t
    }) => jr(uy, k_(e), t)),
    sa = (e, t = []) => {
        Wt(e) ? e.forEach(n => n(...t)) : e && e(...t)
    },
    wd = e => e ? Wt(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;

function k_(e) {
    const t = {};
    for (const ne in e) ne in T_ || (t[ne] = e[ne]);
    if (e.css === !1) return t;
    const {
        name: n = "v",
        type: r,
        duration: i,
        enterFromClass: s = `${n}-enter-from`,
        enterActiveClass: a = `${n}-enter-active`,
        enterToClass: c = `${n}-enter-to`,
        appearFromClass: u = s,
        appearActiveClass: p = a,
        appearToClass: d = c,
        leaveFromClass: g = `${n}-leave-from`,
        leaveActiveClass: m = `${n}-leave-active`,
        leaveToClass: E = `${n}-leave-to`
    } = e, L = b1(i), b = L && L[0], j = L && L[1], {
        onBeforeEnter: A,
        onEnter: $,
        onEnterCancelled: w,
        onLeave: k,
        onLeaveCancelled: S,
        onBeforeAppear: X = A,
        onAppear: J = $,
        onAppearCancelled: xe = w
    } = t, he = (ne, re, K, te) => {
        ne._enterCancelled = te, Po(ne, re ? d : c), Po(ne, re ? p : a), K && K()
    }, me = (ne, re) => {
        ne._isLeaving = !1, Po(ne, g), Po(ne, E), Po(ne, m), re && re()
    }, Q = ne => (re, K) => {
        const te = ne ? J : $,
            G = () => he(re, ne, K);
        sa(te, [re, G]), Dd(() => {
            Po(re, ne ? u : s), Gs(re, ne ? d : c), wd(te) || xd(re, r, b, G)
        })
    };
    return cr(t, {
        onBeforeEnter(ne) {
            sa(A, [ne]), Gs(ne, s), Gs(ne, a)
        },
        onBeforeAppear(ne) {
            sa(X, [ne]), Gs(ne, u), Gs(ne, p)
        },
        onEnter: Q(!1),
        onAppear: Q(!0),
        onLeave(ne, re) {
            ne._isLeaving = !0;
            const K = () => me(ne, re);
            Gs(ne, g), ne._enterCancelled ? (Gs(ne, m), $f()) : ($f(), Gs(ne, m)), Dd(() => {
                ne._isLeaving && (Po(ne, g), Gs(ne, E), wd(k) || xd(ne, r, j, K))
            }), sa(k, [ne, K])
        },
        onEnterCancelled(ne) {
            he(ne, !1, void 0, !0), sa(w, [ne])
        },
        onAppearCancelled(ne) {
            he(ne, !0, void 0, !0), sa(xe, [ne])
        },
        onLeaveCancelled(ne) {
            me(ne), sa(S, [ne])
        }
    })
}

function b1(e) {
    if (e == null) return null;
    if (or(e)) return [tf(e.enter), tf(e.leave)];
    {
        const t = tf(e);
        return [t, t]
    }
}

function tf(e) {
    return ju(e)
}

function Gs(e, t) {
    t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e[Ua] || (e[Ua] = new Set)).add(t)
}

function Po(e, t) {
    t.split(/\s+/).forEach(r => r && e.classList.remove(r));
    const n = e[Ua];
    n && (n.delete(t), n.size || (e[Ua] = void 0))
}

function Dd(e) {
    requestAnimationFrame(() => {
        requestAnimationFrame(e)
    })
}
let w1 = 0;

function xd(e, t, n, r) {
    const i = e._endId = ++w1,
        s = () => {
            i === e._endId && r()
        };
    if (n != null) return setTimeout(s, n);
    const {
        type: a,
        timeout: c,
        propCount: u
    } = A_(e, t);
    if (!a) return r();
    const p = a + "end";
    let d = 0;
    const g = () => {
            e.removeEventListener(p, m), s()
        },
        m = E => {
            E.target === e && ++d >= u && g()
        };
    setTimeout(() => {
        d < u && g()
    }, c + 1), e.addEventListener(p, m)
}

function A_(e, t) {
    const n = window.getComputedStyle(e),
        r = L => (n[L] || "").split(", "),
        i = r(`${xo}Delay`),
        s = r(`${xo}Duration`),
        a = Ed(i, s),
        c = r(`${cl}Delay`),
        u = r(`${cl}Duration`),
        p = Ed(c, u);
    let d = null,
        g = 0,
        m = 0;
    t === xo ? a > 0 && (d = xo, g = a, m = s.length) : t === cl ? p > 0 && (d = cl, g = p, m = u.length) : (g = Math.max(a, p), d = g > 0 ? a > p ? xo : cl : null, m = d ? d === xo ? s.length : u.length : 0);
    const E = d === xo && /\b(transform|all)(,|$)/.test(r(`${xo}Property`).toString());
    return {
        type: d,
        timeout: g,
        propCount: m,
        hasTransform: E
    }
}

function Ed(e, t) {
    for (; e.length < t.length;) e = e.concat(e);
    return Math.max(...t.map((n, r) => Cd(n) + Cd(e[r])))
}

function Cd(e) {
    return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3
}

function $f() {
    return document.body.offsetHeight
}

function D1(e, t, n) {
    const r = e[Ua];
    r && (t = (t ? [t, ...r] : [...r]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}
const rc = Symbol("_vod"),
    R_ = Symbol("_vsh"),
    x1 = {
        beforeMount(e, {
            value: t
        }, {
            transition: n
        }) {
            e[rc] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : fl(e, t)
        },
        mounted(e, {
            value: t
        }, {
            transition: n
        }) {
            n && t && n.enter(e)
        },
        updated(e, {
            value: t,
            oldValue: n
        }, {
            transition: r
        }) {
            !t != !n && (r ? t ? (r.beforeEnter(e), fl(e, !0), r.enter(e)) : r.leave(e, () => {
                fl(e, !1)
            }) : fl(e, t))
        },
        beforeUnmount(e, {
            value: t
        }) {
            fl(e, t)
        }
    };

function fl(e, t) {
    e.style.display = t ? e[rc] : "none", e[R_] = !t
}

function E1() {
    x1.getSSRProps = ({
        value: e
    }) => {
        if (!e) return {
            style: {
                display: "none"
            }
        }
    }
}
const O_ = Symbol("");

function C1(e) {
    const t = wi();
    if (!t) return;
    const n = t.ut = (i = e(t.proxy)) => {
            Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(s => ic(s, i))
        },
        r = () => {
            const i = e(t.proxy);
            t.ce ? ic(t.ce, i) : Hf(t.subTree, i), n(i)
        };
    qg(() => {
        Xu(r)
    }), $i(() => {
        Qr(r, vs, {
            flush: "post"
        });
        const i = new MutationObserver(r);
        i.observe(t.subTree.el.parentNode, {
            childList: !0
        }), Pc(() => i.disconnect())
    })
}

function Hf(e, t) {
    if (e.shapeFlag & 128) {
        const n = e.suspense;
        e = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => {
            Hf(n.activeBranch, t)
        })
    }
    for (; e.component;) e = e.component.subTree;
    if (e.shapeFlag & 1 && e.el) ic(e.el, t);
    else if (e.type === zr) e.children.forEach(n => Hf(n, t));
    else if (e.type === Ha) {
        let {
            el: n,
            anchor: r
        } = e;
        for (; n && (ic(n, t), n !== r);) n = n.nextSibling
    }
}

function ic(e, t) {
    if (e.nodeType === 1) {
        const n = e.style;
        let r = "";
        for (const i in t) n.setProperty(`--${i}`, t[i]), r += `--${i}: ${t[i]};`;
        n[O_] = r
    }
}
const S1 = /(^|;)\s*display\s*:/;

function T1(e, t, n) {
    const r = e.style,
        i = yr(n);
    let s = !1;
    if (n && !i) {
        if (t)
            if (yr(t))
                for (const a of t.split(";")) {
                    const c = a.slice(0, a.indexOf(":")).trim();
                    n[c] == null && $u(r, c, "")
                } else
                    for (const a in t) n[a] == null && $u(r, a, "");
        for (const a in n) a === "display" && (s = !0), $u(r, a, n[a])
    } else if (i) {
        if (t !== n) {
            const a = r[O_];
            a && (n += ";" + a), r.cssText = n, s = S1.test(n)
        }
    } else t && e.removeAttribute("style");
    rc in e && (e[rc] = s ? r.display : "", e[R_] && (r.display = "none"))
}
const Sd = /\s*!important$/;

function $u(e, t, n) {
    if (Wt(n)) n.forEach(r => $u(e, t, r));
    else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n);
    else {
        const r = P1(e, t);
        Sd.test(n) ? e.setProperty(is(r), n.replace(Sd, ""), "important") : e[r] = n
    }
}
const Td = ["Webkit", "Moz", "ms"],
    nf = {};

function P1(e, t) {
    const n = nf[t];
    if (n) return n;
    let r = Bi(t);
    if (r !== "filter" && r in e) return nf[t] = r;
    r = eu(r);
    for (let i = 0; i < Td.length; i++) {
        const s = Td[i] + r;
        if (s in e) return nf[t] = s
    }
    return t
}
const Pd = "http://www.w3.org/1999/xlink";

function kd(e, t, n, r, i, s = Cm(t)) {
    r && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(Pd, t.slice(6, t.length)) : e.setAttributeNS(Pd, t, n) : n == null || s && !ig(n) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : Fs(n) ? String(n) : n)
}

function Ad(e, t, n, r, i) {
    if (t === "innerHTML" || t === "textContent") {
        n != null && (e[t] = t === "innerHTML" ? S_(n) : n);
        return
    }
    const s = e.tagName;
    if (t === "value" && s !== "PROGRESS" && !s.includes("-")) {
        const c = s === "OPTION" ? e.getAttribute("value") || "" : e.value,
            u = n == null ? e.type === "checkbox" ? "on" : "" : String(n);
        (c !== u || !("_value" in e)) && (e.value = u), n == null && e.removeAttribute(t), e._value = n;
        return
    }
    let a = !1;
    if (n === "" || n == null) {
        const c = typeof e[t];
        c === "boolean" ? n = ig(n) : n == null && c === "string" ? (n = "", a = !0) : c === "number" && (n = 0, a = !0)
    }
    try {
        e[t] = n
    } catch {}
    a && e.removeAttribute(i || t)
}

function po(e, t, n, r) {
    e.addEventListener(t, n, r)
}

function k1(e, t, n, r) {
    e.removeEventListener(t, n, r)
}
const Rd = Symbol("_vei");

function A1(e, t, n, r, i = null) {
    const s = e[Rd] || (e[Rd] = {}),
        a = s[t];
    if (r && a) a.value = r;
    else {
        const [c, u] = R1(t);
        if (r) {
            const p = s[t] = L1(r, i);
            po(e, c, p, u)
        } else a && (k1(e, c, a, u), s[t] = void 0)
    }
}
const Od = /(?:Once|Passive|Capture)$/;

function R1(e) {
    let t;
    if (Od.test(e)) {
        t = {};
        let r;
        for (; r = e.match(Od);) e = e.slice(0, e.length - r[0].length), t[r[0].toLowerCase()] = !0
    }
    return [e[2] === ":" ? e.slice(3) : is(e.slice(2)), t]
}
let rf = 0;
const O1 = Promise.resolve(),
    M1 = () => rf || (O1.then(() => rf = 0), rf = Date.now());

function L1(e, t) {
    const n = r => {
        if (!r._vts) r._vts = Date.now();
        else if (r._vts <= n.attached) return;
        Is(F1(r, n.value), t, 5, [r])
    };
    return n.value = e, n.attached = M1(), n
}

function F1(e, t) {
    if (Wt(t)) {
        const n = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = () => {
            n.call(e), e._stopped = !0
        }, t.map(r => i => !i._stopped && r && r(i))
    } else return t
}
const Md = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,
    I1 = (e, t, n, r, i, s) => {
        const a = i === "svg";
        t === "class" ? D1(e, r, a) : t === "style" ? T1(e, n, r) : Zl(t) ? ph(t) || A1(e, t, n, r, s) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : N1(e, t, r, a)) ? (Ad(e, t, r), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && kd(e, t, r, a, s, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !yr(r)) ? Ad(e, Bi(t), r, s, t) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r), kd(e, t, r, a))
    };

function N1(e, t, n, r) {
    if (r) return !!(t === "innerHTML" || t === "textContent" || t in e && Md(t) && ln(n));
    if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1;
    if (t === "width" || t === "height") {
        const i = e.tagName;
        if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE") return !1
    }
    return Md(t) && yr(n) ? !1 : t in e
}
const Ld = {}; /*! #__NO_SIDE_EFFECTS__ */
function B1(e, t, n) {
    const r = Jr(e, t);
    mc(r) && cr(r, t);
    class i extends Ih {
        constructor(a) {
            super(r, a, n)
        }
    }
    return i.def = r, i
} /*! #__NO_SIDE_EFFECTS__ */
const lP = (e, t) => B1(e, t, z_),
    $1 = typeof HTMLElement < "u" ? HTMLElement : class {};
class Ih extends $1 {
    constructor(t, n = {}, r = zf) {
        super(), this._def = t, this._props = n, this._createApp = r, this._isVueCE = !0, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = !1, this._resolved = !1, this._numberProps = null, this._styleChildren = new WeakSet, this._ob = null, this.shadowRoot && r !== zf ? this._root = this.shadowRoot : t.shadowRoot !== !1 ? (this.attachShadow({
            mode: "open"
        }), this._root = this.shadowRoot) : this._root = this, this._def.__asyncLoader || this._resolveProps(this._def)
    }
    connectedCallback() {
        if (!this.isConnected) return;
        this.shadowRoot || this._parseSlots(), this._connected = !0;
        let t = this;
        for (; t = t && (t.parentNode || t.host);)
            if (t instanceof Ih) {
                this._parent = t;
                break
            } this._instance || (this._resolved ? (this._setParent(), this._update()) : t && t._pendingResolve ? this._pendingResolve = t._pendingResolve.then(() => {
            this._pendingResolve = void 0, this._resolveDef()
        }) : this._resolveDef())
    }
    _setParent(t = this._parent) {
        t && (this._instance.parent = t._instance, this._instance.provides = t._instance.provides)
    }
    disconnectedCallback() {
        this._connected = !1, ss(() => {
            this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null)
        })
    }
    _resolveDef() {
        if (this._pendingResolve) return;
        for (let r = 0; r < this.attributes.length; r++) this._setAttr(this.attributes[r].name);
        this._ob = new MutationObserver(r => {
            for (const i of r) this._setAttr(i.attributeName)
        }), this._ob.observe(this, {
            attributes: !0
        });
        const t = (r, i = !1) => {
                this._resolved = !0, this._pendingResolve = void 0;
                const {
                    props: s,
                    styles: a
                } = r;
                let c;
                if (s && !Wt(s))
                    for (const u in s) {
                        const p = s[u];
                        (p === Number || p && p.type === Number) && (u in this._props && (this._props[u] = ju(this._props[u])), (c || (c = Object.create(null)))[Bi(u)] = !0)
                    }
                this._numberProps = c, i && this._resolveProps(r), this.shadowRoot && this._applyStyles(a), this._mount(r)
            },
            n = this._def.__asyncLoader;
        n ? this._pendingResolve = n().then(r => t(this._def = r, !0)) : t(this._def)
    }
    _mount(t) {
        this._app = this._createApp(t), t.configureApp && t.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root);
        const n = this._instance && this._instance.exposed;
        if (n)
            for (const r in n) Xn(this, r) || Object.defineProperty(this, r, {
                get: () => Kt(n[r])
            })
    }
    _resolveProps(t) {
        const {
            props: n
        } = t, r = Wt(n) ? n : Object.keys(n || {});
        for (const i of Object.keys(this)) i[0] !== "_" && r.includes(i) && this._setProp(i, this[i]);
        for (const i of r.map(Bi)) Object.defineProperty(this, i, {
            get() {
                return this._getProp(i)
            },
            set(s) {
                this._setProp(i, s, !0, !0)
            }
        })
    }
    _setAttr(t) {
        if (t.startsWith("data-v-")) return;
        const n = this.hasAttribute(t);
        let r = n ? this.getAttribute(t) : Ld;
        const i = Bi(t);
        n && this._numberProps && this._numberProps[i] && (r = ju(r)), this._setProp(i, r, !1, !0)
    }
    _getProp(t) {
        return this._props[t]
    }
    _setProp(t, n, r = !0, i = !1) {
        if (n !== this._props[t] && (n === Ld ? delete this._props[t] : (this._props[t] = n, t === "key" && this._app && (this._app._ceVNode.key = n)), i && this._instance && this._update(), r)) {
            const s = this._ob;
            s && s.disconnect(), n === !0 ? this.setAttribute(is(t), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(is(t), n + "") : n || this.removeAttribute(is(t)), s && s.observe(this, {
                attributes: !0
            })
        }
    }
    _update() {
        ev(this._createVNode(), this._root)
    }
    _createVNode() {
        const t = {};
        this.shadowRoot || (t.onVnodeMounted = t.onVnodeUpdated = this._renderSlots.bind(this));
        const n = wn(this._def, cr(t, this._props));
        return this._instance || (n.ce = r => {
            this._instance = r, r.ce = this, r.isCE = !0;
            const i = (s, a) => {
                this.dispatchEvent(new CustomEvent(s, mc(a[0]) ? cr({
                    detail: a
                }, a[0]) : {
                    detail: a
                }))
            };
            r.emit = (s, ...a) => {
                i(s, a), is(s) !== s && i(is(s), a)
            }, this._setParent()
        }), n
    }
    _applyStyles(t, n) {
        if (!t) return;
        if (n) {
            if (n === this._def || this._styleChildren.has(n)) return;
            this._styleChildren.add(n)
        }
        const r = this._nonce;
        for (let i = t.length - 1; i >= 0; i--) {
            const s = document.createElement("style");
            r && s.setAttribute("nonce", r), s.textContent = t[i], this.shadowRoot.prepend(s)
        }
    }
    _parseSlots() {
        const t = this._slots = {};
        let n;
        for (; n = this.firstChild;) {
            const r = n.nodeType === 1 && n.getAttribute("slot") || "default";
            (t[r] || (t[r] = [])).push(n), this.removeChild(n)
        }
    }
    _renderSlots() {
        const t = (this._teleportTarget || this).querySelectorAll("slot"),
            n = this._instance.type.__scopeId;
        for (let r = 0; r < t.length; r++) {
            const i = t[r],
                s = i.getAttribute("name") || "default",
                a = this._slots[s],
                c = i.parentNode;
            if (a)
                for (const u of a) {
                    if (n && u.nodeType === 1) {
                        const p = n + "-s",
                            d = document.createTreeWalker(u, 1);
                        u.setAttribute(p, "");
                        let g;
                        for (; g = d.nextNode();) g.setAttribute(p, "")
                    }
                    c.insertBefore(u, i)
                } else
                    for (; i.firstChild;) c.insertBefore(i.firstChild, i);
            c.removeChild(i)
        }
    }
    _injectChildStyle(t) {
        this._applyStyles(t.styles, t)
    }
    _removeChildStyle(t) {}
}

function H1(e) {
    const t = wi(),
        n = t && t.ce;
    return n || null
}

function uP() {
    const e = H1();
    return e && e.shadowRoot
}

function cP(e = "$style") {
    {
        const t = wi();
        if (!t) return $n;
        const n = t.type.__cssModules;
        if (!n) return $n;
        const r = n[e];
        return r || $n
    }
}
const M_ = new WeakMap,
    L_ = new WeakMap,
    sc = Symbol("_moveCb"),
    Fd = Symbol("_enterCb"),
    V1 = e => (delete e.props.mode, e),
    z1 = V1({
        name: "TransitionGroup",
        props: cr({}, P_, {
            tag: String,
            moveClass: String
        }),
        setup(e, {
            slots: t
        }) {
            const n = wi(),
                r = Ng();
            let i, s;
            return Sh(() => {
                if (!i.length) return;
                const a = e.moveClass || `${e.name||"v"}-move`;
                if (!q1(i[0].el, n.vnode.el, a)) return;
                i.forEach(j1), i.forEach(U1);
                const c = i.filter(W1);
                $f(), c.forEach(u => {
                    const p = u.el,
                        d = p.style;
                    Gs(p, a), d.transform = d.webkitTransform = d.transitionDuration = "";
                    const g = p[sc] = m => {
                        m && m.target !== p || (!m || /transform$/.test(m.propertyName)) && (p.removeEventListener("transitionend", g), p[sc] = null, Po(p, a))
                    };
                    p.addEventListener("transitionend", g)
                })
            }), () => {
                const a = Bn(e),
                    c = k_(a);
                let u = a.tag || zr;
                if (i = [], s)
                    for (let p = 0; p < s.length; p++) {
                        const d = s[p];
                        d.el && d.el instanceof Element && (i.push(d), Vo(d, jl(d, c, r, n)), M_.set(d, d.el.getBoundingClientRect()))
                    }
                s = t.default ? Eh(t.default()) : [];
                for (let p = 0; p < s.length; p++) {
                    const d = s[p];
                    d.key != null && Vo(d, jl(d, c, r, n))
                }
                return wn(u, null, s)
            }
        }
    }),
    fP = z1;

function j1(e) {
    const t = e.el;
    t[sc] && t[sc](), t[Fd] && t[Fd]()
}

function U1(e) {
    L_.set(e, e.el.getBoundingClientRect())
}

function W1(e) {
    const t = M_.get(e),
        n = L_.get(e),
        r = t.left - n.left,
        i = t.top - n.top;
    if (r || i) {
        const s = e.el.style;
        return s.transform = s.webkitTransform = `translate(${r}px,${i}px)`, s.transitionDuration = "0s", e
    }
}

function q1(e, t, n) {
    const r = e.cloneNode(),
        i = e[Ua];
    i && i.forEach(c => {
        c.split(/\s+/).forEach(u => u && r.classList.remove(u))
    }), n.split(/\s+/).forEach(c => c && r.classList.add(c)), r.style.display = "none";
    const s = t.nodeType === 1 ? t : t.parentNode;
    s.appendChild(r);
    const {
        hasTransform: a
    } = A_(r);
    return s.removeChild(r), a
}
const jo = e => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return Wt(t) ? n => Ia(t, n) : t
};

function G1(e) {
    e.target.composing = !0
}

function Id(e) {
    const t = e.target;
    t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")))
}
const Ds = Symbol("_assign"),
    Vf = {
        created(e, {
            modifiers: {
                lazy: t,
                trim: n,
                number: r
            }
        }, i) {
            e[Ds] = jo(i);
            const s = r || i.props && i.props.type === "number";
            po(e, t ? "change" : "input", a => {
                if (a.target.composing) return;
                let c = e.value;
                n && (c = c.trim()), s && (c = zu(c)), e[Ds](c)
            }), n && po(e, "change", () => {
                e.value = e.value.trim()
            }), t || (po(e, "compositionstart", G1), po(e, "compositionend", Id), po(e, "change", Id))
        },
        mounted(e, {
            value: t
        }) {
            e.value = t ?? ""
        },
        beforeUpdate(e, {
            value: t,
            oldValue: n,
            modifiers: {
                lazy: r,
                trim: i,
                number: s
            }
        }, a) {
            if (e[Ds] = jo(a), e.composing) return;
            const c = (s || e.type === "number") && !/^0\d/.test(e.value) ? zu(e.value) : e.value,
                u = t ?? "";
            c !== u && (document.activeElement === e && e.type !== "range" && (r && t === n || i && e.value.trim() === u) || (e.value = u))
        }
    },
    F_ = {
        deep: !0,
        created(e, t, n) {
            e[Ds] = jo(n), po(e, "change", () => {
                const r = e._modelValue,
                    i = Wa(e),
                    s = e.checked,
                    a = e[Ds];
                if (Wt(r)) {
                    const c = wc(r, i),
                        u = c !== -1;
                    if (s && !u) a(r.concat(i));
                    else if (!s && u) {
                        const p = [...r];
                        p.splice(c, 1), a(p)
                    }
                } else if (ma(r)) {
                    const c = new Set(r);
                    s ? c.add(i) : c.delete(i), a(c)
                } else a(N_(e, s))
            })
        },
        mounted: Nd,
        beforeUpdate(e, t, n) {
            e[Ds] = jo(n), Nd(e, t, n)
        }
    };

function Nd(e, {
    value: t,
    oldValue: n
}, r) {
    e._modelValue = t;
    let i;
    if (Wt(t)) i = wc(t, r.props.value) > -1;
    else if (ma(t)) i = t.has(r.props.value);
    else {
        if (t === n) return;
        i = $o(t, N_(e, !0))
    }
    e.checked !== i && (e.checked = i)
}
const I_ = {
        created(e, {
            value: t
        }, n) {
            e.checked = $o(t, n.props.value), e[Ds] = jo(n), po(e, "change", () => {
                e[Ds](Wa(e))
            })
        },
        beforeUpdate(e, {
            value: t,
            oldValue: n
        }, r) {
            e[Ds] = jo(r), t !== n && (e.checked = $o(t, r.props.value))
        }
    },
    Y1 = {
        deep: !0,
        created(e, {
            value: t,
            modifiers: {
                number: n
            }
        }, r) {
            const i = ma(t);
            po(e, "change", () => {
                const s = Array.prototype.filter.call(e.options, a => a.selected).map(a => n ? zu(Wa(a)) : Wa(a));
                e[Ds](e.multiple ? i ? new Set(s) : s : s[0]), e._assigning = !0, ss(() => {
                    e._assigning = !1
                })
            }), e[Ds] = jo(r)
        },
        mounted(e, {
            value: t
        }) {
            Bd(e, t)
        },
        beforeUpdate(e, t, n) {
            e[Ds] = jo(n)
        },
        updated(e, {
            value: t
        }) {
            e._assigning || Bd(e, t)
        }
    };

function Bd(e, t) {
    const n = e.multiple,
        r = Wt(t);
    if (!(n && !r && !ma(t))) {
        for (let i = 0, s = e.options.length; i < s; i++) {
            const a = e.options[i],
                c = Wa(a);
            if (n)
                if (r) {
                    const u = typeof c;
                    u === "string" || u === "number" ? a.selected = t.some(p => String(p) === String(c)) : a.selected = wc(t, c) > -1
                } else a.selected = t.has(c);
            else if ($o(Wa(a), t)) {
                e.selectedIndex !== i && (e.selectedIndex = i);
                return
            }
        }!n && e.selectedIndex !== -1 && (e.selectedIndex = -1)
    }
}

function Wa(e) {
    return "_value" in e ? e._value : e.value
}

function N_(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t
}
const X1 = {
    created(e, t, n) {
        Cu(e, t, n, null, "created")
    },
    mounted(e, t, n) {
        Cu(e, t, n, null, "mounted")
    },
    beforeUpdate(e, t, n, r) {
        Cu(e, t, n, r, "beforeUpdate")
    },
    updated(e, t, n, r) {
        Cu(e, t, n, r, "updated")
    }
};

function B_(e, t) {
    switch (e) {
        case "SELECT":
            return Y1;
        case "TEXTAREA":
            return Vf;
        default:
            switch (t) {
                case "checkbox":
                    return F_;
                case "radio":
                    return I_;
                default:
                    return Vf
            }
    }
}

function Cu(e, t, n, r, i) {
    const a = B_(e.tagName, n.props && n.props.type)[i];
    a && a(e, t, n, r)
}

function K1() {
    Vf.getSSRProps = ({
        value: e
    }) => ({
        value: e
    }), I_.getSSRProps = ({
        value: e
    }, t) => {
        if (t.props && $o(t.props.value, e)) return {
            checked: !0
        }
    }, F_.getSSRProps = ({
        value: e
    }, t) => {
        if (Wt(e)) {
            if (t.props && wc(e, t.props.value) > -1) return {
                checked: !0
            }
        } else if (ma(e)) {
            if (t.props && e.has(t.props.value)) return {
                checked: !0
            }
        } else if (e) return {
            checked: !0
        }
    }, X1.getSSRProps = (e, t) => {
        if (typeof t.type != "string") return;
        const n = B_(t.type.toUpperCase(), t.props && t.props.type);
        if (n.getSSRProps) return n.getSSRProps(e, t)
    }
}
const Q1 = ["ctrl", "shift", "alt", "meta"],
    J1 = {
        stop: e => e.stopPropagation(),
        prevent: e => e.preventDefault(),
        self: e => e.target !== e.currentTarget,
        ctrl: e => !e.ctrlKey,
        shift: e => !e.shiftKey,
        alt: e => !e.altKey,
        meta: e => !e.metaKey,
        left: e => "button" in e && e.button !== 0,
        middle: e => "button" in e && e.button !== 1,
        right: e => "button" in e && e.button !== 2,
        exact: (e, t) => Q1.some(n => e[`${n}Key`] && !t.includes(n))
    },
    hP = (e, t) => {
        const n = e._withMods || (e._withMods = {}),
            r = t.join(".");
        return n[r] || (n[r] = (i, ...s) => {
            for (let a = 0; a < t.length; a++) {
                const c = J1[t[a]];
                if (c && c(i, t)) return
            }
            return e(i, ...s)
        })
    },
    Z1 = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    },
    dP = (e, t) => {
        const n = e._withKeys || (e._withKeys = {}),
            r = t.join(".");
        return n[r] || (n[r] = i => {
            if (!("key" in i)) return;
            const s = is(i.key);
            if (t.some(a => a === s || Z1[a] === s)) return e(i)
        })
    },
    $_ = cr({
        patchProp: I1
    }, m1);
let Ll, $d = !1;

function H_() {
    return Ll || (Ll = Vy($_))
}

function V_() {
    return Ll = $d ? Ll : zy($_), $d = !0, Ll
}
const ev = (...e) => {
        H_().render(...e)
    },
    pP = (...e) => {
        V_().hydrate(...e)
    },
    zf = (...e) => {
        const t = H_().createApp(...e),
            {
                mount: n
            } = t;
        return t.mount = r => {
            const i = U_(r);
            if (!i) return;
            const s = t._component;
            !ln(s) && !s.render && !s.template && (s.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
            const a = n(i, !1, j_(i));
            return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), a
        }, t
    },
    z_ = (...e) => {
        const t = V_().createApp(...e),
            {
                mount: n
            } = t;
        return t.mount = r => {
            const i = U_(r);
            if (i) return n(i, !0, j_(i))
        }, t
    };

function j_(e) {
    if (e instanceof SVGElement) return "svg";
    if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml"
}

function U_(e) {
    return yr(e) ? document.querySelector(e) : e
}
let Hd = !1;
const gP = () => {
        Hd || (Hd = !0, K1(), E1())
    },
    tv = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
    nv = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
    rv = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;

function iv(e, t) {
    if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype" in t) {
        sv(e);
        return
    }
    return t
}

function sv(e) {
    console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)
}

function oc(e, t = {}) {
    if (typeof e != "string") return e;
    if (e[0] === '"' && e[e.length - 1] === '"' && e.indexOf("\\") === -1) return e.slice(1, -1);
    const n = e.trim();
    if (n.length <= 9) switch (n.toLowerCase()) {
        case "true":
            return !0;
        case "false":
            return !1;
        case "undefined":
            return;
        case "null":
            return null;
        case "nan":
            return Number.NaN;
        case "infinity":
            return Number.POSITIVE_INFINITY;
        case "-infinity":
            return Number.NEGATIVE_INFINITY
    }
    if (!rv.test(e)) {
        if (t.strict) throw new SyntaxError("[destr] Invalid JSON");
        return e
    }
    try {
        if (tv.test(e) || nv.test(e)) {
            if (t.strict) throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(e, iv)
        }
        return JSON.parse(e)
    } catch (r) {
        if (t.strict) throw r;
        return e
    }
}
const ov = /#/g,
    av = /&/g,
    lv = /\//g,
    uv = /=/g,
    Nh = /\+/g,
    cv = /%5e/gi,
    fv = /%60/gi,
    hv = /%7c/gi,
    dv = /%20/gi;

function pv(e) {
    return encodeURI("" + e).replace(hv, "|")
}

function jf(e) {
    return pv(typeof e == "string" ? e : JSON.stringify(e)).replace(Nh, "%2B").replace(dv, "+").replace(ov, "%23").replace(av, "%26").replace(fv, "`").replace(cv, "^").replace(lv, "%2F")
}

function sf(e) {
    return jf(e).replace(uv, "%3D")
}

function ac(e = "") {
    try {
        return decodeURIComponent("" + e)
    } catch {
        return "" + e
    }
}

function gv(e) {
    return ac(e.replace(Nh, " "))
}

function _v(e) {
    return ac(e.replace(Nh, " "))
}

function Bh(e = "") {
    const t = Object.create(null);
    e[0] === "?" && (e = e.slice(1));
    for (const n of e.split("&")) {
        const r = n.match(/([^=]+)=?(.*)/) || [];
        if (r.length < 2) continue;
        const i = gv(r[1]);
        if (i === "__proto__" || i === "constructor") continue;
        const s = _v(r[2] || "");
        t[i] === void 0 ? t[i] = s : Array.isArray(t[i]) ? t[i].push(s) : t[i] = [t[i], s]
    }
    return t
}

function mv(e, t) {
    return (typeof t == "number" || typeof t == "boolean") && (t = String(t)), t ? Array.isArray(t) ? t.map(n => `${sf(e)}=${jf(n)}`).join("&") : `${sf(e)}=${jf(t)}` : sf(e)
}

function yv(e) {
    return Object.keys(e).filter(t => e[t] !== void 0).map(t => mv(t, e[t])).filter(Boolean).join("&")
}
const vv = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/,
    W_ = /^[\s\w\0+.-]{2,}:([/\\]{2})?/,
    bv = /^([/\\]\s*){2,}[^/\\]/,
    wv = /^[\s\0]*(blob|data|javascript|vbscript):$/i,
    Dv = /\/$|\/\?|\/#/,
    xv = /^\.?\//;

function Qs(e, t = {}) {
    return typeof t == "boolean" && (t = {
        acceptRelative: t
    }), t.strict ? vv.test(e) : W_.test(e) || (t.acceptRelative ? bv.test(e) : !1)
}

function Ev(e) {
    return !!e && wv.test(e)
}

function Uf(e = "", t) {
    return t ? Dv.test(e) : e.endsWith("/")
}

function qa(e = "", t) {
    if (!t) return (Uf(e) ? e.slice(0, -1) : e) || "/";
    if (!Uf(e, !0)) return e || "/";
    let n = e,
        r = "";
    const i = e.indexOf("#");
    i !== -1 && (n = e.slice(0, i), r = e.slice(i));
    const [s, ...a] = n.split("?");
    return ((s.endsWith("/") ? s.slice(0, -1) : s) || "/") + (a.length > 0 ? `?${a.join("?")}` : "") + r
}

function q_(e = "", t) {
    if (!t) return e.endsWith("/") ? e : e + "/";
    if (Uf(e, !0)) return e || "/";
    let n = e,
        r = "";
    const i = e.indexOf("#");
    if (i !== -1 && (n = e.slice(0, i), r = e.slice(i), !n)) return r;
    const [s, ...a] = n.split("?");
    return s + "/" + (a.length > 0 ? `?${a.join("?")}` : "") + r
}

function Cv(e = "") {
    return e.startsWith("/")
}

function _P(e = "") {
    return Cv(e) ? e : "/" + e
}

function Sv(e, t) {
    if (G_(t) || Qs(e)) return e;
    const n = qa(t);
    return e.startsWith(n) ? e : Rc(n, e)
}

function Vd(e, t) {
    if (G_(t)) return e;
    const n = qa(t);
    if (!e.startsWith(n)) return e;
    const r = e.slice(n.length);
    return r[0] === "/" ? r : "/" + r
}

function Yl(e, t) {
    const n = K_(e),
        r = {
            ...Bh(n.search),
            ...t
        };
    return n.search = yv(r), Rv(n)
}

function G_(e) {
    return !e || e === "/"
}

function Tv(e) {
    return e && e !== "/"
}

function Rc(e, ...t) {
    let n = e || "";
    for (const r of t.filter(i => Tv(i)))
        if (n) {
            const i = r.replace(xv, "");
            n = q_(n) + i
        } else n = r;
    return n
}

function Y_(...e) {
    var a, c, u, p;
    const t = /\/(?!\/)/,
        n = e.filter(Boolean),
        r = [];
    let i = 0;
    for (const d of n)
        if (!(!d || d === "/")) {
            for (const [g, m] of d.split(t).entries())
                if (!(!m || m === ".")) {
                    if (m === "..") {
                        if (r.length === 1 && Qs(r[0])) continue;
                        r.pop(), i--;
                        continue
                    }
                    if (g === 1 && ((a = r[r.length - 1]) != null && a.endsWith(":/"))) {
                        r[r.length - 1] += "/" + m;
                        continue
                    }
                    r.push(m), i++
                }
        } let s = r.join("/");
    return i >= 0 ? (c = n[0]) != null && c.startsWith("/") && !s.startsWith("/") ? s = "/" + s : (u = n[0]) != null && u.startsWith("./") && !s.startsWith("./") && (s = "./" + s) : s = "../".repeat(-1 * i) + s, (p = n[n.length - 1]) != null && p.endsWith("/") && !s.endsWith("/") && (s += "/"), s
}

function Pv(e) {
    return kv(e, "https://")
}

function kv(e, t) {
    let n = e.match(W_);
    return n || (n = e.match(/^\/{2,}/)), n ? t + e.slice(n[0].length) : t + e
}

function Av(e, t) {
    return ac(qa(e)) === ac(qa(t))
}
const X_ = Symbol.for("ufo:protocolRelative");

function K_(e = "", t) {
    const n = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
    if (n) {
        const [, g, m = ""] = n;
        return {
            protocol: g.toLowerCase(),
            pathname: m,
            href: g + m,
            auth: "",
            host: "",
            search: "",
            hash: ""
        }
    }
    if (!Qs(e, {
            acceptRelative: !0
        })) return zd(e);
    const [, r = "", i, s = ""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
    let [, a = "", c = ""] = s.match(/([^#/?]*)(.*)?/) || [];
    r === "file:" && (c = c.replace(/\/(?=[A-Za-z]:)/, ""));
    const {
        pathname: u,
        search: p,
        hash: d
    } = zd(c);
    return {
        protocol: r.toLowerCase(),
        auth: i ? i.slice(0, Math.max(0, i.length - 1)) : "",
        host: a,
        pathname: u,
        search: p,
        hash: d,
        [X_]: !r
    }
}

function zd(e = "") {
    const [t = "", n = "", r = ""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
    return {
        pathname: t,
        search: n,
        hash: r
    }
}

function Rv(e) {
    const t = e.pathname || "",
        n = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : "",
        r = e.hash || "",
        i = e.auth ? e.auth + "@" : "",
        s = e.host || "";
    return (e.protocol || e[X_] ? (e.protocol || "") + "//" : "") + i + s + t + n + r
}
class Ov extends Error {
    constructor(t, n) {
        super(t, n), this.name = "FetchError", n != null && n.cause && !this.cause && (this.cause = n.cause)
    }
}

function Mv(e) {
    var u, p, d, g, m;
    const t = ((u = e.error) == null ? void 0 : u.message) || ((p = e.error) == null ? void 0 : p.toString()) || "",
        n = ((d = e.request) == null ? void 0 : d.method) || ((g = e.options) == null ? void 0 : g.method) || "GET",
        r = ((m = e.request) == null ? void 0 : m.url) || String(e.request) || "/",
        i = `[${n}] ${JSON.stringify(r)}`,
        s = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>",
        a = `${i}: ${s}${t?` ${t}`:""}`,
        c = new Ov(a, e.error ? {
            cause: e.error
        } : void 0);
    for (const E of ["request", "options", "response"]) Object.defineProperty(c, E, {
        get() {
            return e[E]
        }
    });
    for (const [E, L] of [
            ["data", "_data"],
            ["status", "status"],
            ["statusCode", "status"],
            ["statusText", "statusText"],
            ["statusMessage", "statusText"]
        ]) Object.defineProperty(c, E, {
        get() {
            return e.response && e.response[L]
        }
    });
    return c
}
const Lv = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));

function jd(e = "GET") {
    return Lv.has(e.toUpperCase())
}

function Fv(e) {
    if (e === void 0) return !1;
    const t = typeof e;
    return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function"
}
const Iv = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]),
    Nv = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;

function Bv(e = "") {
    if (!e) return "json";
    const t = e.split(";").shift() || "";
    return Nv.test(t) ? "json" : Iv.has(t) || t.startsWith("text/") ? "text" : "blob"
}

function $v(e, t, n, r) {
    const i = Hv((t == null ? void 0 : t.headers) ?? (e == null ? void 0 : e.headers), n == null ? void 0 : n.headers, r);
    let s;
    return (n != null && n.query || n != null && n.params || t != null && t.params || t != null && t.query) && (s = {
        ...n == null ? void 0 : n.params,
        ...n == null ? void 0 : n.query,
        ...t == null ? void 0 : t.params,
        ...t == null ? void 0 : t.query
    }), {
        ...n,
        ...t,
        query: s,
        params: s,
        headers: i
    }
}

function Hv(e, t, n) {
    if (!t) return new n(e);
    const r = new n(t);
    if (e)
        for (const [i, s] of Symbol.iterator in e || Array.isArray(e) ? e : new n(e)) r.set(i, s);
    return r
}
async function Su(e, t) {
    if (t)
        if (Array.isArray(t))
            for (const n of t) await n(e);
        else await t(e)
}
const Vv = new Set([408, 409, 425, 429, 500, 502, 503, 504]),
    zv = new Set([101, 204, 205, 304]);

function Q_(e = {}) {
    const {
        fetch: t = globalThis.fetch,
        Headers: n = globalThis.Headers,
        AbortController: r = globalThis.AbortController
    } = e;
    async function i(c) {
        const u = c.error && c.error.name === "AbortError" && !c.options.timeout || !1;
        if (c.options.retry !== !1 && !u) {
            let d;
            typeof c.options.retry == "number" ? d = c.options.retry : d = jd(c.options.method) ? 0 : 1;
            const g = c.response && c.response.status || 500;
            if (d > 0 && (Array.isArray(c.options.retryStatusCodes) ? c.options.retryStatusCodes.includes(g) : Vv.has(g))) {
                const m = typeof c.options.retryDelay == "function" ? c.options.retryDelay(c) : c.options.retryDelay || 0;
                return m > 0 && await new Promise(E => setTimeout(E, m)), s(c.request, {
                    ...c.options,
                    retry: d - 1
                })
            }
        }
        const p = Mv(c);
        throw Error.captureStackTrace && Error.captureStackTrace(p, s), p
    }
    const s = async function(u, p = {}) {
        const d = {
            request: u,
            options: $v(u, p, e.defaults, n),
            response: void 0,
            error: void 0
        };
        d.options.method && (d.options.method = d.options.method.toUpperCase()), d.options.onRequest && await Su(d, d.options.onRequest), typeof d.request == "string" && (d.options.baseURL && (d.request = Sv(d.request, d.options.baseURL)), d.options.query && (d.request = Yl(d.request, d.options.query), delete d.options.query), "query" in d.options && delete d.options.query, "params" in d.options && delete d.options.params), d.options.body && jd(d.options.method) && (Fv(d.options.body) ? (d.options.body = typeof d.options.body == "string" ? d.options.body : JSON.stringify(d.options.body), d.options.headers = new n(d.options.headers || {}), d.options.headers.has("content-type") || d.options.headers.set("content-type", "application/json"), d.options.headers.has("accept") || d.options.headers.set("accept", "application/json")) : ("pipeTo" in d.options.body && typeof d.options.body.pipeTo == "function" || typeof d.options.body.pipe == "function") && ("duplex" in d.options || (d.options.duplex = "half")));
        let g;
        if (!d.options.signal && d.options.timeout) {
            const E = new r;
            g = setTimeout(() => {
                const L = new Error("[TimeoutError]: The operation was aborted due to timeout");
                L.name = "TimeoutError", L.code = 23, E.abort(L)
            }, d.options.timeout), d.options.signal = E.signal
        }
        try {
            d.response = await t(d.request, d.options)
        } catch (E) {
            return d.error = E, d.options.onRequestError && await Su(d, d.options.onRequestError), await i(d)
        } finally {
            g && clearTimeout(g)
        }
        if ((d.response.body || d.response._bodyInit) && !zv.has(d.response.status) && d.options.method !== "HEAD") {
            const E = (d.options.parseResponse ? "json" : d.options.responseType) || Bv(d.response.headers.get("content-type") || "");
            switch (E) {
                case "json": {
                    const L = await d.response.text(),
                        b = d.options.parseResponse || oc;
                    d.response._data = b(L);
                    break
                }
                case "stream": {
                    d.response._data = d.response.body || d.response._bodyInit;
                    break
                }
                default:
                    d.response._data = await d.response[E]()
            }
        }
        return d.options.onResponse && await Su(d, d.options.onResponse), !d.options.ignoreResponseError && d.response.status >= 400 && d.response.status < 600 ? (d.options.onResponseError && await Su(d, d.options.onResponseError), await i(d)) : d.response
    }, a = async function(u, p) {
        return (await s(u, p))._data
    };
    return a.raw = s, a.native = (...c) => t(...c), a.create = (c = {}, u = {}) => Q_({
        ...e,
        ...u,
        defaults: {
            ...e.defaults,
            ...u.defaults,
            ...c
        }
    }), a
}
const lc = function() {
        if (typeof globalThis < "u") return globalThis;
        if (typeof self < "u") return self;
        if (typeof window < "u") return window;
        if (typeof global < "u") return global;
        throw new Error("unable to locate global object")
    }(),
    jv = lc.fetch ? (...e) => lc.fetch(...e) : () => Promise.reject(new Error("[ofetch] global.fetch is not supported!")),
    Uv = lc.Headers,
    Wv = lc.AbortController,
    qv = Q_({
        fetch: jv,
        Headers: Uv,
        AbortController: Wv
    }),
    Gv = qv,
    Yv = () => {
        var e;
        return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {}
    },
    uc = Yv().app,
    Xv = () => uc.baseURL,
    Kv = () => uc.buildAssetsDir,
    $h = (...e) => Y_(J_(), Kv(), ...e),
    J_ = (...e) => {
        const t = uc.cdnURL || uc.baseURL;
        return e.length ? Y_(t, ...e) : t
    };
globalThis.__buildAssetsURL = $h, globalThis.__publicAssetsURL = J_;
globalThis.$fetch || (globalThis.$fetch = Gv.create({
    baseURL: Xv()
}));

function Wf(e, t = {}, n) {
    for (const r in e) {
        const i = e[r],
            s = n ? `${n}:${r}` : r;
        typeof i == "object" && i !== null ? Wf(i, t, s) : typeof i == "function" && (t[s] = i)
    }
    return t
}
const Qv = {
        run: e => e()
    },
    Jv = () => Qv,
    Z_ = typeof console.createTask < "u" ? console.createTask : Jv;

function Zv(e, t) {
    const n = t.shift(),
        r = Z_(n);
    return e.reduce((i, s) => i.then(() => r.run(() => s(...t))), Promise.resolve())
}

function eb(e, t) {
    const n = t.shift(),
        r = Z_(n);
    return Promise.all(e.map(i => r.run(() => i(...t))))
}

function of(e, t) {
    for (const n of [...e]) n(t)
}
class tb {
    constructor() {
        this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this)
    }
    hook(t, n, r = {}) {
        if (!t || typeof n != "function") return () => {};
        const i = t;
        let s;
        for (; this._deprecatedHooks[t];) s = this._deprecatedHooks[t], t = s.to;
        if (s && !r.allowDeprecated) {
            let a = s.message;
            a || (a = `${i} hook has been deprecated` + (s.to ? `, please use ${s.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = new Set), this._deprecatedMessages.has(a) || (console.warn(a), this._deprecatedMessages.add(a))
        }
        if (!n.name) try {
            Object.defineProperty(n, "name", {
                get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb",
                configurable: !0
            })
        } catch {}
        return this._hooks[t] = this._hooks[t] || [], this._hooks[t].push(n), () => {
            n && (this.removeHook(t, n), n = void 0)
        }
    }
    hookOnce(t, n) {
        let r, i = (...s) => (typeof r == "function" && r(), r = void 0, i = void 0, n(...s));
        return r = this.hook(t, i), r
    }
    removeHook(t, n) {
        if (this._hooks[t]) {
            const r = this._hooks[t].indexOf(n);
            r !== -1 && this._hooks[t].splice(r, 1), this._hooks[t].length === 0 && delete this._hooks[t]
        }
    }
    deprecateHook(t, n) {
        this._deprecatedHooks[t] = typeof n == "string" ? {
            to: n
        } : n;
        const r = this._hooks[t] || [];
        delete this._hooks[t];
        for (const i of r) this.hook(t, i)
    }
    deprecateHooks(t) {
        Object.assign(this._deprecatedHooks, t);
        for (const n in t) this.deprecateHook(n, t[n])
    }
    addHooks(t) {
        const n = Wf(t),
            r = Object.keys(n).map(i => this.hook(i, n[i]));
        return () => {
            for (const i of r.splice(0, r.length)) i()
        }
    }
    removeHooks(t) {
        const n = Wf(t);
        for (const r in n) this.removeHook(r, n[r])
    }
    removeAllHooks() {
        for (const t in this._hooks) delete this._hooks[t]
    }
    callHook(t, ...n) {
        return n.unshift(t), this.callHookWith(Zv, t, ...n)
    }
    callHookParallel(t, ...n) {
        return n.unshift(t), this.callHookWith(eb, t, ...n)
    }
    callHookWith(t, n, ...r) {
        const i = this._before || this._after ? {
            name: n,
            args: r,
            context: {}
        } : void 0;
        this._before && of(this._before, i);
        const s = t(n in this._hooks ? [...this._hooks[n]] : [], r);
        return s instanceof Promise ? s.finally(() => {
            this._after && i && of(this._after, i)
        }) : (this._after && i && of(this._after, i), s)
    }
    beforeEach(t) {
        return this._before = this._before || [], this._before.push(t), () => {
            if (this._before !== void 0) {
                const n = this._before.indexOf(t);
                n !== -1 && this._before.splice(n, 1)
            }
        }
    }
    afterEach(t) {
        return this._after = this._after || [], this._after.push(t), () => {
            if (this._after !== void 0) {
                const n = this._after.indexOf(t);
                n !== -1 && this._after.splice(n, 1)
            }
        }
    }
}

function e0() {
    return new tb
}

function nb(e = {}) {
    let t, n = !1;
    const r = a => {
        if (t && t !== a) throw new Error("Context conflict")
    };
    let i;
    if (e.asyncContext) {
        const a = e.AsyncLocalStorage || globalThis.AsyncLocalStorage;
        a ? i = new a : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
    }
    const s = () => {
        if (i) {
            const a = i.getStore();
            if (a !== void 0) return a
        }
        return t
    };
    return {
        use: () => {
            const a = s();
            if (a === void 0) throw new Error("Context is not available");
            return a
        },
        tryUse: () => s(),
        set: (a, c) => {
            c || r(a), t = a, n = !0
        },
        unset: () => {
            t = void 0, n = !1
        },
        call: (a, c) => {
            r(a), t = a;
            try {
                return i ? i.run(a, c) : c()
            } finally {
                n || (t = void 0)
            }
        },
        async callAsync(a, c) {
            t = a;
            const u = () => {
                    t = a
                },
                p = () => t === a ? u : void 0;
            qf.add(p);
            try {
                const d = i ? i.run(a, c) : c();
                return n || (t = void 0), await d
            } finally {
                qf.delete(p)
            }
        }
    }
}

function rb(e = {}) {
    const t = {};
    return {
        get(n, r = {}) {
            return t[n] || (t[n] = nb({
                ...e,
                ...r
            })), t[n]
        }
    }
}
const cc = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {},
    Ud = "__unctx__",
    ib = cc[Ud] || (cc[Ud] = rb()),
    sb = (e, t = {}) => ib.get(e, t),
    Wd = "__unctx_async_handlers__",
    qf = cc[Wd] || (cc[Wd] = new Set);

function Va(e) {
    const t = [];
    for (const i of qf) {
        const s = i();
        s && t.push(s)
    }
    const n = () => {
        for (const i of t) i()
    };
    let r = e();
    return r && typeof r == "object" && "catch" in r && (r = r.catch(i => {
        throw n(), i
    })), [r, n]
}
const ob = !1,
    qd = !1,
    ab = !1,
    lb = {
        componentName: "NuxtLink",
        prefetch: !0,
        prefetchOn: {
            visibility: !0
        }
    },
    Ks = {
        value: null,
        errorValue: null,
        deep: !0
    },
    ub = null,
    cb = "#__nuxt",
    t0 = "nuxt-app",
    Gd = 36e5,
    fb = "vite:preloadError";

function n0(e = t0) {
    return sb(e, {
        asyncContext: !1
    })
}
const hb = "__nuxt_plugin";

function db(e) {
    var i;
    let t = 0;
    const n = {
        _id: e.id || t0 || "nuxt-app",
        _scope: go(),
        provide: void 0,
        globalName: "nuxt",
        versions: {
            get nuxt() {
                return "3.17.2"
            },
            get vue() {
                return n.vueApp.version
            }
        },
        payload: Ms({
            ...((i = e.ssrContext) == null ? void 0 : i.payload) || {},
            data: Ms({}),
            state: mi({}),
            once: new Set,
            _errors: Ms({})
        }),
        static: {
            data: {}
        },
        runWithContext(s) {
            return n._scope.active && !Uo() ? n._scope.run(() => Yd(n, s)) : Yd(n, s)
        },
        isHydrating: !0,
        deferHydration() {
            if (!n.isHydrating) return () => {};
            t++;
            let s = !1;
            return () => {
                if (!s && (s = !0, t--, t === 0)) return n.isHydrating = !1, n.callHook("app:suspense:resolve")
            }
        },
        _asyncDataPromises: {},
        _asyncData: Ms({}),
        _payloadRevivers: {},
        ...e
    };
    {
        const s = window.__NUXT__;
        if (s)
            for (const a in s) switch (a) {
                case "data":
                case "state":
                case "_errors":
                    Object.assign(n.payload[a], s[a]);
                    break;
                default:
                    n.payload[a] = s[a]
            }
    }
    n.hooks = e0(), n.hook = n.hooks.hook, n.callHook = n.hooks.callHook, n.provide = (s, a) => {
        const c = "$" + s;
        Tu(n, c, a), Tu(n.vueApp.config.globalProperties, c, a)
    }, Tu(n.vueApp, "$nuxt", n), Tu(n.vueApp.config.globalProperties, "$nuxt", n);
    {
        window.addEventListener(fb, a => {
            n.callHook("app:chunkError", {
                error: a.payload
            }), (n.isHydrating || a.payload.message.includes("Unable to preload CSS")) && a.preventDefault()
        }), window.useNuxtApp || (window.useNuxtApp = vr);
        const s = n.hook("app:error", (...a) => {
            console.error("[nuxt] error caught during app initialization", ...a)
        });
        n.hook("app:mounted", s)
    }
    const r = n.payload.config;
    return n.provide("config", r), n
}

function pb(e, t) {
    t.hooks && e.hooks.addHooks(t.hooks)
}
async function gb(e, t) {
    if (typeof t == "function") {
        const {
            provide: n
        } = await e.runWithContext(() => t(e)) || {};
        if (n && typeof n == "object")
            for (const r in n) e.provide(r, n[r])
    }
}
async function _b(e, t) {
    const n = [],
        r = [],
        i = [],
        s = [];
    let a = 0;
    async function c(u) {
        var d;
        const p = ((d = u.dependsOn) == null ? void 0 : d.filter(g => t.some(m => m._name === g) && !n.includes(g))) ?? [];
        if (p.length > 0) r.push([new Set(p), u]);
        else {
            const g = gb(e, u).then(async () => {
                u._name && (n.push(u._name), await Promise.all(r.map(async ([m, E]) => {
                    m.has(u._name) && (m.delete(u._name), m.size === 0 && (a++, await c(E)))
                })))
            });
            u.parallel ? i.push(g.catch(m => s.push(m))) : await g
        }
    }
    for (const u of t) pb(e, u);
    for (const u of t) await c(u);
    if (await Promise.all(i), a)
        for (let u = 0; u < a; u++) await Promise.all(i);
    if (s.length) throw s[0]
}

function Di(e) {
    if (typeof e == "function") return e;
    const t = e._name || e.name;
    return delete e.name, Object.assign(e.setup || (() => {}), e, {
        [hb]: !0,
        _name: t
    })
}
const mb = Di;

function Yd(e, t, n) {
    const r = () => t();
    return n0(e._id).set(e), e.vueApp.runWithContext(r)
}

function r0(e) {
    var n;
    let t;
    return Ja() && (t = (n = wi()) == null ? void 0 : n.appContext.app.$nuxt), t || (t = n0(e).tryUse()), t || null
}

function vr(e) {
    const t = r0(e);
    if (!t) throw new Error("[nuxt] instance unavailable");
    return t
}

function Bs(e) {
    return vr().$config
}

function Tu(e, t, n) {
    Object.defineProperty(e, t, {
        get: () => n
    })
}

function yb(e, t) {
    return {
        ctx: {
            table: e
        },
        matchAll: n => s0(n, e)
    }
}

function i0(e) {
    const t = {};
    for (const n in e) t[n] = n === "dynamic" ? new Map(Object.entries(e[n]).map(([r, i]) => [r, i0(i)])) : new Map(Object.entries(e[n]));
    return t
}

function vb(e) {
    return yb(i0(e))
}

function s0(e, t, n) {
    e.endsWith("/") && (e = e.slice(0, -1) || "/");
    const r = [];
    for (const [s, a] of Xd(t.wildcard))(e === s || e.startsWith(s + "/")) && r.push(a);
    for (const [s, a] of Xd(t.dynamic))
        if (e.startsWith(s + "/")) {
            const c = "/" + e.slice(s.length).split("/").splice(2).join("/");
            r.push(...s0(c, a))
        } const i = t.static.get(e);
    return i && r.push(i), r.filter(Boolean)
}

function Xd(e) {
    return [...e.entries()].sort((t, n) => t[0].length - n[0].length)
}

function af(e) {
    if (e === null || typeof e != "object") return !1;
    const t = Object.getPrototypeOf(e);
    return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0
}

function Gf(e, t, n = ".", r) {
    if (!af(t)) return Gf(e, {}, n, r);
    const i = Object.assign({}, t);
    for (const s in e) {
        if (s === "__proto__" || s === "constructor") continue;
        const a = e[s];
        a != null && (r && r(i, s, a, n) || (Array.isArray(a) && Array.isArray(i[s]) ? i[s] = [...a, ...i[s]] : af(a) && af(i[s]) ? i[s] = Gf(a, i[s], (n ? `${n}.` : "") + s.toString(), r) : i[s] = a))
    }
    return i
}

function bb(e) {
    return (...t) => t.reduce((n, r) => Gf(n, r, "", e), {})
}
const Oc = bb();

function wb(e, t) {
    try {
        return t in e
    } catch {
        return !1
    }
}
class Yf extends Error {
    constructor(n, r = {}) {
        super(n, r);
        Ct(this, "statusCode", 500);
        Ct(this, "fatal", !1);
        Ct(this, "unhandled", !1);
        Ct(this, "statusMessage");
        Ct(this, "data");
        Ct(this, "cause");
        r.cause && !this.cause && (this.cause = r.cause)
    }
    toJSON() {
        const n = {
            message: this.message,
            statusCode: Xf(this.statusCode, 500)
        };
        return this.statusMessage && (n.statusMessage = o0(this.statusMessage)), this.data !== void 0 && (n.data = this.data), n
    }
}
Ct(Yf, "__h3_error__", !0);

function Db(e) {
    if (typeof e == "string") return new Yf(e);
    if (xb(e)) return e;
    const t = new Yf(e.message ?? e.statusMessage ?? "", {
        cause: e.cause || e
    });
    if (wb(e, "stack")) try {
        Object.defineProperty(t, "stack", {
            get() {
                return e.stack
            }
        })
    } catch {
        try {
            t.stack = e.stack
        } catch {}
    }
    if (e.data && (t.data = e.data), e.statusCode ? t.statusCode = Xf(e.statusCode, t.statusCode) : e.status && (t.statusCode = Xf(e.status, t.statusCode)), e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText), t.statusMessage) {
        const n = t.statusMessage;
        o0(t.statusMessage) !== n && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
    }
    return e.fatal !== void 0 && (t.fatal = e.fatal), e.unhandled !== void 0 && (t.unhandled = e.unhandled), t
}

function xb(e) {
    var t;
    return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0
}
const Eb = /[^\u0009\u0020-\u007E]/g;

function o0(e = "") {
    return e.replace(Eb, "")
}

function Xf(e, t = 200) {
    return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)), e < 100 || e > 999) ? t : e
}
const a0 = Symbol("layout-meta"),
    su = Symbol("route"),
    Qi = () => {
        var e;
        return (e = vr()) == null ? void 0 : e.$router
    },
    Mc = () => Ja() ? Er(su, vr()._route) : vr()._route;
const Cb = () => {
        try {
            if (vr()._processingMiddleware) return !0
        } catch {
            return !1
        }
        return !1
    },
    Sb = (e, t) => {
        e || (e = "/");
        const n = typeof e == "string" ? e : "path" in e ? Kf(e) : Qi().resolve(e).href;
        if (t != null && t.open) {
            const {
                target: u = "_blank",
                windowFeatures: p = {}
            } = t.open, d = Object.entries(p).filter(([g, m]) => m !== void 0).map(([g, m]) => `${g.toLowerCase()}=${m}`).join(", ");
            return open(n, u, d), Promise.resolve()
        }
        const r = Qs(n, {
                acceptRelative: !0
            }),
            i = (t == null ? void 0 : t.external) || r;
        if (i) {
            if (!(t != null && t.external)) throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
            const {
                protocol: u
            } = new URL(n, window.location.href);
            if (u && Ev(u)) throw new Error(`Cannot navigate to a URL with '${u}' protocol.`)
        }
        const s = Cb();
        if (!i && s) {
            if (t != null && t.replace) {
                if (typeof e == "string") {
                    const {
                        pathname: u,
                        search: p,
                        hash: d
                    } = K_(e);
                    return {
                        path: u,
                        ...p && {
                            query: Bh(p)
                        },
                        ...d && {
                            hash: d
                        },
                        replace: !0
                    }
                }
                return {
                    ...e,
                    replace: !0
                }
            }
            return e
        }
        const a = Qi(),
            c = vr();
        return i ? (c._scope.stop(), t != null && t.replace ? location.replace(n) : location.href = n, s ? c.isHydrating ? new Promise(() => {}) : !1 : Promise.resolve()) : t != null && t.replace ? a.replace(e) : a.push(e)
    };

function Kf(e) {
    return Yl(e.path || "", e.query || {}) + (e.hash || "")
}
const l0 = "__nuxt_error",
    Lc = () => Na(vr().payload, "error"),
    ua = e => {
        const t = Bo(e);
        try {
            const n = vr(),
                r = Lc();
            n.hooks.callHook("app:error", t), r.value || (r.value = t)
        } catch {
            throw t
        }
        return t
    },
    Tb = async (e = {}) => {
        const t = vr(),
            n = Lc();
        t.callHook("app:error:cleared", e), e.redirect && await Qi().replace(e.redirect), n.value = ub
    }, u0 = e => !!e && typeof e == "object" && l0 in e, Bo = e => {
        const t = Db(e);
        return Object.defineProperty(t, l0, {
            value: !0,
            configurable: !1,
            writable: !1
        }), t
    }, Pb = {
        trailing: !0
    };

function kb(e, t = 25, n = {}) {
    if (n = {
            ...Pb,
            ...n
        }, !Number.isFinite(t)) throw new TypeError("Expected `wait` to be a finite number");
    let r, i, s = [],
        a, c;
    const u = (p, d) => (a = Ab(e, p, d), a.finally(() => {
        if (a = null, n.trailing && c && !i) {
            const g = u(p, c);
            return c = null, g
        }
    }), a);
    return function(...p) {
        return a ? (n.trailing && (c = p), a) : new Promise(d => {
            const g = !i && n.leading;
            clearTimeout(i), i = setTimeout(() => {
                i = null;
                const m = n.leading ? r : u(this, p);
                for (const E of s) E(m);
                s = []
            }, t), g ? (r = u(this, p), d(r)) : s.push(d)
        })
    }
}
async function Ab(e, t, n) {
    return await e.apply(t, n)
}
/*!
 * pinia v3.0.2
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let c0;
const ou = e => c0 = e,
    f0 = Symbol();

function Qf(e) {
    return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function"
}
var Fl;
(function(e) {
    e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function"
})(Fl || (Fl = {}));

function Rb() {
    const e = go(!0),
        t = e.run(() => kn({}));
    let n = [],
        r = [];
    const i = Dh({
        install(s) {
            ou(i), i._a = s, s.provide(f0, i), s.config.globalProperties.$pinia = i, r.forEach(a => n.push(a)), r = []
        },
        use(s) {
            return this._a ? n.push(s) : r.push(s), this
        },
        _p: n,
        _a: null,
        _e: e,
        _s: new Map,
        state: t
    });
    return i
}
const h0 = () => {};

function Kd(e, t, n, r = h0) {
    e.push(t);
    const i = () => {
        const s = e.indexOf(t);
        s > -1 && (e.splice(s, 1), r())
    };
    return !n && Uo() && fs(i), i
}

function Ta(e, ...t) {
    e.slice().forEach(n => {
        n(...t)
    })
}
const Ob = e => e(),
    Qd = Symbol(),
    lf = Symbol();

function Jf(e, t) {
    e instanceof Map && t instanceof Map ? t.forEach((n, r) => e.set(r, n)) : e instanceof Set && t instanceof Set && t.forEach(e.add, e);
    for (const n in t) {
        if (!t.hasOwnProperty(n)) continue;
        const r = t[n],
            i = e[n];
        Qf(i) && Qf(r) && e.hasOwnProperty(n) && !mr(r) && !mo(r) ? e[n] = Jf(i, r) : e[n] = r
    }
    return e
}
const Mb = Symbol();

function Lb(e) {
    return !Qf(e) || !Object.prototype.hasOwnProperty.call(e, Mb)
}
const {
    assign: ko
} = Object;

function Fb(e) {
    return !!(mr(e) && e.effect)
}

function Ib(e, t, n, r) {
    const {
        state: i,
        actions: s,
        getters: a
    } = t, c = n.state.value[e];
    let u;

    function p() {
        c || (n.state.value[e] = i ? i() : {});
        const d = Xm(n.state.value[e]);
        return ko(d, s, Object.keys(a || {}).reduce((g, m) => (g[m] = Dh(xn(() => {
            ou(n);
            const E = n._s.get(e);
            return a[m].call(E, E)
        })), g), {}))
    }
    return u = d0(e, p, t, n, r, !0), u
}

function d0(e, t, n = {}, r, i, s) {
    let a;
    const c = ko({
            actions: {}
        }, n),
        u = {
            deep: !0
        };
    let p, d, g = [],
        m = [],
        E;
    const L = r.state.value[e];
    !s && !L && (r.state.value[e] = {}), kn({});
    let b;

    function j(xe) {
        let he;
        p = d = !1, typeof xe == "function" ? (xe(r.state.value[e]), he = {
            type: Fl.patchFunction,
            storeId: e,
            events: E
        }) : (Jf(r.state.value[e], xe), he = {
            type: Fl.patchObject,
            payload: xe,
            storeId: e,
            events: E
        });
        const me = b = Symbol();
        ss().then(() => {
            b === me && (p = !0)
        }), d = !0, Ta(g, he, r.state.value[e])
    }
    const A = s ? function() {
        const {
            state: he
        } = n, me = he ? he() : {};
        this.$patch(Q => {
            ko(Q, me)
        })
    } : h0;

    function $() {
        a.stop(), g = [], m = [], r._s.delete(e)
    }
    const w = (xe, he = "") => {
            if (Qd in xe) return xe[lf] = he, xe;
            const me = function() {
                ou(r);
                const Q = Array.from(arguments),
                    ne = [],
                    re = [];

                function K(ce) {
                    ne.push(ce)
                }

                function te(ce) {
                    re.push(ce)
                }
                Ta(m, {
                    args: Q,
                    name: me[lf],
                    store: S,
                    after: K,
                    onError: te
                });
                let G;
                try {
                    G = xe.apply(this && this.$id === e ? this : S, Q)
                } catch (ce) {
                    throw Ta(re, ce), ce
                }
                return G instanceof Promise ? G.then(ce => (Ta(ne, ce), ce)).catch(ce => (Ta(re, ce), Promise.reject(ce))) : (Ta(ne, G), G)
            };
            return me[Qd] = !0, me[lf] = he, me
        },
        k = {
            _p: r,
            $id: e,
            $onAction: Kd.bind(null, m),
            $patch: j,
            $reset: A,
            $subscribe(xe, he = {}) {
                const me = Kd(g, xe, he.detached, () => Q()),
                    Q = a.run(() => Qr(() => r.state.value[e], ne => {
                        (he.flush === "sync" ? d : p) && xe({
                            storeId: e,
                            type: Fl.direct,
                            events: E
                        }, ne)
                    }, ko({}, u, he)));
                return me
            },
            $dispose: $
        },
        S = mi(k);
    r._s.set(e, S);
    const J = (r._a && r._a.runWithContext || Ob)(() => r._e.run(() => (a = go()).run(() => t({
        action: w
    }))));
    for (const xe in J) {
        const he = J[xe];
        if (mr(he) && !Fb(he) || mo(he)) s || (L && Lb(he) && (mr(he) ? he.value = L[xe] : Jf(he, L[xe])), r.state.value[e][xe] = he);
        else if (typeof he == "function") {
            const me = w(he, xe);
            J[xe] = me, c.actions[xe] = he
        }
    }
    return ko(S, J), ko(Bn(S), J), Object.defineProperty(S, "$state", {
        get: () => r.state.value[e],
        set: xe => {
            j(he => {
                ko(he, xe)
            })
        }
    }), r._p.forEach(xe => {
        ko(S, a.run(() => xe({
            store: S,
            app: r._a,
            pinia: r,
            options: c
        })))
    }), L && s && n.hydrate && n.hydrate(S.$state, L), p = !0, d = !0, S
} /*! #__NO_SIDE_EFFECTS__ */
function Nb(e, t, n) {
    let r;
    const i = typeof t == "function";
    r = i ? n : t;

    function s(a, c) {
        const u = Ja();
        return a = a || (u ? Er(f0, null) : null), a && ou(a), a = c0, a._s.has(e) || (i ? d0(e, t, r, a) : Ib(e, r, a)), a._s.get(e)
    }
    return s.$id = e, s
}

function Jd(e) {
    const t = $b(e),
        n = new ArrayBuffer(t.length),
        r = new DataView(n);
    for (let i = 0; i < n.byteLength; i++) r.setUint8(i, t.charCodeAt(i));
    return n
}
const Bb = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

function $b(e) {
    e.length % 4 === 0 && (e = e.replace(/==?$/, ""));
    let t = "",
        n = 0,
        r = 0;
    for (let i = 0; i < e.length; i++) n <<= 6, n |= Bb.indexOf(e[i]), r += 6, r === 24 && (t += String.fromCharCode((n & 16711680) >> 16), t += String.fromCharCode((n & 65280) >> 8), t += String.fromCharCode(n & 255), n = r = 0);
    return r === 12 ? (n >>= 4, t += String.fromCharCode(n)) : r === 18 && (n >>= 2, t += String.fromCharCode((n & 65280) >> 8), t += String.fromCharCode(n & 255)), t
}
const Hb = -1,
    Vb = -2,
    zb = -3,
    jb = -4,
    Ub = -5,
    Wb = -6;

function qb(e, t) {
    return Gb(JSON.parse(e), t)
}

function Gb(e, t) {
    if (typeof e == "number") return i(e, !0);
    if (!Array.isArray(e) || e.length === 0) throw new Error("Invalid input");
    const n = e,
        r = Array(n.length);

    function i(s, a = !1) {
        if (s === Hb) return;
        if (s === zb) return NaN;
        if (s === jb) return 1 / 0;
        if (s === Ub) return -1 / 0;
        if (s === Wb) return -0;
        if (a) throw new Error("Invalid input");
        if (s in r) return r[s];
        const c = n[s];
        if (!c || typeof c != "object") r[s] = c;
        else if (Array.isArray(c))
            if (typeof c[0] == "string") {
                const u = c[0],
                    p = t == null ? void 0 : t[u];
                if (p) return r[s] = p(i(c[1]));
                switch (u) {
                    case "Date":
                        r[s] = new Date(c[1]);
                        break;
                    case "Set":
                        const d = new Set;
                        r[s] = d;
                        for (let E = 1; E < c.length; E += 1) d.add(i(c[E]));
                        break;
                    case "Map":
                        const g = new Map;
                        r[s] = g;
                        for (let E = 1; E < c.length; E += 2) g.set(i(c[E]), i(c[E + 1]));
                        break;
                    case "RegExp":
                        r[s] = new RegExp(c[1], c[2]);
                        break;
                    case "Object":
                        r[s] = Object(c[1]);
                        break;
                    case "BigInt":
                        r[s] = BigInt(c[1]);
                        break;
                    case "null":
                        const m = Object.create(null);
                        r[s] = m;
                        for (let E = 1; E < c.length; E += 2) m[c[E]] = i(c[E + 1]);
                        break;
                    case "Int8Array":
                    case "Uint8Array":
                    case "Uint8ClampedArray":
                    case "Int16Array":
                    case "Uint16Array":
                    case "Int32Array":
                    case "Uint32Array":
                    case "Float32Array":
                    case "Float64Array":
                    case "BigInt64Array":
                    case "BigUint64Array": {
                        const E = globalThis[u],
                            L = c[1],
                            b = Jd(L),
                            j = new E(b);
                        r[s] = j;
                        break
                    }
                    case "ArrayBuffer": {
                        const E = c[1],
                            L = Jd(E);
                        r[s] = L;
                        break
                    }
                    default:
                        throw new Error(`Unknown type ${u}`)
                }
            } else {
                const u = new Array(c.length);
                r[s] = u;
                for (let p = 0; p < c.length; p += 1) {
                    const d = c[p];
                    d !== Vb && (u[p] = i(d))
                }
            }
        else {
            const u = {};
            r[s] = u;
            for (const p in c) {
                const d = c[p];
                u[p] = i(d)
            }
        }
        return r[s]
    }
    return i(0)
}
const Yb = new Set(["link", "style", "script", "noscript"]),
    Xb = new Set(["title", "titleTemplate", "script", "style", "noscript"]),
    Zd = new Set(["base", "meta", "link", "style", "script", "noscript"]),
    Kb = new Set(["title", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"]),
    Qb = new Set(["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"]),
    Jb = new Set(["key", "tagPosition", "tagPriority", "tagDuplicateStrategy", "innerHTML", "textContent", "processTemplateParams"]),
    Zb = new Set(["templateParams", "htmlAttrs", "bodyAttrs"]),
    Hh = new Set(["theme-color", "google-site-verification", "og", "article", "book", "profile", "twitter", "author"]),
    Xl = {
        META: new Set(["twitter"]),
        OG: new Set(["og", "book", "article", "profile", "fb"]),
        MEDIA: new Set(["ogImage", "ogVideo", "ogAudio", "twitterImage"]),
        HTTP_EQUIV: new Set(["contentType", "defaultStyle", "xUaCompatible"])
    },
    ew = {
        articleExpirationTime: "article:expiration_time",
        articleModifiedTime: "article:modified_time",
        articlePublishedTime: "article:published_time",
        bookReleaseDate: "book:release_date",
        fbAppId: "fb:app_id",
        ogAudioSecureUrl: "og:audio:secure_url",
        ogAudioUrl: "og:audio",
        ogImageSecureUrl: "og:image:secure_url",
        ogImageUrl: "og:image",
        ogSiteName: "og:site_name",
        ogVideoSecureUrl: "og:video:secure_url",
        ogVideoUrl: "og:video",
        profileFirstName: "profile:first_name",
        profileLastName: "profile:last_name",
        profileUsername: "profile:username",
        msapplicationConfig: "msapplication-Config",
        msapplicationTileColor: "msapplication-TileColor",
        msapplicationTileImage: "msapplication-TileImage"
    },
    p0 = {
        appleItunesApp: {
            unpack: {
                entrySeparator: ", ",
                resolve: ({
                    key: e,
                    value: t
                }) => `${_o(e)}=${t}`
            }
        },
        refresh: {
            metaKey: "http-equiv",
            unpack: {
                entrySeparator: ";",
                resolve: ({
                    key: e,
                    value: t
                }) => e === "seconds" ? `${t}` : void 0
            }
        },
        robots: {
            unpack: {
                entrySeparator: ", ",
                resolve: ({
                    key: e,
                    value: t
                }) => typeof t == "boolean" ? _o(e) : `${_o(e)}:${t}`
            }
        },
        contentSecurityPolicy: {
            metaKey: "http-equiv",
            unpack: {
                entrySeparator: "; ",
                resolve: ({
                    key: e,
                    value: t
                }) => `${_o(e)} ${t}`
            }
        },
        charset: {}
    };

function _o(e) {
    const t = e.replace(/([A-Z])/g, "-$1").toLowerCase(),
        n = t.indexOf("-");
    return n === -1 ? t : Xl.META.has(t.slice(0, n)) || Xl.OG.has(t.slice(0, n)) ? e.replace(/([A-Z])/g, ":$1").toLowerCase() : t
}

function g0(e) {
    return Object.fromEntries(Object.entries(e).filter(([t, n]) => String(n) !== "false" && t))
}

function Zf(e) {
    return Array.isArray(e) ? e.map(Zf) : !e || typeof e != "object" ? e : Object.fromEntries(Object.entries(e).map(([t, n]) => [_o(t), Zf(n)]))
}

function _0(e, t = {}) {
    const {
        entrySeparator: n = "",
        keyValueSeparator: r = "",
        wrapValue: i,
        resolve: s
    } = t;
    return Object.entries(e).map(([a, c]) => {
        if (s) {
            const p = s({
                key: a,
                value: c
            });
            if (p !== void 0) return p
        }
        const u = typeof c == "object" ? _0(c, t) : typeof c == "number" ? c.toString() : typeof c == "string" && i ? `${i}${c.replace(new RegExp(i,"g"),`\\${i}`)}${i}` : c;
        return `${a}${r}${u}`
    }).join(n)
}

function ep(e, t) {
    const n = g0(t),
        r = _o(e),
        i = m0(r);
    if (!Hh.has(r)) return [{
        [i]: r,
        ...n
    }];
    const s = Object.fromEntries(Object.entries(n).map(([a, c]) => [`${e}${a==="url"?"":`${a[0].toUpperCase()}${a.slice(1)}`}`, c]));
    return fc(s || {}).sort((a, c) => {
        var u, p;
        return (((u = a[i]) == null ? void 0 : u.length) || 0) - (((p = c[i]) == null ? void 0 : p.length) || 0)
    })
}

function m0(e) {
    var r;
    if (((r = p0[e]) == null ? void 0 : r.metaKey) === "http-equiv" || Xl.HTTP_EQUIV.has(e)) return "http-equiv";
    const t = _o(e),
        n = t.indexOf(":");
    return n === -1 ? "name" : Xl.OG.has(t.slice(0, n)) ? "property" : "name"
}

function tw(e) {
    return ew[e] || _o(e)
}

function nw(e, t) {
    var n;
    return t === "refresh" ? `${e.seconds};url=${e.url}` : _0(Zf(e), {
        keyValueSeparator: "=",
        entrySeparator: ", ",
        resolve: ({
            value: r,
            key: i
        }) => r === null ? "" : typeof r == "boolean" ? i : void 0,
        ...(n = p0[t]) == null ? void 0 : n.unpack
    })
}

function fc(e) {
    const t = [],
        n = {};
    for (const [i, s] of Object.entries(e)) {
        if (Array.isArray(s)) {
            if (i === "themeColor") {
                s.forEach(a => {
                    typeof a == "object" && a !== null && t.push({
                        name: "theme-color",
                        ...a
                    })
                });
                continue
            }
            for (const a of s)
                if (typeof a == "object" && a !== null) {
                    const c = [],
                        u = [];
                    for (const [p, d] of Object.entries(a)) {
                        const g = `${i}${p==="url"?"":`:${p}`}`,
                            m = fc({
                                [g]: d
                            });
                        (p === "url" ? c : u).push(...m)
                    }
                    t.push(...c, ...u)
                } else t.push(...typeof a == "string" ? fc({
                    [i]: a
                }) : ep(i, a));
            continue
        }
        if (typeof s == "object" && s)
            if (Xl.MEDIA.has(i)) {
                const a = i.startsWith("twitter") ? "twitter" : "og",
                    c = i.replace(/^(og|twitter)/, "").toLowerCase(),
                    u = a === "twitter" ? "name" : "property";
                s.url && t.push({
                    [u]: `${a}:${c}`,
                    content: s.url
                }), s.secureUrl && t.push({
                    [u]: `${a}:${c}:secure_url`,
                    content: s.secureUrl
                });
                for (const [p, d] of Object.entries(s)) p !== "url" && p !== "secureUrl" && t.push({
                    [u]: `${a}:${c}:${p}`,
                    content: d
                })
            } else Hh.has(_o(i)) ? t.push(...ep(i, s)) : n[i] = g0(s);
        else n[i] = s
    }
    const r = Object.entries(n).map(([i, s]) => {
        if (i === "charset") return {
            charset: s === null ? "_null" : s
        };
        const a = m0(i),
            c = tw(i),
            u = s === null ? "_null" : typeof s == "object" ? nw(s, i) : typeof s == "number" ? s.toString() : s;
        return a === "http-equiv" ? {
            "http-equiv": c,
            content: u
        } : {
            [a]: c,
            content: u
        }
    });
    return [...t, ...r].map(i => "content" in i && i.content === "_null" ? {
        ...i,
        content: null
    } : i)
}
const rw = {
        key: "flatMeta",
        hooks: {
            "entries:normalize": e => {
                const t = [];
                e.tags = e.tags.map(n => n.tag !== "_flatMeta" ? n : (t.push(fc(n.props).map(r => ({
                    ...n,
                    tag: "meta",
                    props: r
                }))), !1)).filter(Boolean).concat(...t)
            }
        }
    },
    iw = ["name", "property", "http-equiv"];

function y0(e) {
    const t = e.split(":")[1];
    return Hh.has(t)
}

function eh(e) {
    const {
        props: t,
        tag: n
    } = e;
    if (Qb.has(n)) return n;
    if (n === "link" && t.rel === "canonical") return "canonical";
    if (t.charset) return "charset";
    if (e.tag === "meta") {
        for (const r of iw)
            if (t[r] !== void 0) return `${n}:${t[r]}`
    }
    if (e.key) return `${n}:key:${e.key}`;
    if (t.id) return `${n}:id:${t.id}`;
    if (Xb.has(n)) {
        const r = e.textContent || e.innerHTML;
        if (r) return `${n}:content:${r}`
    }
}

function tp(e) {
    const t = e._h || e._d;
    if (t) return t;
    const n = e.textContent || e.innerHTML;
    return n || `${e.tag}:${Object.entries(e.props).map(([r,i])=>`${r}:${String(i)}`).join(",")}`
}

function hc(e, t, n) {
    typeof e === "function" && (!n || n !== "titleTemplate" && !(n[0] === "o" && n[1] === "n")) && (e = e());
    let i;
    if (t && (i = t(n, e)), Array.isArray(i)) return i.map(s => hc(s, t));
    if ((i == null ? void 0 : i.constructor) === Object) {
        const s = {};
        for (const a of Object.keys(i)) s[a] = hc(i[a], t, a);
        return s
    }
    return i
}

function sw(e, t) {
    const n = e === "style" ? new Map : new Set;

    function r(i) {
        const s = i.trim();
        if (s)
            if (e === "style") {
                const [a, ...c] = s.split(":").map(u => u.trim());
                a && c.length && n.set(a, c.join(":"))
            } else s.split(" ").filter(Boolean).forEach(a => n.add(a))
    }
    return typeof t == "string" ? e === "style" ? t.split(";").forEach(r) : r(t) : Array.isArray(t) ? t.forEach(i => r(i)) : t && typeof t == "object" && Object.entries(t).forEach(([i, s]) => {
        s && s !== "false" && (e === "style" ? n.set(i.trim(), s) : r(i))
    }), n
}

function v0(e, t) {
    return e.props = e.props || {}, t && Object.entries(t).forEach(([n, r]) => {
        if (r === null) {
            e.props[n] = null;
            return
        }
        if (n === "class" || n === "style") {
            e.props[n] = sw(n, r);
            return
        }
        if (Jb.has(n)) {
            if (["textContent", "innerHTML"].includes(n) && typeof r == "object") {
                let a = t.type;
                if (t.type || (a = "application/json"), !(a != null && a.endsWith("json")) && a !== "speculationrules") return;
                t.type = a, e.props.type = a, e[n] = JSON.stringify(r)
            } else e[n] = r;
            return
        }
        const i = String(r),
            s = n.startsWith("data-");
        i === "true" || i === "" ? e.props[n] = s ? i : !0 : !r && s && i === "false" ? e.props[n] = "false" : r !== void 0 && (e.props[n] = r)
    }), e
}

function ow(e, t) {
    const n = typeof t == "object" && typeof t != "function" ? t : {
            [e === "script" || e === "noscript" || e === "style" ? "innerHTML" : "textContent"]: t
        },
        r = v0({
            tag: e,
            props: {}
        }, n);
    return r.key && Yb.has(r.tag) && (r.props["data-hid"] = r._h = r.key), r.tag === "script" && typeof r.innerHTML == "object" && (r.innerHTML = JSON.stringify(r.innerHTML), r.props.type = r.props.type || "application/json"), Array.isArray(r.props.content) ? r.props.content.map(i => ({
        ...r,
        props: {
            ...r.props,
            content: i
        }
    })) : r
}

function aw(e, t) {
    if (!e) return [];
    typeof e == "function" && (e = e());
    const n = (i, s) => {
        for (let a = 0; a < t.length; a++) s = t[a](i, s);
        return s
    };
    e = n(void 0, e);
    const r = [];
    return e = hc(e, n), Object.entries(e || {}).forEach(([i, s]) => {
        if (s !== void 0)
            for (const a of Array.isArray(s) ? s : [s]) r.push(ow(i, a))
    }), r.flat()
}
const np = (e, t) => e._w === t._w ? e._p - t._p : e._w - t._w,
    rp = {
        base: -10,
        title: 10
    },
    lw = {
        critical: -8,
        high: -1,
        low: 2
    },
    ip = {
        meta: {
            "content-security-policy": -30,
            charset: -20,
            viewport: -15
        },
        link: {
            preconnect: 20,
            stylesheet: 60,
            preload: 70,
            modulepreload: 70,
            prefetch: 90,
            "dns-prefetch": 90,
            prerender: 90
        },
        script: {
            async: 30,
            defer: 80,
            sync: 50
        },
        style: {
            imported: 40,
            sync: 60
        }
    },
    uw = /@import/,
    hl = e => e === "" || e === !0;

function cw(e, t) {
    var s;
    if (typeof t.tagPriority == "number") return t.tagPriority;
    let n = 100;
    const r = lw[t.tagPriority] || 0,
        i = e.resolvedOptions.disableCapoSorting ? {
            link: {},
            script: {},
            style: {}
        } : ip;
    if (t.tag in rp) n = rp[t.tag];
    else if (t.tag === "meta") {
        const a = t.props["http-equiv"] === "content-security-policy" ? "content-security-policy" : t.props.charset ? "charset" : t.props.name === "viewport" ? "viewport" : null;
        a && (n = ip.meta[a])
    } else t.tag === "link" && t.props.rel ? n = i.link[t.props.rel] : t.tag === "script" ? hl(t.props.async) ? n = i.script.async : t.props.src && !hl(t.props.defer) && !hl(t.props.async) && t.props.type !== "module" && !((s = t.props.type) != null && s.endsWith("json")) ? n = i.script.sync : hl(t.props.defer) && t.props.src && !hl(t.props.async) && (n = i.script.defer) : t.tag === "style" && (n = t.innerHTML && uw.test(t.innerHTML) ? i.style.imported : i.style.sync);
    return (n || 100) + r
}

function sp(e, t) {
    const n = typeof t == "function" ? t(e) : t,
        r = n.key || String(e.plugins.size + 1);
    e.plugins.get(r) || (e.plugins.set(r, n), e.hooks.addHooks(n.hooks || {}))
}

function fw(e = {}) {
    var c;
    const t = e0();
    t.addHooks(e.hooks || {});
    const n = !e.document,
        r = new Map,
        i = new Map,
        s = [],
        a = {
            _entryCount: 1,
            plugins: i,
            dirty: !1,
            resolvedOptions: e,
            hooks: t,
            ssr: n,
            entries: r,
            headEntries() {
                return [...r.values()]
            },
            use: u => sp(a, u),
            push(u, p) {
                const d = {
                    ...p || {}
                };
                delete d.head;
                const g = d._index ?? a._entryCount++,
                    m = {
                        _i: g,
                        input: u,
                        options: d
                    },
                    E = {
                        _poll(L = !1) {
                            a.dirty = !0, !L && s.push(g), t.callHook("entries:updated", a)
                        },
                        dispose() {
                            r.delete(g) && E._poll(!0)
                        },
                        patch(L) {
                            (!d.mode || d.mode === "server" && n || d.mode === "client" && !n) && (m.input = L, r.set(g, m), E._poll())
                        }
                    };
                return E.patch(u), E
            },
            async resolveTags() {
                var E;
                const u = {
                    tagMap: new Map,
                    tags: [],
                    entries: [...a.entries.values()]
                };
                for (await t.callHook("entries:resolve", u); s.length;) {
                    const L = s.shift(),
                        b = r.get(L);
                    if (b) {
                        const j = {
                            tags: aw(b.input, e.propResolvers || []).map(A => Object.assign(A, b.options)),
                            entry: b
                        };
                        await t.callHook("entries:normalize", j), b._tags = j.tags.map((A, $) => (A._w = cw(a, A), A._p = (b._i << 10) + $, A._d = eh(A), A))
                    }
                }
                let p = !1;
                u.entries.flatMap(L => (L._tags || []).map(b => ({
                    ...b,
                    props: {
                        ...b.props
                    }
                }))).sort(np).reduce((L, b) => {
                    const j = String(b._d || b._p);
                    if (!L.has(j)) return L.set(j, b);
                    const A = L.get(j);
                    if (((b == null ? void 0 : b.tagDuplicateStrategy) || (Zb.has(b.tag) ? "merge" : null) || (b.key && b.key === A.key ? "merge" : null)) === "merge") {
                        const w = {
                            ...A.props
                        };
                        Object.entries(b.props).forEach(([k, S]) => w[k] = k === "style" ? new Map([...A.props.style || new Map, ...S]) : k === "class" ? new Set([...A.props.class || new Set, ...S]) : S), L.set(j, {
                            ...b,
                            props: w
                        })
                    } else b._p >> 10 === A._p >> 10 && y0(b._d) ? (L.set(j, Object.assign([...Array.isArray(A) ? A : [A], b], b)), p = !0) : (b._w === A._w ? b._p > A._p : (b == null ? void 0 : b._w) < (A == null ? void 0 : A._w)) && L.set(j, b);
                    return L
                }, u.tagMap);
                const d = u.tagMap.get("title"),
                    g = u.tagMap.get("titleTemplate");
                if (a._title = d == null ? void 0 : d.textContent, g) {
                    const L = g == null ? void 0 : g.textContent;
                    if (a._titleTemplate = L, L) {
                        let b = typeof L == "function" ? L(d == null ? void 0 : d.textContent) : L;
                        typeof b == "string" && !a.plugins.has("template-params") && (b = b.replace("%s", (d == null ? void 0 : d.textContent) || "")), d ? b === null ? u.tagMap.delete("title") : u.tagMap.set("title", {
                            ...d,
                            textContent: b
                        }) : (g.tag = "title", g.textContent = b)
                    }
                }
                u.tags = Array.from(u.tagMap.values()), p && (u.tags = u.tags.flat().sort(np)), await t.callHook("tags:beforeResolve", u), await t.callHook("tags:resolve", u), await t.callHook("tags:afterResolve", u);
                const m = [];
                for (const L of u.tags) {
                    const {
                        innerHTML: b,
                        tag: j,
                        props: A
                    } = L;
                    if (Kb.has(j) && !(Object.keys(A).length === 0 && !L.innerHTML && !L.textContent) && !(j === "meta" && !A.content && !A["http-equiv"] && !A.charset)) {
                        if (j === "script" && b) {
                            if ((E = A.type) != null && E.endsWith("json")) {
                                const $ = typeof b == "string" ? b : JSON.stringify(b);
                                L.innerHTML = $.replace(/</g, "\\u003C")
                            } else typeof b == "string" && (L.innerHTML = b.replace(new RegExp(`</${j}`, "g"), `<\\/${j}`));
                            L._d = eh(L)
                        }
                        m.push(L)
                    }
                }
                return m
            }
        };
    return ((e == null ? void 0 : e.plugins) || []).forEach(u => sp(a, u)), a.hooks.callHook("init", a), (c = e.init) == null || c.forEach(u => u && a.push(u)), a
}
const hw = (e, t) => mr(t) ? pa(t) : t,
    Vh = "usehead";

function dw(e) {
    return {
        install(n) {
            n.config.globalProperties.$unhead = e, n.config.globalProperties.$head = e, n.provide(Vh, e)
        }
    }.install
}

function b0() {
    if (Ja()) {
        const e = Er(Vh);
        if (!e) throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.");
        return e
    }
    throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.")
}

function w0(e, t = {}) {
    const n = t.head || b0();
    return n.ssr ? n.push(e || {}, t) : pw(n, e, t)
}

function pw(e, t, n = {}) {
    const r = kn(!1);
    let i;
    return Ol(() => {
        const a = r.value ? {} : hc(t, hw);
        i ? i.patch(a) : i = e.push(a, n)
    }), wi() && (va(() => {
        i.dispose()
    }), jg(() => {
        r.value = !0
    }), zg(() => {
        r.value = !1
    })), i
}

function gw(e = {}, t = {}) {
    (t.head || b0()).use(rw);
    const {
        title: r,
        titleTemplate: i,
        ...s
    } = e;
    return w0({
        title: r,
        titleTemplate: i,
        _flatMeta: s
    }, t)
}

function zh(e) {
    var n;
    const t = e || r0();
    return ((n = t == null ? void 0 : t.ssrContext) == null ? void 0 : n.head) || (t == null ? void 0 : t.runWithContext(() => {
        if (Ja()) return Er(Vh)
    }))
}

function D0(e, t = {}) {
    const n = zh(t.nuxt);
    if (n) return w0(e, {
        head: n,
        ...t
    })
}

function mP(e, t = {}) {
    const n = zh(t.nuxt);
    if (n) return gw(e, {
        head: n,
        ...t
    })
}
const _w = "modulepreload",
    mw = function(e, t) {
        return new URL(e, t).href
    },
    op = {},
    Ht = function(t, n, r) {
        let i = Promise.resolve();
        if (n && n.length > 0) {
            let a = function(d) {
                return Promise.all(d.map(g => Promise.resolve(g).then(m => ({
                    status: "fulfilled",
                    value: m
                }), m => ({
                    status: "rejected",
                    reason: m
                }))))
            };
            const c = document.getElementsByTagName("link"),
                u = document.querySelector("meta[property=csp-nonce]"),
                p = (u == null ? void 0 : u.nonce) || (u == null ? void 0 : u.getAttribute("nonce"));
            i = a(n.map(d => {
                if (d = mw(d, r), d in op) return;
                op[d] = !0;
                const g = d.endsWith(".css"),
                    m = g ? '[rel="stylesheet"]' : "";
                if (!!r)
                    for (let b = c.length - 1; b >= 0; b--) {
                        const j = c[b];
                        if (j.href === d && (!g || j.rel === "stylesheet")) return
                    } else if (document.querySelector(`link[href="${d}"]${m}`)) return;
                const L = document.createElement("link");
                if (L.rel = g ? "stylesheet" : _w, g || (L.as = "script"), L.crossOrigin = "", L.href = d, p && L.setAttribute("nonce", p), document.head.appendChild(L), g) return new Promise((b, j) => {
                    L.addEventListener("load", b), L.addEventListener("error", () => j(new Error(`Unable to preload CSS for ${d}`)))
                })
            }))
        }

        function s(a) {
            const c = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (c.payload = a, window.dispatchEvent(c), !c.defaultPrevented) throw a
        }
        return i.then(a => {
            for (const c of a || []) c.status === "rejected" && s(c.reason);
            return t().catch(s)
        })
    };
let Hu, Vu;

function yw() {
    return Hu = $fetch($h(`builds/meta/${Bs().app.buildId}.json`), {
        responseType: "json"
    }), Hu.then(e => {
        Vu = vb(e.matcher)
    }).catch(e => {
        console.error("[nuxt] Error fetching app manifest.", e)
    }), Hu
}

function Fc() {
    return Hu || yw()
}
async function jh(e) {
    const t = typeof e == "string" ? e : e.path;
    if (await Fc(), !Vu) return console.error("[nuxt] Error creating app manifest matcher.", Vu), {};
    try {
        return Oc({}, ...Vu.matchAll(t).reverse())
    } catch (n) {
        return console.error("[nuxt] Error matching route rules.", n), {}
    }
}
async function ap(e, t = {}) {
    if (!await E0(e)) return null;
    const r = await bw(e, t);
    return await x0(r) || null
}
const vw = "_payload.json";
async function bw(e, t = {}) {
    const n = new URL(e, "http://localhost");
    if (n.host !== "localhost" || Qs(n.pathname, {
            acceptRelative: !0
        })) throw new Error("Payload URL must not include hostname: " + e);
    const r = Bs(),
        i = t.hash || (t.fresh ? Date.now() : r.app.buildId),
        s = r.app.cdnURL,
        a = s && await E0(e) ? s : r.app.baseURL;
    return Rc(a, n.pathname, vw + (i ? `?${i}` : ""))
}
async function x0(e) {
    const t = fetch(e, {
        cache: "force-cache"
    }).then(n => n.text().then(C0));
    try {
        return await t
    } catch (n) {
        console.warn("[nuxt] Cannot load payload ", e, n)
    }
    return null
}
async function E0(e = Mc().path) {
    const t = vr();
    return e = qa(e), (await Fc()).prerendered.includes(e) ? !0 : t.runWithContext(async () => {
        const r = await jh({
            path: e
        });
        return !!r.prerender && !r.redirect
    })
}
let oa = null;
async function ww() {
    var r;
    if (oa) return oa;
    const e = document.getElementById("__NUXT_DATA__");
    if (!e) return {};
    const t = await C0(e.textContent || ""),
        n = e.dataset.src ? await x0(e.dataset.src) : void 0;
    return oa = {
        ...t,
        ...n,
        ...window.__NUXT__
    }, (r = oa.config) != null && r.public && (oa.config.public = mi(oa.config.public)), oa
}
async function C0(e) {
    return await qb(e, vr()._payloadRevivers)
}

function S0(e, t) {
    vr()._payloadRevivers[e] = t
}
const Dw = mb(() => {
        S0("skipHydrate", e => {})
    }),
    xw = [
        ["NuxtError", e => Bo(e)],
        ["EmptyShallowRef", e => Ur(e === "_" ? void 0 : e === "0n" ? BigInt(0) : oc(e))],
        ["EmptyRef", e => kn(e === "_" ? void 0 : e === "0n" ? BigInt(0) : oc(e))],
        ["ShallowRef", e => Ur(e)],
        ["ShallowReactive", e => Ms(e)],
        ["Ref", e => kn(e)],
        ["Reactive", e => mi(e)]
    ],
    Ew = Di({
        name: "nuxt:revive-payload:client",
        order: -30,
        async setup(e) {
            let t, n;
            for (const [r, i] of xw) S0(r, i);
            Object.assign(e.payload, ([t, n] = Va(() => e.runWithContext(ww)), t = await t, n(), t)), window.__NUXT__ = e.payload
        }
    });
async function Uh(e, t = {}) {
    const n = t.document || e.resolvedOptions.document;
    if (!n || !e.dirty) return;
    const r = {
        shouldRender: !0,
        tags: []
    };
    if (await e.hooks.callHook("dom:beforeRender", r), !!r.shouldRender) return e._domUpdatePromise || (e._domUpdatePromise = new Promise(async i => {
        var E;
        const s = new Map,
            a = new Promise(L => {
                e.resolveTags().then(b => {
                    L(b.map(j => {
                        const A = s.get(j._d) || 0,
                            $ = {
                                tag: j,
                                id: (A ? `${j._d}:${A}` : j._d) || tp(j),
                                shouldRender: !0
                            };
                        return j._d && y0(j._d) && s.set(j._d, A + 1), $
                    }))
                })
            });
        let c = e._dom;
        if (!c) {
            c = {
                title: n.title,
                elMap: new Map().set("htmlAttrs", n.documentElement).set("bodyAttrs", n.body)
            };
            for (const L of ["body", "head"]) {
                const b = (E = n[L]) == null ? void 0 : E.children;
                for (const j of b) {
                    const A = j.tagName.toLowerCase();
                    if (!Zd.has(A)) continue;
                    const $ = v0({
                        tag: A,
                        props: {}
                    }, {
                        innerHTML: j.innerHTML,
                        ...j.getAttributeNames().reduce((w, k) => (w[k] = j.getAttribute(k), w), {}) || {}
                    });
                    if ($.key = j.getAttribute("data-hid") || void 0, $._d = eh($) || tp($), c.elMap.has($._d)) {
                        let w = 1,
                            k = $._d;
                        for (; c.elMap.has(k);) k = `${$._d}:${w++}`;
                        c.elMap.set(k, j)
                    } else c.elMap.set($._d, j)
                }
            }
        }
        c.pendingSideEffects = {
            ...c.sideEffects
        }, c.sideEffects = {};

        function u(L, b, j) {
            const A = `${L}:${b}`;
            c.sideEffects[A] = j, delete c.pendingSideEffects[A]
        }

        function p({
            id: L,
            $el: b,
            tag: j
        }) {
            const A = j.tag.endsWith("Attrs");
            c.elMap.set(L, b), A || (j.textContent && j.textContent !== b.textContent && (b.textContent = j.textContent), j.innerHTML && j.innerHTML !== b.innerHTML && (b.innerHTML = j.innerHTML), u(L, "el", () => {
                b == null || b.remove(), c.elMap.delete(L)
            }));
            for (const $ in j.props) {
                if (!Object.prototype.hasOwnProperty.call(j.props, $)) continue;
                const w = j.props[$];
                if ($.startsWith("on") && typeof w == "function") {
                    const S = b == null ? void 0 : b.dataset;
                    if (S && S[`${$}fired`]) {
                        const X = $.slice(0, -5);
                        w.call(b, new Event(X.substring(2)))
                    }
                    b.getAttribute(`data-${$}`) !== "" && ((j.tag === "bodyAttrs" ? n.defaultView : b).addEventListener($.substring(2), w.bind(b)), b.setAttribute(`data-${$}`, ""));
                    continue
                }
                const k = `attr:${$}`;
                if ($ === "class") {
                    if (!w) continue;
                    for (const S of w) A && u(L, `${k}:${S}`, () => b.classList.remove(S)), !b.classList.contains(S) && b.classList.add(S)
                } else if ($ === "style") {
                    if (!w) continue;
                    for (const [S, X] of w) u(L, `${k}:${S}`, () => {
                        b.style.removeProperty(S)
                    }), b.style.setProperty(S, X)
                } else w !== !1 && w !== null && (b.getAttribute($) !== w && b.setAttribute($, w === !0 ? "" : String(w)), A && u(L, k, () => b.removeAttribute($)))
            }
        }
        const d = [],
            g = {
                bodyClose: void 0,
                bodyOpen: void 0,
                head: void 0
            },
            m = await a;
        for (const L of m) {
            const {
                tag: b,
                shouldRender: j,
                id: A
            } = L;
            if (j) {
                if (b.tag === "title") {
                    n.title = b.textContent, u("title", "", () => n.title = c.title);
                    continue
                }
                L.$el = L.$el || c.elMap.get(A), L.$el ? p(L) : Zd.has(b.tag) && d.push(L)
            }
        }
        for (const L of d) {
            const b = L.tag.tagPosition || "head";
            L.$el = n.createElement(L.tag.tag), p(L), g[b] = g[b] || n.createDocumentFragment(), g[b].appendChild(L.$el)
        }
        for (const L of m) await e.hooks.callHook("dom:renderTag", L, n, u);
        g.head && n.head.appendChild(g.head), g.bodyOpen && n.body.insertBefore(g.bodyOpen, n.body.firstChild), g.bodyClose && n.body.appendChild(g.bodyClose);
        for (const L in c.pendingSideEffects) c.pendingSideEffects[L]();
        e._dom = c, await e.hooks.callHook("dom:rendered", {
            renders: m
        }), i()
    }).finally(() => {
        e._domUpdatePromise = void 0, e.dirty = !1
    })), e._domUpdatePromise
}

function Cw(e = {}) {
    var r, i, s;
    const t = ((r = e.domOptions) == null ? void 0 : r.render) || Uh;
    e.document = e.document || (typeof window < "u" ? document : void 0);
    const n = ((s = (i = e.document) == null ? void 0 : i.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : s.innerHTML) || !1;
    return fw({
        ...e,
        plugins: [...e.plugins || [], {
            key: "client",
            hooks: {
                "entries:updated": t
            }
        }],
        init: [n ? JSON.parse(n) : !1, ...e.init || []]
    })
}

function Sw(e, t) {
    let n = 0;
    return () => {
        const r = ++n;
        t(() => {
            n === r && e()
        })
    }
}

function Tw(e = {}) {
    const t = Cw({
        domOptions: {
            render: Sw(() => Uh(t), n => setTimeout(n, 0))
        },
        ...e
    });
    return t.install = dw(t), t
}
const Pw = new Set(["onload", "onerror"]);
const kw = (e, t) => e._w === t._w ? e._p - t._p : e._w - t._w,
    Lo = "%separator",
    Aw = new RegExp(`${Lo}(?:\\s*${Lo})*`, "g");

function Rw(e, t, n = !1) {
    var i;
    let r;
    if (t === "s" || t === "pageTitle") r = e.pageTitle;
    else if (t.includes(".")) {
        const s = t.indexOf(".");
        r = (i = e[t.substring(0, s)]) == null ? void 0 : i[t.substring(s + 1)]
    } else r = e[t];
    if (r !== void 0) return n ? (r || "").replace(/\\/g, "\\\\").replace(/</g, "\\u003C").replace(/"/g, '\\"') : r || ""
}

function Pu(e, t, n, r = !1) {
    if (typeof e != "string" || !e.includes("%")) return e;
    let i = e;
    try {
        i = decodeURI(e)
    } catch {}
    const s = i.match(/%\w+(?:\.\w+)?/g);
    if (!s) return e;
    const a = e.includes(Lo);
    return e = e.replace(/%\w+(?:\.\w+)?/g, c => {
        if (c === Lo || !s.includes(c)) return c;
        const u = Rw(t, c.slice(1), r);
        return u !== void 0 ? u : c
    }).trim(), a && (e.endsWith(Lo) && (e = e.slice(0, -Lo.length)), e.startsWith(Lo) && (e = e.slice(Lo.length)), e = e.replace(Aw, n || "").trim()), e
}
const lp = e => e.includes(":key") ? e : e.split(":").join(":key:"),
    Ow = {
        key: "aliasSorting",
        hooks: {
            "tags:resolve": e => {
                let t = !1;
                for (const n of e.tags) {
                    const r = n.tagPriority;
                    if (!r) continue;
                    const i = String(r);
                    if (i.startsWith("before:")) {
                        const s = lp(i.slice(7)),
                            a = e.tagMap.get(s);
                        a && (typeof a.tagPriority == "number" && (n.tagPriority = a.tagPriority), n._p = a._p - 1, t = !0)
                    } else if (i.startsWith("after:")) {
                        const s = lp(i.slice(6)),
                            a = e.tagMap.get(s);
                        a && (typeof a.tagPriority == "number" && (n.tagPriority = a.tagPriority), n._p = a._p + 1, t = !0)
                    }
                }
                t && (e.tags = e.tags.sort(kw))
            }
        }
    },
    Mw = {
        key: "deprecations",
        hooks: {
            "entries:normalize": ({
                tags: e
            }) => {
                for (const t of e) t.props.children && (t.innerHTML = t.props.children, delete t.props.children), t.props.hid && (t.key = t.props.hid, delete t.props.hid), t.props.vmid && (t.key = t.props.vmid, delete t.props.vmid), t.props.body && (t.tagPosition = "bodyClose", delete t.props.body)
            }
        }
    };
async function th(e) {
    if (typeof e === "function") return e;
    if (e instanceof Promise) return await e;
    if (Array.isArray(e)) return await Promise.all(e.map(n => th(n)));
    if ((e == null ? void 0 : e.constructor) === Object) {
        const n = {};
        for (const r of Object.keys(e)) n[r] = await th(e[r]);
        return n
    }
    return e
}
const Lw = {
        key: "promises",
        hooks: {
            "entries:resolve": async e => {
                const t = [];
                for (const n in e.entries) e.entries[n]._promisesProcessed || t.push(th(e.entries[n].input).then(r => {
                    e.entries[n].input = r, e.entries[n]._promisesProcessed = !0
                }));
                await Promise.all(t)
            }
        }
    },
    Fw = {
        meta: "content",
        link: "href",
        htmlAttrs: "lang"
    },
    Iw = ["innerHTML", "textContent"],
    Nw = e => ({
        key: "template-params",
        hooks: {
            "entries:normalize": t => {
                var r, i, s;
                const n = ((i = (r = t.tags.filter(a => a.tag === "templateParams" && a.mode === "server")) == null ? void 0 : r[0]) == null ? void 0 : i.props) || {};
                Object.keys(n).length && (e._ssrPayload = {
                    templateParams: {
                        ...((s = e._ssrPayload) == null ? void 0 : s.templateParams) || {},
                        ...n
                    }
                })
            },
            "tags:resolve": ({
                tagMap: t,
                tags: n
            }) => {
                var s;
                const r = ((s = t.get("templateParams")) == null ? void 0 : s.props) || {},
                    i = r.separator || "|";
                delete r.separator, r.pageTitle = Pu(r.pageTitle || e._title || "", r, i);
                for (const a of n) {
                    if (a.processTemplateParams === !1) continue;
                    const c = Fw[a.tag];
                    if (c && typeof a.props[c] == "string") a.props[c] = Pu(a.props[c], r, i);
                    else if (a.processTemplateParams || a.tag === "titleTemplate" || a.tag === "title")
                        for (const u of Iw) typeof a[u] == "string" && (a[u] = Pu(a[u], r, i, a.tag === "script" && a.props.type.endsWith("json")))
                }
                e._templateParams = r, e._separator = i
            },
            "tags:afterResolve": ({
                tagMap: t
            }) => {
                const n = t.get("title");
                n != null && n.textContent && n.processTemplateParams !== !1 && (n.textContent = Pu(n.textContent, e._templateParams, e._separator))
            }
        }
    }),
    Bw = {
        disableDefaults: !0,
        disableCapoSorting: !1,
        plugins: [Mw, Lw, Nw, Ow]
    },
    $w = Di({
        name: "nuxt:head",
        enforce: "pre",
        setup(e) {
            const t = Tw(Bw);
            e.vueApp.use(t);
            {
                let n = !0;
                const r = async () => {
                    n = !1, await Uh(t)
                };
                t.hooks.hook("dom:beforeRender", i => {
                    i.shouldRender = !n
                }), e.hooks.hook("page:start", () => {
                    n = !0
                }), e.hooks.hook("page:finish", () => {
                    e.isHydrating || r()
                }), e.hooks.hook("app:error", r), e.hooks.hook("app:suspense:resolve", r)
            }
        }
    });
/*!
 * vue-router v4.5.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
const Ra = typeof document < "u";

function T0(e) {
    return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e
}

function Hw(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module" || e.default && T0(e.default)
}
const Jn = Object.assign;

function uf(e, t) {
    const n = {};
    for (const r in t) {
        const i = t[r];
        n[r] = Ns(i) ? i.map(e) : e(i)
    }
    return n
}
const Il = () => {},
    Ns = Array.isArray,
    P0 = /#/g,
    Vw = /&/g,
    zw = /\//g,
    jw = /=/g,
    Uw = /\?/g,
    k0 = /\+/g,
    Ww = /%5B/g,
    qw = /%5D/g,
    A0 = /%5E/g,
    Gw = /%60/g,
    R0 = /%7B/g,
    Yw = /%7C/g,
    O0 = /%7D/g,
    Xw = /%20/g;

function Wh(e) {
    return encodeURI("" + e).replace(Yw, "|").replace(Ww, "[").replace(qw, "]")
}

function Kw(e) {
    return Wh(e).replace(R0, "{").replace(O0, "}").replace(A0, "^")
}

function nh(e) {
    return Wh(e).replace(k0, "%2B").replace(Xw, "+").replace(P0, "%23").replace(Vw, "%26").replace(Gw, "`").replace(R0, "{").replace(O0, "}").replace(A0, "^")
}

function Qw(e) {
    return nh(e).replace(jw, "%3D")
}

function Jw(e) {
    return Wh(e).replace(P0, "%23").replace(Uw, "%3F")
}

function Zw(e) {
    return e == null ? "" : Jw(e).replace(zw, "%2F")
}

function Kl(e) {
    try {
        return decodeURIComponent("" + e)
    } catch {}
    return "" + e
}
const eD = /\/$/,
    tD = e => e.replace(eD, "");

function cf(e, t, n = "/") {
    let r, i = {},
        s = "",
        a = "";
    const c = t.indexOf("#");
    let u = t.indexOf("?");
    return c < u && c >= 0 && (u = -1), u > -1 && (r = t.slice(0, u), s = t.slice(u + 1, c > -1 ? c : t.length), i = e(s)), c > -1 && (r = r || t.slice(0, c), a = t.slice(c, t.length)), r = sD(r ?? t, n), {
        fullPath: r + (s && "?") + s + a,
        path: r,
        query: i,
        hash: Kl(a)
    }
}

function nD(e, t) {
    const n = t.query ? e(t.query) : "";
    return t.path + (n && "?") + n + (t.hash || "")
}

function up(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}

function rD(e, t, n) {
    const r = t.matched.length - 1,
        i = n.matched.length - 1;
    return r > -1 && r === i && Ga(t.matched[r], n.matched[i]) && M0(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
}

function Ga(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}

function M0(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length) return !1;
    for (const n in e)
        if (!iD(e[n], t[n])) return !1;
    return !0
}

function iD(e, t) {
    return Ns(e) ? cp(e, t) : Ns(t) ? cp(t, e) : e === t
}

function cp(e, t) {
    return Ns(t) ? e.length === t.length && e.every((n, r) => n === t[r]) : e.length === 1 && e[0] === t
}

function sD(e, t) {
    if (e.startsWith("/")) return e;
    if (!e) return t;
    const n = t.split("/"),
        r = e.split("/"),
        i = r[r.length - 1];
    (i === ".." || i === ".") && r.push("");
    let s = n.length - 1,
        a, c;
    for (a = 0; a < r.length; a++)
        if (c = r[a], c !== ".")
            if (c === "..") s > 1 && s--;
            else break;
    return n.slice(0, s).join("/") + "/" + r.slice(a).join("/")
}
const ys = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var Ql;
(function(e) {
    e.pop = "pop", e.push = "push"
})(Ql || (Ql = {}));
var Nl;
(function(e) {
    e.back = "back", e.forward = "forward", e.unknown = ""
})(Nl || (Nl = {}));

function oD(e) {
    if (!e)
        if (Ra) {
            const t = document.querySelector("base");
            e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "")
        } else e = "/";
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), tD(e)
}
const aD = /^[^#]+#/;

function lD(e, t) {
    return e.replace(aD, "#") + t
}

function uD(e, t) {
    const n = document.documentElement.getBoundingClientRect(),
        r = e.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: r.left - n.left - (t.left || 0),
        top: r.top - n.top - (t.top || 0)
    }
}
const Ic = () => ({
    left: window.scrollX,
    top: window.scrollY
});

function cD(e) {
    let t;
    if ("el" in e) {
        const n = e.el,
            r = typeof n == "string" && n.startsWith("#"),
            i = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!i) return;
        t = uD(i, e)
    } else t = e;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}

function fp(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const rh = new Map;

function fD(e, t) {
    rh.set(e, t)
}

function hD(e) {
    const t = rh.get(e);
    return rh.delete(e), t
}
let dD = () => location.protocol + "//" + location.host;

function L0(e, t) {
    const {
        pathname: n,
        search: r,
        hash: i
    } = t, s = e.indexOf("#");
    if (s > -1) {
        let c = i.includes(e.slice(s)) ? e.slice(s).length : 1,
            u = i.slice(c);
        return u[0] !== "/" && (u = "/" + u), up(u, "")
    }
    return up(n, e) + r + i
}

function pD(e, t, n, r) {
    let i = [],
        s = [],
        a = null;
    const c = ({
        state: m
    }) => {
        const E = L0(e, location),
            L = n.value,
            b = t.value;
        let j = 0;
        if (m) {
            if (n.value = E, t.value = m, a && a === L) {
                a = null;
                return
            }
            j = b ? m.position - b.position : 0
        } else r(E);
        i.forEach(A => {
            A(n.value, L, {
                delta: j,
                type: Ql.pop,
                direction: j ? j > 0 ? Nl.forward : Nl.back : Nl.unknown
            })
        })
    };

    function u() {
        a = n.value
    }

    function p(m) {
        i.push(m);
        const E = () => {
            const L = i.indexOf(m);
            L > -1 && i.splice(L, 1)
        };
        return s.push(E), E
    }

    function d() {
        const {
            history: m
        } = window;
        m.state && m.replaceState(Jn({}, m.state, {
            scroll: Ic()
        }), "")
    }

    function g() {
        for (const m of s) m();
        s = [], window.removeEventListener("popstate", c), window.removeEventListener("beforeunload", d)
    }
    return window.addEventListener("popstate", c), window.addEventListener("beforeunload", d, {
        passive: !0
    }), {
        pauseListeners: u,
        listen: p,
        destroy: g
    }
}

function hp(e, t, n, r = !1, i = !1) {
    return {
        back: e,
        current: t,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: i ? Ic() : null
    }
}

function gD(e) {
    const {
        history: t,
        location: n
    } = window, r = {
        value: L0(e, n)
    }, i = {
        value: t.state
    };
    i.value || s(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0);

    function s(u, p, d) {
        const g = e.indexOf("#"),
            m = g > -1 ? (n.host && document.querySelector("base") ? e : e.slice(g)) + u : dD() + e + u;
        try {
            t[d ? "replaceState" : "pushState"](p, "", m), i.value = p
        } catch (E) {
            console.error(E), n[d ? "replace" : "assign"](m)
        }
    }

    function a(u, p) {
        const d = Jn({}, t.state, hp(i.value.back, u, i.value.forward, !0), p, {
            position: i.value.position
        });
        s(u, d, !0), r.value = u
    }

    function c(u, p) {
        const d = Jn({}, i.value, t.state, {
            forward: u,
            scroll: Ic()
        });
        s(d.current, d, !0);
        const g = Jn({}, hp(r.value, u, null), {
            position: d.position + 1
        }, p);
        s(u, g, !1), r.value = u
    }
    return {
        location: r,
        state: i,
        push: c,
        replace: a
    }
}

function _D(e) {
    e = oD(e);
    const t = gD(e),
        n = pD(e, t.state, t.location, t.replace);

    function r(s, a = !0) {
        a || n.pauseListeners(), history.go(s)
    }
    const i = Jn({
        location: "",
        base: e,
        go: r,
        createHref: lD.bind(null, e)
    }, t, n);
    return Object.defineProperty(i, "location", {
        enumerable: !0,
        get: () => t.location.value
    }), Object.defineProperty(i, "state", {
        enumerable: !0,
        get: () => t.state.value
    }), i
}

function mD(e) {
    return typeof e == "string" || e && typeof e == "object"
}

function F0(e) {
    return typeof e == "string" || typeof e == "symbol"
}
const I0 = Symbol("");
var dp;
(function(e) {
    e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated"
})(dp || (dp = {}));

function Ya(e, t) {
    return Jn(new Error, {
        type: e,
        [I0]: !0
    }, t)
}

function lo(e, t) {
    return e instanceof Error && I0 in e && (t == null || !!(e.type & t))
}
const pp = "[^/]+?",
    yD = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    },
    vD = /[.+*?^${}()[\]/\\]/g;

function bD(e, t) {
    const n = Jn({}, yD, t),
        r = [];
    let i = n.start ? "^" : "";
    const s = [];
    for (const p of e) {
        const d = p.length ? [] : [90];
        n.strict && !p.length && (i += "/");
        for (let g = 0; g < p.length; g++) {
            const m = p[g];
            let E = 40 + (n.sensitive ? .25 : 0);
            if (m.type === 0) g || (i += "/"), i += m.value.replace(vD, "\\$&"), E += 40;
            else if (m.type === 1) {
                const {
                    value: L,
                    repeatable: b,
                    optional: j,
                    regexp: A
                } = m;
                s.push({
                    name: L,
                    repeatable: b,
                    optional: j
                });
                const $ = A || pp;
                if ($ !== pp) {
                    E += 10;
                    try {
                        new RegExp(`(${$})`)
                    } catch (k) {
                        throw new Error(`Invalid custom RegExp for param "${L}" (${$}): ` + k.message)
                    }
                }
                let w = b ? `((?:${$})(?:/(?:${$}))*)` : `(${$})`;
                g || (w = j && p.length < 2 ? `(?:/${w})` : "/" + w), j && (w += "?"), i += w, E += 20, j && (E += -8), b && (E += -20), $ === ".*" && (E += -50)
            }
            d.push(E)
        }
        r.push(d)
    }
    if (n.strict && n.end) {
        const p = r.length - 1;
        r[p][r[p].length - 1] += .7000000000000001
    }
    n.strict || (i += "/?"), n.end ? i += "$" : n.strict && !i.endsWith("/") && (i += "(?:/|$)");
    const a = new RegExp(i, n.sensitive ? "" : "i");

    function c(p) {
        const d = p.match(a),
            g = {};
        if (!d) return null;
        for (let m = 1; m < d.length; m++) {
            const E = d[m] || "",
                L = s[m - 1];
            g[L.name] = E && L.repeatable ? E.split("/") : E
        }
        return g
    }

    function u(p) {
        let d = "",
            g = !1;
        for (const m of e) {
            (!g || !d.endsWith("/")) && (d += "/"), g = !1;
            for (const E of m)
                if (E.type === 0) d += E.value;
                else if (E.type === 1) {
                const {
                    value: L,
                    repeatable: b,
                    optional: j
                } = E, A = L in p ? p[L] : "";
                if (Ns(A) && !b) throw new Error(`Provided param "${L}" is an array but it is not repeatable (* or + modifiers)`);
                const $ = Ns(A) ? A.join("/") : A;
                if (!$)
                    if (j) m.length < 2 && (d.endsWith("/") ? d = d.slice(0, -1) : g = !0);
                    else throw new Error(`Missing required param "${L}"`);
                d += $
            }
        }
        return d || "/"
    }
    return {
        re: a,
        score: r,
        keys: s,
        parse: c,
        stringify: u
    }
}

function wD(e, t) {
    let n = 0;
    for (; n < e.length && n < t.length;) {
        const r = t[n] - e[n];
        if (r) return r;
        n++
    }
    return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0
}

function N0(e, t) {
    let n = 0;
    const r = e.score,
        i = t.score;
    for (; n < r.length && n < i.length;) {
        const s = wD(r[n], i[n]);
        if (s) return s;
        n++
    }
    if (Math.abs(i.length - r.length) === 1) {
        if (gp(r)) return 1;
        if (gp(i)) return -1
    }
    return i.length - r.length
}

function gp(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const DD = {
        type: 0,
        value: ""
    },
    xD = /[a-zA-Z0-9_]/;

function ED(e) {
    if (!e) return [
        []
    ];
    if (e === "/") return [
        [DD]
    ];
    if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`);

    function t(E) {
        throw new Error(`ERR (${n})/"${p}": ${E}`)
    }
    let n = 0,
        r = n;
    const i = [];
    let s;

    function a() {
        s && i.push(s), s = []
    }
    let c = 0,
        u, p = "",
        d = "";

    function g() {
        p && (n === 0 ? s.push({
            type: 0,
            value: p
        }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (u === "*" || u === "+") && t(`A repeatable param (${p}) must be alone in its segment. eg: '/:ids+.`), s.push({
            type: 1,
            value: p,
            regexp: d,
            repeatable: u === "*" || u === "+",
            optional: u === "*" || u === "?"
        })) : t("Invalid state to consume buffer"), p = "")
    }

    function m() {
        p += u
    }
    for (; c < e.length;) {
        if (u = e[c++], u === "\\" && n !== 2) {
            r = n, n = 4;
            continue
        }
        switch (n) {
            case 0:
                u === "/" ? (p && g(), a()) : u === ":" ? (g(), n = 1) : m();
                break;
            case 4:
                m(), n = r;
                break;
            case 1:
                u === "(" ? n = 2 : xD.test(u) ? m() : (g(), n = 0, u !== "*" && u !== "?" && u !== "+" && c--);
                break;
            case 2:
                u === ")" ? d[d.length - 1] == "\\" ? d = d.slice(0, -1) + u : n = 3 : d += u;
                break;
            case 3:
                g(), n = 0, u !== "*" && u !== "?" && u !== "+" && c--, d = "";
                break;
            default:
                t("Unknown state");
                break
        }
    }
    return n === 2 && t(`Unfinished custom RegExp for param "${p}"`), g(), a(), i
}

function CD(e, t, n) {
    const r = bD(ED(e.path), n),
        i = Jn(r, {
            record: e,
            parent: t,
            children: [],
            alias: []
        });
    return t && !i.record.aliasOf == !t.record.aliasOf && t.children.push(i), i
}

function SD(e, t) {
    const n = [],
        r = new Map;
    t = vp({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t);

    function i(g) {
        return r.get(g)
    }

    function s(g, m, E) {
        const L = !E,
            b = mp(g);
        b.aliasOf = E && E.record;
        const j = vp(t, g),
            A = [b];
        if ("alias" in g) {
            const k = typeof g.alias == "string" ? [g.alias] : g.alias;
            for (const S of k) A.push(mp(Jn({}, b, {
                components: E ? E.record.components : b.components,
                path: S,
                aliasOf: E ? E.record : b
            })))
        }
        let $, w;
        for (const k of A) {
            const {
                path: S
            } = k;
            if (m && S[0] !== "/") {
                const X = m.record.path,
                    J = X[X.length - 1] === "/" ? "" : "/";
                k.path = m.record.path + (S && J + S)
            }
            if ($ = CD(k, m, j), E ? E.alias.push($) : (w = w || $, w !== $ && w.alias.push($), L && g.name && !yp($) && a(g.name)), B0($) && u($), b.children) {
                const X = b.children;
                for (let J = 0; J < X.length; J++) s(X[J], $, E && E.children[J])
            }
            E = E || $
        }
        return w ? () => {
            a(w)
        } : Il
    }

    function a(g) {
        if (F0(g)) {
            const m = r.get(g);
            m && (r.delete(g), n.splice(n.indexOf(m), 1), m.children.forEach(a), m.alias.forEach(a))
        } else {
            const m = n.indexOf(g);
            m > -1 && (n.splice(m, 1), g.record.name && r.delete(g.record.name), g.children.forEach(a), g.alias.forEach(a))
        }
    }

    function c() {
        return n
    }

    function u(g) {
        const m = kD(g, n);
        n.splice(m, 0, g), g.record.name && !yp(g) && r.set(g.record.name, g)
    }

    function p(g, m) {
        let E, L = {},
            b, j;
        if ("name" in g && g.name) {
            if (E = r.get(g.name), !E) throw Ya(1, {
                location: g
            });
            j = E.record.name, L = Jn(_p(m.params, E.keys.filter(w => !w.optional).concat(E.parent ? E.parent.keys.filter(w => w.optional) : []).map(w => w.name)), g.params && _p(g.params, E.keys.map(w => w.name))), b = E.stringify(L)
        } else if (g.path != null) b = g.path, E = n.find(w => w.re.test(b)), E && (L = E.parse(b), j = E.record.name);
        else {
            if (E = m.name ? r.get(m.name) : n.find(w => w.re.test(m.path)), !E) throw Ya(1, {
                location: g,
                currentLocation: m
            });
            j = E.record.name, L = Jn({}, m.params, g.params), b = E.stringify(L)
        }
        const A = [];
        let $ = E;
        for (; $;) A.unshift($.record), $ = $.parent;
        return {
            name: j,
            path: b,
            params: L,
            matched: A,
            meta: PD(A)
        }
    }
    e.forEach(g => s(g));

    function d() {
        n.length = 0, r.clear()
    }
    return {
        addRoute: s,
        resolve: p,
        removeRoute: a,
        clearRoutes: d,
        getRoutes: c,
        getRecordMatcher: i
    }
}

function _p(e, t) {
    const n = {};
    for (const r of t) r in e && (n[r] = e[r]);
    return n
}

function mp(e) {
    const t = {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: e.aliasOf,
        beforeEnter: e.beforeEnter,
        props: TD(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in e ? e.components || null : e.component && {
            default: e.component
        }
    };
    return Object.defineProperty(t, "mods", {
        value: {}
    }), t
}

function TD(e) {
    const t = {},
        n = e.props || !1;
    if ("component" in e) t.default = n;
    else
        for (const r in e.components) t[r] = typeof n == "object" ? n[r] : n;
    return t
}

function yp(e) {
    for (; e;) {
        if (e.record.aliasOf) return !0;
        e = e.parent
    }
    return !1
}

function PD(e) {
    return e.reduce((t, n) => Jn(t, n.meta), {})
}

function vp(e, t) {
    const n = {};
    for (const r in e) n[r] = r in t ? t[r] : e[r];
    return n
}

function kD(e, t) {
    let n = 0,
        r = t.length;
    for (; n !== r;) {
        const s = n + r >> 1;
        N0(e, t[s]) < 0 ? r = s : n = s + 1
    }
    const i = AD(e);
    return i && (r = t.lastIndexOf(i, r - 1)), r
}

function AD(e) {
    let t = e;
    for (; t = t.parent;)
        if (B0(t) && N0(e, t) === 0) return t
}

function B0({
    record: e
}) {
    return !!(e.name || e.components && Object.keys(e.components).length || e.redirect)
}

function RD(e) {
    const t = {};
    if (e === "" || e === "?") return t;
    const r = (e[0] === "?" ? e.slice(1) : e).split("&");
    for (let i = 0; i < r.length; ++i) {
        const s = r[i].replace(k0, " "),
            a = s.indexOf("="),
            c = Kl(a < 0 ? s : s.slice(0, a)),
            u = a < 0 ? null : Kl(s.slice(a + 1));
        if (c in t) {
            let p = t[c];
            Ns(p) || (p = t[c] = [p]), p.push(u)
        } else t[c] = u
    }
    return t
}

function bp(e) {
    let t = "";
    for (let n in e) {
        const r = e[n];
        if (n = Qw(n), r == null) {
            r !== void 0 && (t += (t.length ? "&" : "") + n);
            continue
        }(Ns(r) ? r.map(s => s && nh(s)) : [r && nh(r)]).forEach(s => {
            s !== void 0 && (t += (t.length ? "&" : "") + n, s != null && (t += "=" + s))
        })
    }
    return t
}

function OD(e) {
    const t = {};
    for (const n in e) {
        const r = e[n];
        r !== void 0 && (t[n] = Ns(r) ? r.map(i => i == null ? null : "" + i) : r == null ? r : "" + r)
    }
    return t
}
const MD = Symbol(""),
    wp = Symbol(""),
    Nc = Symbol(""),
    qh = Symbol(""),
    ih = Symbol("");

function dl() {
    let e = [];

    function t(r) {
        return e.push(r), () => {
            const i = e.indexOf(r);
            i > -1 && e.splice(i, 1)
        }
    }

    function n() {
        e = []
    }
    return {
        add: t,
        list: () => e.slice(),
        reset: n
    }
}

function Fo(e, t, n, r, i, s = a => a()) {
    const a = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
    return () => new Promise((c, u) => {
        const p = m => {
                m === !1 ? u(Ya(4, {
                    from: n,
                    to: t
                })) : m instanceof Error ? u(m) : mD(m) ? u(Ya(2, {
                    from: t,
                    to: m
                })) : (a && r.enterCallbacks[i] === a && typeof m == "function" && a.push(m), c())
            },
            d = s(() => e.call(r && r.instances[i], t, n, p));
        let g = Promise.resolve(d);
        e.length < 3 && (g = g.then(p)), g.catch(m => u(m))
    })
}

function ff(e, t, n, r, i = s => s()) {
    const s = [];
    for (const a of e)
        for (const c in a.components) {
            let u = a.components[c];
            if (!(t !== "beforeRouteEnter" && !a.instances[c]))
                if (T0(u)) {
                    const d = (u.__vccOpts || u)[t];
                    d && s.push(Fo(d, n, r, a, c, i))
                } else {
                    let p = u();
                    s.push(() => p.then(d => {
                        if (!d) throw new Error(`Couldn't resolve component "${c}" at "${a.path}"`);
                        const g = Hw(d) ? d.default : d;
                        a.mods[c] = d, a.components[c] = g;
                        const E = (g.__vccOpts || g)[t];
                        return E && Fo(E, n, r, a, c, i)()
                    }))
                }
        }
    return s
}

function Dp(e) {
    const t = Er(Nc),
        n = Er(qh),
        r = xn(() => {
            const u = Kt(e.to);
            return t.resolve(u)
        }),
        i = xn(() => {
            const {
                matched: u
            } = r.value, {
                length: p
            } = u, d = u[p - 1], g = n.matched;
            if (!d || !g.length) return -1;
            const m = g.findIndex(Ga.bind(null, d));
            if (m > -1) return m;
            const E = xp(u[p - 2]);
            return p > 1 && xp(d) === E && g[g.length - 1].path !== E ? g.findIndex(Ga.bind(null, u[p - 2])) : m
        }),
        s = xn(() => i.value > -1 && BD(n.params, r.value.params)),
        a = xn(() => i.value > -1 && i.value === n.matched.length - 1 && M0(n.params, r.value.params));

    function c(u = {}) {
        if (ND(u)) {
            const p = t[Kt(e.replace) ? "replace" : "push"](Kt(e.to)).catch(Il);
            return e.viewTransition && typeof document < "u" && "startViewTransition" in document && document.startViewTransition(() => p), p
        }
        return Promise.resolve()
    }
    return {
        route: r,
        href: xn(() => r.value.href),
        isActive: s,
        isExactActive: a,
        navigate: c
    }
}

function LD(e) {
    return e.length === 1 ? e[0] : e
}
const FD = Jr({
        name: "RouterLink",
        compatConfig: {
            MODE: 3
        },
        props: {
            to: {
                type: [String, Object],
                required: !0
            },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: {
                type: String,
                default: "page"
            },
            viewTransition: Boolean
        },
        useLink: Dp,
        setup(e, {
            slots: t
        }) {
            const n = mi(Dp(e)),
                {
                    options: r
                } = Er(Nc),
                i = xn(() => ({
                    [Ep(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
                    [Ep(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
                }));
            return () => {
                const s = t.default && LD(t.default(n));
                return e.custom ? s : jr("a", {
                    "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                    href: n.href,
                    onClick: n.navigate,
                    class: i.value
                }, s)
            }
        }
    }),
    ID = FD;

function ND(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t)) return
        }
        return e.preventDefault && e.preventDefault(), !0
    }
}

function BD(e, t) {
    for (const n in t) {
        const r = t[n],
            i = e[n];
        if (typeof r == "string") {
            if (r !== i) return !1
        } else if (!Ns(i) || i.length !== r.length || r.some((s, a) => s !== i[a])) return !1
    }
    return !0
}

function xp(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const Ep = (e, t, n) => e ?? t ?? n,
    $D = Jr({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(e, {
            attrs: t,
            slots: n
        }) {
            const r = Er(ih),
                i = xn(() => e.route || r.value),
                s = Er(wp, 0),
                a = xn(() => {
                    let p = Kt(s);
                    const {
                        matched: d
                    } = i.value;
                    let g;
                    for (;
                        (g = d[p]) && !g.components;) p++;
                    return p
                }),
                c = xn(() => i.value.matched[a.value]);
            ws(wp, xn(() => a.value + 1)), ws(MD, c), ws(ih, i);
            const u = kn();
            return Qr(() => [u.value, c.value, e.name], ([p, d, g], [m, E, L]) => {
                d && (d.instances[g] = p, E && E !== d && p && p === m && (d.leaveGuards.size || (d.leaveGuards = E.leaveGuards), d.updateGuards.size || (d.updateGuards = E.updateGuards))), p && d && (!E || !Ga(d, E) || !m) && (d.enterCallbacks[g] || []).forEach(b => b(p))
            }, {
                flush: "post"
            }), () => {
                const p = i.value,
                    d = e.name,
                    g = c.value,
                    m = g && g.components[d];
                if (!m) return Cp(n.default, {
                    Component: m,
                    route: p
                });
                const E = g.props[d],
                    L = E ? E === !0 ? p.params : typeof E == "function" ? E(p) : E : null,
                    j = jr(m, Jn({}, L, t, {
                        onVnodeUnmounted: A => {
                            A.component.isUnmounted && (g.instances[d] = null)
                        },
                        ref: u
                    }));
                return Cp(n.default, {
                    Component: j,
                    route: p
                }) || j
            }
        }
    });

function Cp(e, t) {
    if (!e) return null;
    const n = e(t);
    return n.length === 1 ? n[0] : n
}
const $0 = $D;

function HD(e) {
    const t = SD(e.routes, e),
        n = e.parseQuery || RD,
        r = e.stringifyQuery || bp,
        i = e.history,
        s = dl(),
        a = dl(),
        c = dl(),
        u = Ur(ys);
    let p = ys;
    Ra && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const d = uf.bind(null, de => "" + de),
        g = uf.bind(null, Zw),
        m = uf.bind(null, Kl);

    function E(de, ye) {
        let oe, ze;
        return F0(de) ? (oe = t.getRecordMatcher(de), ze = ye) : ze = de, t.addRoute(ze, oe)
    }

    function L(de) {
        const ye = t.getRecordMatcher(de);
        ye && t.removeRoute(ye)
    }

    function b() {
        return t.getRoutes().map(de => de.record)
    }

    function j(de) {
        return !!t.getRecordMatcher(de)
    }

    function A(de, ye) {
        if (ye = Jn({}, ye || u.value), typeof de == "string") {
            const I = cf(n, de, ye.path),
                fe = t.resolve({
                    path: I.path
                }, ye),
                Oe = i.createHref(I.fullPath);
            return Jn(I, fe, {
                params: m(fe.params),
                hash: Kl(I.hash),
                redirectedFrom: void 0,
                href: Oe
            })
        }
        let oe;
        if (de.path != null) oe = Jn({}, de, {
            path: cf(n, de.path, ye.path).path
        });
        else {
            const I = Jn({}, de.params);
            for (const fe in I) I[fe] == null && delete I[fe];
            oe = Jn({}, de, {
                params: g(I)
            }), ye.params = g(ye.params)
        }
        const ze = t.resolve(oe, ye),
            Se = de.hash || "";
        ze.params = d(m(ze.params));
        const Ke = nD(r, Jn({}, de, {
                hash: Kw(Se),
                path: ze.path
            })),
            M = i.createHref(Ke);
        return Jn({
            fullPath: Ke,
            hash: Se,
            query: r === bp ? OD(de.query) : de.query || {}
        }, ze, {
            redirectedFrom: void 0,
            href: M
        })
    }

    function $(de) {
        return typeof de == "string" ? cf(n, de, u.value.path) : Jn({}, de)
    }

    function w(de, ye) {
        if (p !== de) return Ya(8, {
            from: ye,
            to: de
        })
    }

    function k(de) {
        return J(de)
    }

    function S(de) {
        return k(Jn($(de), {
            replace: !0
        }))
    }

    function X(de) {
        const ye = de.matched[de.matched.length - 1];
        if (ye && ye.redirect) {
            const {
                redirect: oe
            } = ye;
            let ze = typeof oe == "function" ? oe(de) : oe;
            return typeof ze == "string" && (ze = ze.includes("?") || ze.includes("#") ? ze = $(ze) : {
                path: ze
            }, ze.params = {}), Jn({
                query: de.query,
                hash: de.hash,
                params: ze.path != null ? {} : de.params
            }, ze)
        }
    }

    function J(de, ye) {
        const oe = p = A(de),
            ze = u.value,
            Se = de.state,
            Ke = de.force,
            M = de.replace === !0,
            I = X(oe);
        if (I) return J(Jn($(I), {
            state: typeof I == "object" ? Jn({}, Se, I.state) : Se,
            force: Ke,
            replace: M
        }), ye || oe);
        const fe = oe;
        fe.redirectedFrom = ye;
        let Oe;
        return !Ke && rD(r, ze, oe) && (Oe = Ya(16, {
            to: fe,
            from: ze
        }), ht(ze, ze, !0, !1)), (Oe ? Promise.resolve(Oe) : me(fe, ze)).catch(Te => lo(Te) ? lo(Te, 2) ? Te : tt(Te) : le(Te, fe, ze)).then(Te => {
            if (Te) {
                if (lo(Te, 2)) return J(Jn({
                    replace: M
                }, $(Te.to), {
                    state: typeof Te.to == "object" ? Jn({}, Se, Te.to.state) : Se,
                    force: Ke
                }), ye || fe)
            } else Te = ne(fe, ze, !0, M, Se);
            return Q(fe, ze, Te), Te
        })
    }

    function xe(de, ye) {
        const oe = w(de, ye);
        return oe ? Promise.reject(oe) : Promise.resolve()
    }

    function he(de) {
        const ye = mt.values().next().value;
        return ye && typeof ye.runWithContext == "function" ? ye.runWithContext(de) : de()
    }

    function me(de, ye) {
        let oe;
        const [ze, Se, Ke] = VD(de, ye);
        oe = ff(ze.reverse(), "beforeRouteLeave", de, ye);
        for (const I of ze) I.leaveGuards.forEach(fe => {
            oe.push(Fo(fe, de, ye))
        });
        const M = xe.bind(null, de, ye);
        return oe.push(M), St(oe).then(() => {
            oe = [];
            for (const I of s.list()) oe.push(Fo(I, de, ye));
            return oe.push(M), St(oe)
        }).then(() => {
            oe = ff(Se, "beforeRouteUpdate", de, ye);
            for (const I of Se) I.updateGuards.forEach(fe => {
                oe.push(Fo(fe, de, ye))
            });
            return oe.push(M), St(oe)
        }).then(() => {
            oe = [];
            for (const I of Ke)
                if (I.beforeEnter)
                    if (Ns(I.beforeEnter))
                        for (const fe of I.beforeEnter) oe.push(Fo(fe, de, ye));
                    else oe.push(Fo(I.beforeEnter, de, ye));
            return oe.push(M), St(oe)
        }).then(() => (de.matched.forEach(I => I.enterCallbacks = {}), oe = ff(Ke, "beforeRouteEnter", de, ye, he), oe.push(M), St(oe))).then(() => {
            oe = [];
            for (const I of a.list()) oe.push(Fo(I, de, ye));
            return oe.push(M), St(oe)
        }).catch(I => lo(I, 8) ? I : Promise.reject(I))
    }

    function Q(de, ye, oe) {
        c.list().forEach(ze => he(() => ze(de, ye, oe)))
    }

    function ne(de, ye, oe, ze, Se) {
        const Ke = w(de, ye);
        if (Ke) return Ke;
        const M = ye === ys,
            I = Ra ? history.state : {};
        oe && (ze || M ? i.replace(de.fullPath, Jn({
            scroll: M && I && I.scroll
        }, Se)) : i.push(de.fullPath, Se)), u.value = de, ht(de, ye, oe, M), tt()
    }
    let re;

    function K() {
        re || (re = i.listen((de, ye, oe) => {
            if (!Pt.listening) return;
            const ze = A(de),
                Se = X(ze);
            if (Se) {
                J(Jn(Se, {
                    replace: !0,
                    force: !0
                }), ze).catch(Il);
                return
            }
            p = ze;
            const Ke = u.value;
            Ra && fD(fp(Ke.fullPath, oe.delta), Ic()), me(ze, Ke).catch(M => lo(M, 12) ? M : lo(M, 2) ? (J(Jn($(M.to), {
                force: !0
            }), ze).then(I => {
                lo(I, 20) && !oe.delta && oe.type === Ql.pop && i.go(-1, !1)
            }).catch(Il), Promise.reject()) : (oe.delta && i.go(-oe.delta, !1), le(M, ze, Ke))).then(M => {
                M = M || ne(ze, Ke, !1), M && (oe.delta && !lo(M, 8) ? i.go(-oe.delta, !1) : oe.type === Ql.pop && lo(M, 20) && i.go(-1, !1)), Q(ze, Ke, M)
            }).catch(Il)
        }))
    }
    let te = dl(),
        G = dl(),
        ce;

    function le(de, ye, oe) {
        tt(de);
        const ze = G.list();
        return ze.length ? ze.forEach(Se => Se(de, ye, oe)) : console.error(de), Promise.reject(de)
    }

    function ve() {
        return ce && u.value !== ys ? Promise.resolve() : new Promise((de, ye) => {
            te.add([de, ye])
        })
    }

    function tt(de) {
        return ce || (ce = !de, K(), te.list().forEach(([ye, oe]) => de ? oe(de) : ye()), te.reset()), de
    }

    function ht(de, ye, oe, ze) {
        const {
            scrollBehavior: Se
        } = e;
        if (!Ra || !Se) return Promise.resolve();
        const Ke = !oe && hD(fp(de.fullPath, 0)) || (ze || !oe) && history.state && history.state.scroll || null;
        return ss().then(() => Se(de, ye, Ke)).then(M => M && cD(M)).catch(M => le(M, de, ye))
    }
    const lt = de => i.go(de);
    let _t;
    const mt = new Set,
        Pt = {
            currentRoute: u,
            listening: !0,
            addRoute: E,
            removeRoute: L,
            clearRoutes: t.clearRoutes,
            hasRoute: j,
            getRoutes: b,
            resolve: A,
            options: e,
            push: k,
            replace: S,
            go: lt,
            back: () => lt(-1),
            forward: () => lt(1),
            beforeEach: s.add,
            beforeResolve: a.add,
            afterEach: c.add,
            onError: G.add,
            isReady: ve,
            install(de) {
                const ye = this;
                de.component("RouterLink", ID), de.component("RouterView", $0), de.config.globalProperties.$router = ye, Object.defineProperty(de.config.globalProperties, "$route", {
                    enumerable: !0,
                    get: () => Kt(u)
                }), Ra && !_t && u.value === ys && (_t = !0, k(i.location).catch(Se => {}));
                const oe = {};
                for (const Se in ys) Object.defineProperty(oe, Se, {
                    get: () => u.value[Se],
                    enumerable: !0
                });
                de.provide(Nc, ye), de.provide(qh, Ms(oe)), de.provide(ih, u);
                const ze = de.unmount;
                mt.add(de), de.unmount = function() {
                    mt.delete(de), mt.size < 1 && (p = ys, re && re(), re = null, u.value = ys, _t = !1, ce = !1), ze()
                }
            }
        };

    function St(de) {
        return de.reduce((ye, oe) => ye.then(() => he(oe)), Promise.resolve())
    }
    return Pt
}

function VD(e, t) {
    const n = [],
        r = [],
        i = [],
        s = Math.max(t.matched.length, e.matched.length);
    for (let a = 0; a < s; a++) {
        const c = t.matched[a];
        c && (e.matched.find(p => Ga(p, c)) ? r.push(c) : n.push(c));
        const u = e.matched[a];
        u && (t.matched.find(p => Ga(p, u)) || i.push(u))
    }
    return [n, r, i]
}

function zD() {
    return Er(Nc)
}

function jD(e) {
    return Er(qh)
}
const UD = /(:\w+)\([^)]+\)/g,
    WD = /(:\w+)[?+*]/g,
    qD = /:\w+/g,
    GD = (e, t) => t.path.replace(UD, "$1").replace(WD, "$1").replace(qD, n => {
        var r;
        return ((r = e.params[n.slice(1)]) == null ? void 0 : r.toString()) || ""
    }),
    sh = (e, t) => {
        const n = e.route.matched.find(i => {
                var s;
                return ((s = i.components) == null ? void 0 : s.default) === e.Component.type
            }),
            r = t ?? (n == null ? void 0 : n.meta.key) ?? (n && GD(e.route, n));
        return typeof r == "function" ? r(e.route) : r
    },
    YD = (e, t) => ({
        default: () => e ? jr(by, e === !0 ? {} : e, t) : t
    });

function Gh(e) {
    return Array.isArray(e) ? e : [e]
}

// site-header
const ms = null,
    ku = {},
    hf = [{
        name: "about",
        path: "/about",
        component: () => Ht(() => import("./Cb4wYaKN.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]), import.meta.url)
    }, {
        name: "index",
        path: "/",
        component: () => Ht(() => import("./DyUXhHQ0.js"), __vite__mapDeps([20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21]), import.meta.url)
    }, {
        name: "press",
        path: "/press",
        component: () => Ht(() => import("./gHg1li4D.js"), __vite__mapDeps([22, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 23]), import.meta.url)
    }, {
        name: "config",
        path: "/config",
        component: () => Ht(() => import("./CqoGyOl6.js"), __vite__mapDeps([24, 25]), import.meta.url)
    }, {
        name: "system",
        path: "/system",
        component: () => Ht(() => import("./CkY6zwto.js"), __vite__mapDeps([26, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 27]), import.meta.url)
    }, {
        name: "careers",
        path: "/careers",
        component: () => Ht(() => import("./DXmqWGh7.js"), __vite__mapDeps([28, 29, 30, 31, 32, 33, 34, 35, 36, 11, 12, 37, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 17, 18, 38]), import.meta.url)
    }, {
        name: "contact",
        path: "/contact",
        component: () => Ht(() => import("./CrDfq5w8.js"), __vite__mapDeps([39, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 40]), import.meta.url)
    }, {
        name: "security",
        path: "/security",
        component: () => Ht(() => import("./Budg17VV.js"), __vite__mapDeps([41, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 42]), import.meta.url)
    }, {
        name: "slug",
        path: "/:slug(.*)*",
        component: () => Ht(() => import("./BVB8peBq.js"), __vite__mapDeps([43, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]), import.meta.url)
    }, {
        name: "blog-slug",
        path: "/blog/:slug()",
        component: () => Ht(() => import("./B8MigvAX.js"), __vite__mapDeps([44, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18]), import.meta.url)
    }, {
        name: "privacy-policy",
        path: "/privacy-policy",
        component: () => Ht(() => import("./BKgq3HUB.js"), __vite__mapDeps([45, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 46]), import.meta.url)
    }, {
        name: "terms-of-service",
        path: "/terms-of-service",
        component: () => Ht(() => import("./Cg9iJPL1.js"), __vite__mapDeps([47, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 48]), import.meta.url)
    }, {
        name: ms == null ? void 0 : ms.name,
        path: "/home",
        component: ku
    }, {
        name: ms == null ? void 0 : ms.name,
        path: "/global/*",
        component: ku
    }, {
        name: ms == null ? void 0 : ms.name,
        path: "/authors/*",
        component: ku
    }, {
        name: ms == null ? void 0 : ms.name,
        path: "/clipboard",
        component: ku
    }],
    H0 = (e, t) => ({
        default: () => {
            var n;
            return e ? jr(v1, e === !0 ? {} : e, t) : (n = t.default) == null ? void 0 : n.call(t)
        }
    }),
    XD = /(:\w+)\([^)]+\)/g,
    KD = /(:\w+)[?+*]/g,
    QD = /:\w+/g;

function Sp(e) {
    const t = (e == null ? void 0 : e.meta.key) ?? e.path.replace(XD, "$1").replace(KD, "$1").replace(QD, n => {
        var r;
        return ((r = e.params[n.slice(1)]) == null ? void 0 : r.toString()) || ""
    });
    return typeof t == "function" ? t(e) : t
}

function JD(e, t) {
    return e === t || t === ys ? !1 : Sp(e) !== Sp(t) ? !0 : !e.matched.every((r, i) => {
        var s, a;
        return r.components && r.components.default === ((a = (s = t.matched[i]) == null ? void 0 : s.components) == null ? void 0 : a.default)
    })
}
const ZD = {
    scrollBehavior(e, t, n) {
        var u;
        const r = vr(),
            i = ((u = Qi().options) == null ? void 0 : u.scrollBehaviorType) ?? "auto";
        if (e.path === t.path) return t.hash && !e.hash ? {
            left: 0,
            top: 0
        } : e.hash ? {
            el: e.hash,
            top: V0(e.hash),
            behavior: i
        } : !1;
        if ((typeof e.meta.scrollToTop == "function" ? e.meta.scrollToTop(e, t) : e.meta.scrollToTop) === !1) return !1;
        let a = n || void 0;
        !a && JD(e, t) && (a = {
            left: 0,
            top: 0
        });
        const c = r._runningTransition ? "page:transition:finish" : "page:loading:end";
        return new Promise(p => {
            if (t === ys) {
                p(Tp(e, "instant", a));
                return
            }
            r.hooks.hookOnce(c, () => {
                requestAnimationFrame(() => p(Tp(e, "instant", a)))
            })
        })
    }
};

function V0(e) {
    try {
        const t = document.querySelector(e);
        if (t) return (Number.parseFloat(getComputedStyle(t).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle(document.documentElement).scrollPaddingTop) || 0)
    } catch {}
    return 0
}

function Tp(e, t, n) {
    return n || (e.hash ? {
        el: e.hash,
        top: V0(e.hash),
        behavior: t
    } : {
        left: 0,
        top: 0,
        behavior: t
    })
}
const ex = {
        hashMode: !1,
        scrollBehaviorType: "auto"
    },
    qs = {
        ...ex,
        ...ZD
    },
    tx = async (e, t) => {
        var a;
        let n, r;
        if (!((a = e.meta) != null && a.validate)) return;
        const i = ([n, r] = Va(() => Promise.resolve(e.meta.validate(e))), n = await n, r(), n);
        if (i === !0) return;
        const s = Bo({
            fatal: !0,
            statusCode: i && i.statusCode || 404,
            statusMessage: i && i.statusMessage || `Page Not Found: ${e.fullPath}`,
            data: {
                path: e.fullPath
            }
        });
        return typeof window < "u" && window.history.pushState({}, "", t.fullPath), s
    }, nx = async e => {
        let t, n;
        const r = ([t, n] = Va(() => jh({
            path: e.path
        })), t = await t, n(), t);
        if (r.redirect) return Qs(r.redirect, {
            acceptRelative: !0
        }) ? (window.location.href = r.redirect, !1) : r.redirect
    }, rx = [tx, nx], Bl = {};

function ix(e, t, n) {
    const {
        pathname: r,
        search: i,
        hash: s
    } = t, a = e.indexOf("#");
    if (a > -1) {
        const p = s.includes(e.slice(a)) ? e.slice(a).length : 1;
        let d = s.slice(p);
        return d[0] !== "/" && (d = "/" + d), Vd(d, "")
    }
    const c = Vd(r, e),
        u = !n || Av(c, n) ? c : n;
    return u + (u.includes("?") ? "" : i) + s
}
const sx = Di({
        name: "nuxt:router",
        enforce: "pre",
        async setup(e) {
            var j;
            let t, n, r = Bs().app.baseURL;
            const i = ((j = qs.history) == null ? void 0 : j.call(qs, r)) ?? _D(r),
                s = qs.routes ? ([t, n] = Va(() => qs.routes(hf)), t = await t, n(), t ?? hf) : hf;
            let a;
            const c = HD({
                ...qs,
                scrollBehavior: (A, $, w) => {
                    if ($ === ys) {
                        a = w;
                        return
                    }
                    if (qs.scrollBehavior) {
                        if (c.options.scrollBehavior = qs.scrollBehavior, "scrollRestoration" in window.history) {
                            const k = c.beforeEach(() => {
                                k(), window.history.scrollRestoration = "manual"
                            })
                        }
                        return qs.scrollBehavior(A, ys, a || w)
                    }
                },
                history: i,
                routes: s
            });
            "scrollRestoration" in window.history && (window.history.scrollRestoration = "auto"), e.vueApp.use(c);
            const u = Ur(c.currentRoute.value);
            c.afterEach((A, $) => {
                u.value = $
            }), Object.defineProperty(e.vueApp.config.globalProperties, "previousRoute", {
                get: () => u.value
            });
            const p = ix(r, window.location, e.payload.path),
                d = Ur(c.currentRoute.value),
                g = () => {
                    d.value = c.currentRoute.value
                };
            e.hook("page:finish", g), c.afterEach((A, $) => {
                var w, k, S, X;
                ((k = (w = A.matched[0]) == null ? void 0 : w.components) == null ? void 0 : k.default) === ((X = (S = $.matched[0]) == null ? void 0 : S.components) == null ? void 0 : X.default) && g()
            });
            const m = {};
            for (const A in d.value) Object.defineProperty(m, A, {
                get: () => d.value[A],
                enumerable: !0
            });
            e._route = Ms(m), e._middleware || (e._middleware = {
                global: [],
                named: {}
            });
            const E = Lc();
            c.afterEach(async (A, $, w) => {
                delete e._processingMiddleware, !e.isHydrating && E.value && await e.runWithContext(Tb), w && await e.callHook("page:loading:end")
            });
            try {
                [t, n] = Va(() => c.isReady()), await t, n()
            } catch (A) {
                [t, n] = Va(() => e.runWithContext(() => ua(A))), await t, n()
            }
            const L = p !== c.currentRoute.value.fullPath ? c.resolve(p) : c.currentRoute.value;
            g();
            const b = e.payload.state._layout;
            return c.beforeEach(async (A, $) => {
                var w;
                await e.callHook("page:loading:start"), A.meta = mi(A.meta), e.isHydrating && b && !Ho(A.meta.layout) && (A.meta.layout = b), e._processingMiddleware = !0;
                {
                    const k = new Set([...rx, ...e._middleware.global]);
                    for (const S of A.matched) {
                        const X = S.meta.middleware;
                        if (X)
                            for (const J of Gh(X)) k.add(J)
                    } {
                        const S = await e.runWithContext(() => jh({
                            path: A.path
                        }));
                        if (S.appMiddleware)
                            for (const X in S.appMiddleware) S.appMiddleware[X] ? k.add(X) : k.delete(X)
                    }
                    for (const S of k) {
                        const X = typeof S == "string" ? e._middleware.named[S] || await ((w = Bl[S]) == null ? void 0 : w.call(Bl).then(J => J.default || J)) : S;
                        if (!X) throw new Error(`Unknown route middleware: '${S}'.`);
                        try {
                            const J = await e.runWithContext(() => X(A, $));
                            if (!e.payload.serverRendered && e.isHydrating && (J === !1 || J instanceof Error)) {
                                const xe = J || Bo({
                                    statusCode: 404,
                                    statusMessage: `Page Not Found: ${p}`
                                });
                                return await e.runWithContext(() => ua(xe)), !1
                            }
                            if (J === !0) continue;
                            if (J === !1) return J;
                            if (J) return u0(J) && J.fatal && await e.runWithContext(() => ua(J)), J
                        } catch (J) {
                            const xe = Bo(J);
                            return xe.fatal && await e.runWithContext(() => ua(xe)), xe
                        }
                    }
                }
            }), c.onError(async () => {
                delete e._processingMiddleware, await e.callHook("page:loading:end")
            }), c.afterEach(async (A, $) => {
                A.matched.length === 0 && await e.runWithContext(() => ua(Bo({
                    statusCode: 404,
                    fatal: !1,
                    statusMessage: `Page not found: ${A.fullPath}`,
                    data: {
                        path: A.fullPath
                    }
                })))
            }), e.hooks.hookOnce("app:created", async () => {
                try {
                    "name" in L && (L.name = void 0), await c.replace({
                        ...L,
                        force: !0
                    }), c.options.scrollBehavior = qs.scrollBehavior
                } catch (A) {
                    await e.runWithContext(() => ua(A))
                }
            }), {
                provide: {
                    router: c
                }
            }
        }
    }),
    z0 = Symbol.for("nuxt:client-only"),
    yP = Jr({
        name: "ClientOnly",
        inheritAttrs: !1,
        props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"],
        setup(e, {
            slots: t,
            attrs: n
        }) {
            const r = kn(!1);
            $i(() => {
                r.value = !0
            });
            const i = wi();
            return i && (i._nuxtClientOnly = !0), ws(z0, !0), s => {
                var p;
                if (r.value) return (p = t.default) == null ? void 0 : p.call(t);
                const a = t.fallback || t.placeholder;
                if (a) return a();
                const c = s.fallback || s.placeholder || "",
                    u = s.fallbackTag || s.placeholderTag || "span";
                return Br(u, n, c)
            }
        }
    }),
    oh = globalThis.requestIdleCallback || (e => {
        const t = Date.now(),
            n = {
                didTimeout: !1,
                timeRemaining: () => Math.max(0, 50 - (Date.now() - t))
            };
        return setTimeout(() => {
            e(n)
        }, 1)
    }),
    ox = globalThis.cancelIdleCallback || (e => {
        clearTimeout(e)
    }),
    au = e => {
        const t = vr();
        t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", () => {
            oh(() => e())
        }) : oh(() => e())
    },
    ax = e => e === "defer" || e === !1;

function lx(...e) {
    var b;
    const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0;
    typeof e[0] != "string" && typeof e[0] != "object" && !(typeof e[0] == "function" && typeof e[1] == "function") && e.unshift(t);
    let [n, r, i = {}] = e;
    const s = xn(() => pa(n));
    if (typeof s.value != "string") throw new TypeError("[nuxt] [useAsyncData] key must be a string.");
    if (typeof r != "function") throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");
    const a = vr(),
        c = () => Ks.value,
        u = (j, A, $) => {
            if (A.isHydrating) return A.payload.data[j];
            if ($.cause !== "refresh:manual" && $.cause !== "refresh:hook") return A.static.data[j]
        };
    i.server ?? (i.server = !0), i.default ?? (i.default = c), i.getCachedData ?? (i.getCachedData = u), i.lazy ?? (i.lazy = !1), i.immediate ?? (i.immediate = !0), i.deep ?? (i.deep = Ks.deep), i.dedupe ?? (i.dedupe = "cancel"), i._functionName, a._asyncData[s.value];
    const p = i.getCachedData(s.value, a, {
        cause: "initial"
    });
    (b = a._asyncData[s.value]) != null && b._init || (a._asyncData[s.value] = Pp(a, s.value, r, i, p));
    const d = a._asyncData[s.value];
    d._deps++;
    const g = () => a._asyncData[s.value].execute({
            cause: "initial",
            dedupe: i.dedupe
        }),
        m = i.server !== !1 && a.payload.serverRendered;
    {
        let j = function(S) {
            const X = a._asyncData[S];
            X != null && X._deps && (X._deps--, X._deps === 0 && (X == null || X._off(), X._init = !1, ah(a, S), X.execute = () => Promise.resolve(), a._asyncData[S].data.value = Ks.value))
        };
        const A = wi();
        if (A && m && i.immediate && !A.sp && (A.sp = []), A && !A._nuxtOnBeforeMountCbs) {
            A._nuxtOnBeforeMountCbs = [];
            const S = A._nuxtOnBeforeMountCbs;
            Wg(() => {
                S.forEach(X => {
                    X()
                }), S.splice(0, S.length)
            }), Pc(() => S.splice(0, S.length))
        }
        const $ = A && (A._nuxtClientOnly || Er(z0, !1));
        m && a.isHydrating && (d.error.value || p != null) ? (d.pending.value = !1, d.status.value = d.error.value ? "error" : "success") : A && !$ && (a.payload.serverRendered && a.isHydrating || i.lazy) && i.immediate ? A._nuxtOnBeforeMountCbs.push(g) : i.immediate && g();
        const w = Uo();
        if (i.watch) {
            const S = Qr(i.watch, () => {
                d._execute({
                    cause: "watch",
                    dedupe: i.dedupe
                })
            }, {
                flush: "post"
            });
            w && fs(() => S())
        }
        const k = Qr(s, (S, X) => {
            var xe, he;
            const J = ((xe = a._asyncData[X]) == null ? void 0 : xe.data.value) !== Ks.value;
            X && j(X), (he = a._asyncData[S]) != null && he._init || (a._asyncData[S] = Pp(a, S, r, i, i.getCachedData(S, a, {
                cause: "initial"
            }))), a._asyncData[S]._deps++, (i.immediate || J) && a._asyncData[S].execute({
                cause: "initial",
                dedupe: i.dedupe
            })
        }, {
            flush: "sync"
        });
        w && fs(() => {
            k(), j(s.value)
        })
    }
    const E = {
            data: Au(() => {
                var j;
                return (j = a._asyncData[s.value]) == null ? void 0 : j.data
            }),
            pending: Au(() => {
                var j;
                return (j = a._asyncData[s.value]) == null ? void 0 : j.pending
            }),
            status: Au(() => {
                var j;
                return (j = a._asyncData[s.value]) == null ? void 0 : j.status
            }),
            error: Au(() => {
                var j;
                return (j = a._asyncData[s.value]) == null ? void 0 : j.error
            }),
            refresh: (...j) => a._asyncData[s.value].execute(...j),
            execute: (...j) => a._asyncData[s.value].execute(...j),
            clear: () => ah(a, s.value)
        },
        L = Promise.resolve(a._asyncDataPromises[s.value]).then(() => E);
    return Object.assign(L, E), L
}

function Au(e) {
    return xn({
        get() {
            var t;
            return (t = e()) == null ? void 0 : t.value
        },
        set(t) {
            const n = e();
            n && (n.value = t)
        }
    })
}

function ux(e) {
    const t = vr();
    if (e in t.payload.data || (t.payload.data[e] = Ks.value), t._asyncData[e]) {
        const n = t._asyncData[e];
        n._deps++, Uo() && fs(() => {
            n._deps--, n._deps === 0 && (n == null || n._off(), n._init = !1, ah(t, e))
        })
    }
    return {
        data: xn({
            get() {
                var n;
                return ((n = t._asyncData[e]) == null ? void 0 : n.data.value) ?? t.payload.data[e]
            },
            set(n) {
                t._asyncData[e] ? t._asyncData[e].data.value = n : t.payload.data[e] = n
            }
        })
    }
}

function ah(e, t) {
    t in e.payload.data && (e.payload.data[t] = void 0), t in e.payload._errors && (e.payload._errors[t] = Ks.errorValue), e._asyncData[t] && (e._asyncData[t].data.value = void 0, e._asyncData[t].error.value = Ks.errorValue, e._asyncData[t].pending.value = !1, e._asyncData[t].status.value = "idle"), t in e._asyncDataPromises && (e._asyncDataPromises[t] && (e._asyncDataPromises[t].cancelled = !0), e._asyncDataPromises[t] = void 0)
}

function cx(e, t) {
    const n = {};
    for (const r of t) n[r] = e[r];
    return n
}

function Pp(e, t, n, r, i) {
    var p;
    (p = e.payload._errors)[t] ?? (p[t] = Ks.errorValue);
    const s = n,
        a = r.deep ? kn : Ur,
        c = i != null,
        u = {
            data: a(c ? i : r.default()),
            pending: Ur(!c),
            error: Na(e.payload._errors, t),
            status: Ur("idle"),
            execute: (d = {}) => {
                if (e._asyncDataPromises[t]) {
                    if (ax(d.dedupe ?? r.dedupe)) return e._asyncDataPromises[t];
                    e._asyncDataPromises[t].cancelled = !0
                }
                if (d.cause === "initial" || e.isHydrating) {
                    const m = d.cause === "initial" ? i : r.getCachedData(t, e, {
                        cause: d.cause ?? "refresh:manual"
                    });
                    if (m != null) return e.payload.data[t] = u.data.value = m, u.error.value = Ks.errorValue, u.status.value = "success", Promise.resolve(m)
                }
                u.pending.value = !0, u.status.value = "pending";
                const g = new Promise((m, E) => {
                    try {
                        m(s(e))
                    } catch (L) {
                        E(L)
                    }
                }).then(async m => {
                    if (g.cancelled) return e._asyncDataPromises[t];
                    let E = m;
                    r.transform && (E = await r.transform(m)), r.pick && (E = cx(E, r.pick)), e.payload.data[t] = E, u.data.value = E, u.error.value = Ks.errorValue, u.status.value = "success"
                }).catch(m => {
                    if (g.cancelled) return e._asyncDataPromises[t];
                    u.error.value = Bo(m), u.data.value = Kt(r.default()), u.status.value = "error"
                }).finally(() => {
                    g.cancelled || (u.pending.value = !1, delete e._asyncDataPromises[t])
                });
                return e._asyncDataPromises[t] = g, e._asyncDataPromises[t]
            },
            _execute: kb((...d) => u.execute(...d), 0, {
                leading: !0
            }),
            _default: r.default,
            _deps: 0,
            _init: !0,
            _hash: void 0,
            _off: e.hook("app:data:refresh", async d => {
                (!d || d.includes(t)) && await u.execute({
                    cause: "refresh:hook"
                })
            })
        };
    return u
}
const fx = "$s";

function hx(...e) {
    const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0;
    typeof e[0] != "string" && e.unshift(t);
    const [n, r] = e;
    if (!n || typeof n != "string") throw new TypeError("[nuxt] [useState] key must be a string: " + n);
    if (r !== void 0 && typeof r != "function") throw new Error("[nuxt] [useState] init must be a function: " + r);
    const i = fx + n,
        s = vr(),
        a = Na(s.payload.state, i);
    if (a.value === void 0 && r) {
        const c = r();
        if (mr(c)) return s.payload.state[i] = c, c;
        a.value = c
    }
    return a
}
async function j0(e, t = Qi()) {
    const {
        path: n,
        matched: r
    } = t.resolve(e);
    if (!r.length || (t._routePreloaded || (t._routePreloaded = new Set), t._routePreloaded.has(n))) return;
    const i = t._preloadPromises || (t._preloadPromises = []);
    if (i.length > 4) return Promise.all(i).then(() => j0(e, t));
    t._routePreloaded.add(n);
    const s = r.map(a => {
        var c;
        return (c = a.components) == null ? void 0 : c.default
    }).filter(a => typeof a == "function");
    for (const a of s) {
        const c = Promise.resolve(a()).catch(() => {}).finally(() => i.splice(i.indexOf(c)));
        i.push(c)
    }
    await Promise.all(i)
}

function dx(e = {}) {
    const t = e.path || window.location.pathname;
    let n = {};
    try {
        n = oc(sessionStorage.getItem("nuxt:reload") || "{}")
    } catch {}
    if (e.force || (n == null ? void 0 : n.path) !== t || (n == null ? void 0 : n.expires) < Date.now()) {
        try {
            sessionStorage.setItem("nuxt:reload", JSON.stringify({
                path: t,
                expires: Date.now() + (e.ttl ?? 1e4)
            }))
        } catch {}
        if (e.persistState) try {
            sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
                state: vr().payload.state
            }))
        } catch {}
        window.location.pathname !== t ? window.location.href = t : window.location.reload()
    }
}
const px = (...e) => e.find(t => t !== void 0);

function gx(e) {
    const t = e.componentName || "NuxtLink";

    function n(s) {
        return typeof s == "string" && s.startsWith("#")
    }

    function r(s, a, c) {
        const u = c ?? e.trailingSlash;
        if (!s || u !== "append" && u !== "remove") return s;
        if (typeof s == "string") return Ru(s, u);
        const p = "path" in s && s.path !== void 0 ? s.path : a(s).path;
        return {
            ...s,
            name: void 0,
            path: Ru(p, u)
        }
    }

    function i(s) {
        const a = Qi(),
            c = Bs(),
            u = xn(() => !!s.target && s.target !== "_self"),
            p = xn(() => {
                const j = s.to || s.href || "";
                return typeof j == "string" && Qs(j, {
                    acceptRelative: !0
                })
            }),
            d = cd("RouterLink"),
            g = d && typeof d != "string" ? d.useLink : void 0,
            m = xn(() => {
                if (s.external) return !0;
                const j = s.to || s.href || "";
                return typeof j == "object" ? !1 : j === "" || p.value
            }),
            E = xn(() => {
                const j = s.to || s.href || "";
                return m.value ? j : r(j, a.resolve, s.trailingSlash)
            }),
            L = m.value || g == null ? void 0 : g({
                ...s,
                to: E
            }),
            b = xn(() => {
                var A;
                const j = s.trailingSlash ?? e.trailingSlash;
                if (!E.value || p.value || n(E.value)) return E.value;
                if (m.value) {
                    const $ = typeof E.value == "object" && "path" in E.value ? Kf(E.value) : E.value,
                        w = typeof $ == "object" ? a.resolve($).href : $;
                    return Ru(w, j)
                }
                return typeof E.value == "object" ? ((A = a.resolve(E.value)) == null ? void 0 : A.href) ?? null : Ru(Rc(c.app.baseURL, E.value), j)
            });
        return {
            to: E,
            hasTarget: u,
            isAbsoluteUrl: p,
            isExternal: m,
            href: b,
            isActive: (L == null ? void 0 : L.isActive) ?? xn(() => E.value === a.currentRoute.value.path),
            isExactActive: (L == null ? void 0 : L.isExactActive) ?? xn(() => E.value === a.currentRoute.value.path),
            route: (L == null ? void 0 : L.route) ?? xn(() => a.resolve(E.value)),
            async navigate(j) {
                await Sb(b.value, {
                    replace: s.replace,
                    external: m.value || u.value
                })
            }
        }
    }
    return Jr({
        name: t,
        props: {
            to: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            href: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            target: {
                type: String,
                default: void 0,
                required: !1
            },
            rel: {
                type: String,
                default: void 0,
                required: !1
            },
            noRel: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            prefetch: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            prefetchOn: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            noPrefetch: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            activeClass: {
                type: String,
                default: void 0,
                required: !1
            },
            exactActiveClass: {
                type: String,
                default: void 0,
                required: !1
            },
            prefetchedClass: {
                type: String,
                default: void 0,
                required: !1
            },
            replace: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            ariaCurrentValue: {
                type: String,
                default: void 0,
                required: !1
            },
            external: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            custom: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            trailingSlash: {
                type: String,
                default: void 0,
                required: !1
            }
        },
        useLink: i,
        setup(s, {
            slots: a
        }) {
            const c = Qi(),
                {
                    to: u,
                    href: p,
                    navigate: d,
                    isExternal: g,
                    hasTarget: m,
                    isAbsoluteUrl: E
                } = i(s),
                L = kn(!1),
                b = kn(null),
                j = w => {
                    var k;
                    b.value = s.custom ? (k = w == null ? void 0 : w.$el) == null ? void 0 : k.nextElementSibling : w == null ? void 0 : w.$el
                };

            function A(w) {
                var k, S;
                return !L.value && (typeof s.prefetchOn == "string" ? s.prefetchOn === w : ((k = s.prefetchOn) == null ? void 0 : k[w]) ?? ((S = e.prefetchOn) == null ? void 0 : S[w])) && (s.prefetch ?? e.prefetch) !== !1 && s.noPrefetch !== !0 && s.target !== "_blank" && !vx()
            }
            async function $(w = vr()) {
                if (L.value) return;
                L.value = !0;
                const k = typeof u.value == "string" ? u.value : g.value ? Kf(u.value) : c.resolve(u.value).fullPath,
                    S = g.value ? new URL(k, window.location.href).href : k;
                await Promise.all([w.hooks.callHook("link:prefetch", S).catch(() => {}), !g.value && !m.value && j0(u.value, c).catch(() => {})])
            }
            if (A("visibility")) {
                const w = vr();
                let k, S = null;
                $i(() => {
                    const X = mx();
                    au(() => {
                        k = oh(() => {
                            var J;
                            (J = b == null ? void 0 : b.value) != null && J.tagName && (S = X.observe(b.value, async () => {
                                S == null || S(), S = null, await $(w)
                            }))
                        })
                    })
                }), va(() => {
                    k && ox(k), S == null || S(), S = null
                })
            }
            return () => {
                var S;
                if (!g.value && !m.value && !n(u.value)) {
                    const X = {
                        ref: j,
                        to: u.value,
                        activeClass: s.activeClass || e.activeClass,
                        exactActiveClass: s.exactActiveClass || e.exactActiveClass,
                        replace: s.replace,
                        ariaCurrentValue: s.ariaCurrentValue,
                        custom: s.custom
                    };
                    return s.custom || (A("interaction") && (X.onPointerenter = $.bind(null, void 0), X.onFocus = $.bind(null, void 0)), L.value && (X.class = s.prefetchedClass || e.prefetchedClass), X.rel = s.rel || void 0), jr(cd("RouterLink"), X, a.default)
                }
                const w = s.target || null,
                    k = px(s.noRel ? "" : s.rel, e.externalRelAttribute, E.value || m.value ? "noopener noreferrer" : "") || null;
                return s.custom ? a.default ? a.default({
                    href: p.value,
                    navigate: d,
                    prefetch: $,
                    get route() {
                        if (!p.value) return;
                        const X = new URL(p.value, window.location.href);
                        return {
                            path: X.pathname,
                            fullPath: X.pathname,
                            get query() {
                                return Bh(X.search)
                            },
                            hash: X.hash,
                            params: {},
                            name: void 0,
                            matched: [],
                            redirectedFrom: void 0,
                            meta: {},
                            href: p.value
                        }
                    },
                    rel: k,
                    target: w,
                    isExternal: g.value || m.value,
                    isActive: !1,
                    isExactActive: !1
                }) : null : jr("a", {
                    ref: b,
                    href: p.value || null,
                    rel: k,
                    target: w
                }, (S = a.default) == null ? void 0 : S.call(a))
            }
        }
    })
}
const _x = gx(lb);

function Ru(e, t) {
    const n = t === "append" ? q_ : qa;
    return Qs(e) && !e.startsWith("http") ? e : n(e, !0)
}

function mx() {
    const e = vr();
    if (e._observer) return e._observer;
    let t = null;
    const n = new Map,
        r = (s, a) => (t || (t = new IntersectionObserver(c => {
            for (const u of c) {
                const p = n.get(u.target);
                (u.isIntersecting || u.intersectionRatio > 0) && p && p()
            }
        })), n.set(s, a), t.observe(s), () => {
            n.delete(s), t == null || t.unobserve(s), n.size === 0 && (t == null || t.disconnect(), t = null)
        });
    return e._observer = {
        observe: r
    }
}
const yx = /2g/;

function vx() {
    const e = navigator.connection;
    return !!(e && (e.saveData || yx.test(e.effectiveType)))
}

function bx(e) {
    typeof e.indexable < "u" && (e.indexable = String(e.indexable) !== "false"), typeof e.trailingSlash < "u" && !e.trailingSlash && (e.trailingSlash = String(e.trailingSlash) !== "false"), e.url && !Qs(String(e.url), {
        acceptRelative: !0,
        strict: !1
    }) && (e.url = Pv(String(e.url)));
    const t = Object.keys(e).sort((r, i) => r.localeCompare(i)),
        n = {};
    for (const r of t) n[r] = e[r];
    return n
}

function wx(e) {
    const n = [];

    function r(s) {
        if (!s || typeof s != "object" || Object.keys(s).length === 0) return () => {};
        s._context;
        const a = {};
        for (const u in s) {
            const p = s[u];
            typeof p < "u" && p !== "" && (a[u] = p)
        }
        let c;
        return Object.keys(a).filter(u => !u.startsWith("_")).length > 0 && (c = n.push(a)), () => {
            typeof c < "u" && n.splice(c - 1, 1)
        }
    }

    function i(s) {
        var c;
        const a = {};
        s != null && s.debug && (a._context = {}), a._priority = {};
        for (const u in n.sort((p, d) => (p._priority || 0) - (d._priority || 0)))
            for (const p in n[u]) {
                const d = p,
                    g = s != null && s.resolveRefs ? pa(n[u][p]) : n[u][p];
                !p.startsWith("_") && typeof g < "u" && g !== "" && (a[p] = g, typeof n[u]._priority < "u" && n[u]._priority !== -1 && (a._priority[d] = n[u]._priority), s != null && s.debug && (a._context[d] = ((c = n[u]._context) == null ? void 0 : c[d]) || n[u]._context || "anonymous"))
            }
        return s != null && s.skipNormalize ? a : bx(a)
    }
    return {
        stack: n,
        push: r,
        get: i
    }
}
const Dx = Di({
        name: "nuxt-site-config:init",
        enforce: "pre",
        async setup(e) {
            var r;
            const t = wx(),
                n = hx("site-config");
            {
                const i = n.value || window.__NUXT_SITE_CONFIG__ || {};
                for (const s in i) s[0] !== "_" && t.push({
                    [s]: i[s],
                    _priority: ((r = i._priority) == null ? void 0 : r[s]) || -1
                })
            }
            return {
                provide: {
                    nuxtSiteConfig: t
                }
            }
        }
    }),
    xx = Di({
        name: "nuxt:payload",
        setup(e) {
            const t = new Set;
            Qi().beforeResolve(async (n, r) => {
                if (n.path === r.path) return;
                const i = await ap(n.path);
                if (i) {
                    for (const s of t) delete e.static.data[s];
                    for (const s in i.data) s in e.static.data || t.add(s), e.static.data[s] = i.data[s]
                }
            }), au(() => {
                var n;
                e.hooks.hook("link:prefetch", async r => {
                    const {
                        hostname: i
                    } = new URL(r, window.location.href);
                    i === window.location.hostname && await ap(r).catch(() => {
                        console.warn("[nuxt] Error preloading payload for", r)
                    })
                }), ((n = navigator.connection) == null ? void 0 : n.effectiveType) !== "slow-2g" && setTimeout(Fc, 1e3)
            })
        }
    }),
    Ex = Di(() => {
        const e = Qi();
        au(() => {
            e.beforeResolve(async () => {
                await new Promise(t => {
                    setTimeout(t, 100), requestAnimationFrame(() => {
                        setTimeout(t, 0)
                    })
                })
            })
        })
    }),
    Cx = Di(e => {
        let t;
        async function n() {
            const r = await Fc();
            t && clearTimeout(t), t = setTimeout(n, Gd);
            try {
                const i = await $fetch($h("builds/latest.json") + `?${Date.now()}`);
                i.id !== r.id && e.hooks.callHook("app:manifest:update", i)
            } catch {}
        }
        au(() => {
            t = setTimeout(n, Gd)
        })
    }),
    Sx = Di({
        name: "nuxt:chunk-reload",
        setup(e) {
            const t = Qi(),
                n = Bs(),
                r = new Set;
            t.beforeEach(() => {
                r.clear()
            }), e.hook("app:chunkError", ({
                error: s
            }) => {
                r.add(s)
            });

            function i(s) {
                const c = "href" in s && s.href[0] === "#" ? n.app.baseURL + s.href : Rc(n.app.baseURL, s.fullPath);
                dx({
                    path: c,
                    persistState: !0
                })
            }
            e.hook("app:manifest:update", () => {
                t.beforeResolve(i)
            }), t.onError((s, a) => {
                r.has(s) && i(a)
            })
        }
    });

function Tx(e = {}) {
    const t = [];
    let n = -1;
    const r = (i = !1) => ({
        get(s, a, c) {
            if (!i) {
                const u = Reflect.get(s, a, c);
                if (typeof u < "u") return u;
                n++, t[n] = []
            }
            return t[n].push({
                type: "get",
                key: a
            }), new Proxy(() => {}, r(!0))
        },
        apply(s, a, c) {
            t[n].push({
                type: "apply",
                key: "",
                args: c
            })
        }
    });
    return {
        proxy: new Proxy(e || {}, r()),
        stack: t
    }
}

function Px(e) {
    const t = {
        get(n, r, i) {
            const s = Reflect.get(n, r, i);
            return typeof s == "object" ? new Proxy(s, t) : s
        },
        apply(n, r, i) {
            Reflect.apply(n, r, i)
        }
    };
    return new Proxy(e, t)
}

function kx(e, t) {
    t.forEach(n => {
        let r = e,
            i = e;
        n.forEach(({
            type: s,
            key: a,
            args: c
        }) => {
            s === "get" ? (i = r, r = r[a]) : s === "apply" && (r = r.call(i, ...c))
        })
    })
}

function Ax(e) {
    return e.key || e.src || (typeof e.innerHTML == "string" ? e.innerHTML : "")
}
const Rx = ["preconnect", "dns-prefetch"];

function Ox(e, t, n) {
    var L, b, j;
    const r = typeof t == "string" ? {
            src: t
        } : t,
        i = n || {},
        s = Ax(r),
        a = (L = e._scripts) == null ? void 0 : L[s];
    if (a) return a.setupTriggerHandler(i.trigger), a;
    (b = i.beforeInit) == null || b.call(i);
    const c = A => {
        m.status = A, e.hooks.callHook("script:updated", E)
    };
    Pw.forEach(A => {
        const $ = A,
            w = typeof r[$] == "function" ? r[$].bind(i.eventContext) : null;
        r[$] = k => {
            c(A === "onload" ? "loaded" : A === "onerror" ? "error" : "loading"), w == null || w(k)
        }
    });
    const u = {
            loaded: [],
            error: []
        },
        p = new Set,
        d = (A, $, w) => {
            if (!e.ssr) {
                if (w != null && w.key) {
                    const k = `${w==null?void 0:w.key}:${w.key}`;
                    if (p.has(k)) return;
                    p.add(k)
                }
                if (u[A]) {
                    const k = u[A].push($);
                    return () => {
                        var S;
                        return (S = u[A]) == null ? void 0 : S.splice(k - 1, 1)
                    }
                }
                return $(m.instance), () => {}
            }
        },
        g = new Promise(A => {
            if (e.ssr) return;
            const $ = k => requestAnimationFrame(() => A(k)),
                w = e.hooks.hook("script:updated", ({
                    script: k
                }) => {
                    const S = k.status;
                    if (k.id === s && (S === "loaded" || S === "error")) {
                        if (S === "loaded")
                            if (typeof i.use == "function") {
                                const X = i.use();
                                X && $(X)
                            } else $({});
                        else S === "error" && A(!1);
                        w()
                    }
                })
        }),
        m = {
            _loadPromise: g,
            instance: !e.ssr && ((j = i == null ? void 0 : i.use) == null ? void 0 : j.call(i)) || null,
            proxy: null,
            id: s,
            status: "awaitingLoad",
            remove() {
                var A, $, w;
                return (A = m._triggerAbortController) == null || A.abort(), m._triggerPromises = [], ($ = m._warmupEl) == null || $.dispose(), m.entry ? (m.entry.dispose(), m.entry = void 0, c("removed"), (w = e._scripts) == null || delete w[s], !0) : !1
            },
            warmup(A) {
                const {
                    src: $
                } = r, w = !$.startsWith("/") || $.startsWith("//"), k = A && Rx.includes(A);
                let S = $;
                if (!A || k && !w) return;
                if (k) {
                    const J = new URL($);
                    S = `${J.protocol}//${J.host}`
                }
                const X = {
                    href: S,
                    rel: A,
                    crossorigin: typeof r.crossorigin < "u" ? r.crossorigin : w ? "anonymous" : void 0,
                    referrerpolicy: typeof r.referrerpolicy < "u" ? r.referrerpolicy : w ? "no-referrer" : void 0,
                    fetchpriority: typeof r.fetchpriority < "u" ? r.fetchpriority : "low",
                    integrity: r.integrity,
                    as: A === "preload" ? "script" : void 0
                };
                return m._warmupEl = e.push({
                    link: [X]
                }, {
                    head: e,
                    tagPriority: "high"
                }), m._warmupEl
            },
            load(A) {
                var $;
                if (($ = m._triggerAbortController) == null || $.abort(), m._triggerPromises = [], !m.entry) {
                    c("loading");
                    const w = {
                        defer: !0,
                        fetchpriority: "low"
                    };
                    r.src && (r.src.startsWith("http") || r.src.startsWith("//")) && (w.crossorigin = "anonymous", w.referrerpolicy = "no-referrer"), m.entry = e.push({
                        script: [{
                            ...w,
                            ...r
                        }]
                    }, i)
                }
                return A && d("loaded", A), g
            },
            onLoaded(A, $) {
                return d("loaded", A, $)
            },
            onError(A, $) {
                return d("error", A, $)
            },
            setupTriggerHandler(A) {
                if (m.status === "awaitingLoad")
                    if ((typeof A > "u" || A === "client") && !e.ssr || A === "server") m.load();
                    else if (A instanceof Promise) {
                    if (e.ssr) return;
                    m._triggerAbortController || (m._triggerAbortController = new AbortController, m._triggerAbortPromise = new Promise(w => {
                        m._triggerAbortController.signal.addEventListener("abort", () => {
                            m._triggerAbortController = null, w()
                        })
                    })), m._triggerPromises = m._triggerPromises || [];
                    const $ = m._triggerPromises.push(Promise.race([A.then(w => typeof w > "u" || w ? m.load : void 0), m._triggerAbortPromise]).catch(() => {}).then(w => {
                        w == null || w()
                    }).finally(() => {
                        var w;
                        (w = m._triggerPromises) == null || w.splice($, 1)
                    }))
                } else typeof A == "function" && A(m.load)
            },
            _cbs: u
        };
    g.then(A => {
        var $, w;
        A !== !1 ? (m.instance = A, ($ = u.loaded) == null || $.forEach(k => k(A)), u.loaded = null) : ((w = u.error) == null || w.forEach(k => k()), u.error = null)
    });
    const E = {
        script: m
    };
    if (m.setupTriggerHandler(i.trigger), i.use) {
        const {
            proxy: A,
            stack: $
        } = Tx(e.ssr ? {} : i.use() || {});
        m.proxy = A, m.onLoaded(w => {
            kx(w, $), m.proxy = Px(w)
        })
    }
    return !i.warmupStrategy && (typeof i.trigger > "u" || i.trigger === "client") && (i.warmupStrategy = "preload"), i.warmupStrategy && m.warmup(i.warmupStrategy), e._scripts = Object.assign(e._scripts || {}, {
        [s]: m
    }), m
}
const Mx = "usehead";

function Lx() {
    if (Ja()) {
        const e = Er(Mx);
        if (!e) throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.");
        return e
    }
    throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.")
}

function Fx(e, t) {
    if (!t) return;
    const n = (r, i) => {
        if (!e._cbs[r]) return i(e.instance), () => {};
        let s = e._cbs[r].push(i);
        const a = () => {
            var c;
            s && ((c = e._cbs[r]) == null || c.splice(s - 1, 1), s = null)
        };
        return fs(a), a
    };
    e.onLoaded = r => n("loaded", r), e.onError = r => n("error", r), fs(() => {
        var r;
        (r = e._triggerAbortController) == null || r.abort()
    })
}

function Ix(e, t) {
    const n = typeof e == "string" ? {
            src: e
        } : e,
        r = t || {},
        i = (r == null ? void 0 : r.head) || Lx();
    r.head = i;
    const s = wi();
    if (r.eventContext = s, s && typeof r.trigger > "u") r.trigger = $i;
    else if (mr(r.trigger)) {
        const c = r.trigger;
        let u;
        r.trigger = new Promise(p => {
            u = Qr(c, d => {
                d && p(!0)
            }, {
                immediate: !0
            }), fs(() => p(!1), !0)
        }).then(p => (u == null || u(), p))
    }
    i._scriptStatusWatcher = i._scriptStatusWatcher || i.hooks.hook("script:updated", ({
        script: c
    }) => {
        c._statusRef.value = c.status
    });
    const a = Ox(i, n, r);
    return a._statusRef = a._statusRef || kn(a.status), Fx(a, s), new Proxy(a, {
        get(c, u, p) {
            return Reflect.get(c, u === "status" ? "_statusRef" : u, p)
        }
    })
}

function Nx() {
    return Bs().public["nuxt-scripts"]
}

function Bx(e) {
    return e.key || e.src || (typeof e.innerHTML == "string" ? e.innerHTML : "")
}

function $x(e, t) {
    var a, c;
    e = typeof e == "string" ? {
        src: e
    } : e, t = Oc(t, (a = Nx()) == null ? void 0 : a.defaultScriptOptions);
    const n = String(Bx(e)),
        r = vr();
    if (t.head = t.head || zh(), !t.head) throw new Error("useScript() has been called without Nuxt context.");
    r.$scripts = r.$scripts || mi({}), (c = r.$scripts) != null && c[n], (t.trigger === "onNuxtReady" || t.trigger === "client") && (t.warmupStrategy || (t.warmupStrategy = "preload"), t.trigger === "onNuxtReady" && (t.trigger = au));
    const i = Ix(e, t),
        s = i.remove;
    return i.remove = () => (r.$scripts[n] = void 0, s()), r.$scripts[n] = i, i
}
const Za = Object.freeze(Object.assign(() => {}, {
        __mock__: !0
    })),
    Hx = Za,
    aa = Za,
    df = Za,
    uo = Za,
    pf = Za,
    gf = Za;

function Vx(e) {
    return (Bs().public.scripts || {})[e]
}

function zx(e, t, n) {
    const r = Vx(e),
        i = Object.assign(n || {}, typeof r == "object" ? r : {}),
        s = t(i),
        a = Oc(i.scriptInput, s.scriptInput, {
            key: e
        }),
        c = Object.assign((i == null ? void 0 : i.scriptOptions) || {}, s.scriptOptions || {}),
        u = c.beforeInit;
    return c.beforeInit = () => {
        var p;
        u == null || u(), (p = s.clientInit) == null || p.call(s)
    }, $x(a, c)
}
Hx({
    id: aa(),
    l: uo(aa()),
    auth: uo(aa()),
    preview: uo(aa()),
    cookiesWin: uo(gf([df(), pf("x")])),
    debug: uo(gf([df(), pf("x")])),
    npa: uo(gf([df(), pf("1")])),
    dataLayer: uo(aa()),
    envName: uo(aa()),
    authReferrerPolicy: uo(aa())
});

function jx(e) {
    return zx((e == null ? void 0 : e.key) || "googleTagManager", t => {
        const n = (t == null ? void 0 : t.l) ?? (t == null ? void 0 : t.dataLayer) ?? "dataLayer";
        return {
            scriptInput: {
                src: Yl("https://www.googletagmanager.com/gtm.js", {
                    id: t.id,
                    l: t.l,
                    gtm_auth: t.auth,
                    gtm_preview: t.preview,
                    gtm_cookies_win: t.cookiesWin ? "x" : void 0,
                    gtm_debug: t.debug ? "x" : void 0,
                    gtm_npa: t.npa ? "1" : void 0,
                    gtm_data_layer: t.dataLayer,
                    gtm_env: t.envName,
                    gtm_auth_referrer_policy: t.authReferrerPolicy
                })
            },
            schema: void 0,
            scriptOptions: {
                use: () => ({
                    dataLayer: window[n],
                    google_tag_manager: window.google_tag_manager
                }),
                performanceMarkFeature: "nuxt-third-parties-gtm",
                tagPriority: 1
            },
            clientInit: () => {
                var i;
                window[n] = window[n] || [];

                function r(...s) {
                    window[n].push(s)
                }(i = e == null ? void 0 : e.onBeforeGtmStart) == null || i.call(e, r), window[n].push({
                    "gtm.start": new Date().getTime(),
                    event: "gtm.js"
                })
            }
        }
    }, e)
}
const Ux = Di({
        name: "scripts:init",
        env: {
            islands: !1
        },
        parallel: !0,
        setup() {
            return {
                provide: {
                    $scripts: {
                        googleTagManager: jx({
                            id: "GTM-NLZX33DL"
                        })
                    }
                }
            }
        }
    }),
    Wx = Di({
        name: "pinia",
        setup(e) {
            const t = Rb();
            return e.vueApp.use(t), ou(t), e.payload && e.payload.pinia && (t.state.value = e.payload.pinia), {
                provide: {
                    pinia: t
                }
            }
        }
    }),
    qx = Qt(() => Ht(() => Promise.resolve().then(() => s2), void 0, import.meta.url).then(e => e.default || e.default || e)),
    Gx = Qt(() => Ht(() => Promise.resolve().then(() => IT), void 0, import.meta.url).then(e => e.default || e.default || e)),
    Yx = Qt(() => Ht(() => import("./DiISNzl7.js"), __vite__mapDeps([11, 12]), import.meta.url).then(e => e.default || e.default || e)),
    Xx = Qt(() => Ht(() => import("./tbOjCnuf.js"), __vite__mapDeps([2, 3]), import.meta.url).then(e => e.default || e.default || e)),
    Kx = Qt(() => Ht(() => Promise.resolve().then(() => jS), void 0, import.meta.url).then(e => e.default || e.default || e)),
    Qx = Qt(() => Ht(() => import("./vERjyvrW.js"), __vite__mapDeps([33, 34]), import.meta.url).then(e => e.default || e.default || e)),
    Jx = Qt(() => Ht(() => import("./RkfjLTg0.js"), __vite__mapDeps([35, 36]), import.meta.url).then(e => e.default || e.default || e)),
    Zx = Qt(() => Ht(() => import("./aIp6R3HE.js"), __vite__mapDeps([49, 30, 35, 36, 50]), import.meta.url).then(e => e.default || e.default || e)),
    eE = Qt(() => Ht(() => import("./DltPStmS.js"), __vite__mapDeps([51, 52]), import.meta.url).then(e => e.default || e.default || e)),
    tE = Qt(() => Ht(() => import("./DIM6A6bD.js"), [], import.meta.url).then(e => e.default || e.default || e)),
    nE = Qt(() => Ht(() => Promise.resolve().then(() => VS), void 0, import.meta.url).then(e => e.default || e.default || e)),
    rE = Qt(() => Ht(() => import("./7i9ndGDa.js"), [], import.meta.url).then(e => e.default || e.default || e)),
    iE = Qt(() => Ht(() => import("./REf8v6gy.js"), __vite__mapDeps([53, 54, 5, 30, 55]), import.meta.url).then(e => e.default || e.default || e)),
    sE = Qt(() => Ht(() => import("./Bi-w0G5b.js"), [], import.meta.url).then(e => e.default || e.default || e)),
    oE = Qt(() => Ht(() => import("./BJxF2Pan.js"), __vite__mapDeps([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]), import.meta.url).then(e => e.default || e.default || e)),
    aE = Qt(() => Ht(() => Promise.resolve().then(() => lT), void 0, import.meta.url).then(e => e.default || e.default || e)),
    lE = Qt(() => Ht(() => import("./BfwGAPrn.js"), __vite__mapDeps([56, 35, 36, 57]), import.meta.url).then(e => e.default || e.default || e)),
    uE = Qt(() => Ht(() => import("./DH-1Q7yJ.js"), __vite__mapDeps([58, 59]), import.meta.url).then(e => e.default || e.default || e)),
    cE = Qt(() => Ht(() => import("./CuR2BBdh.js"), __vite__mapDeps([60, 61]), import.meta.url).then(e => e.default || e.default || e)),
    fE = Qt(() => Ht(() => import("./CSAUWnR2.js"), __vite__mapDeps([62, 33, 34, 35, 36, 53, 54, 5, 30, 55, 11, 12, 9, 10, 13, 14, 63]), import.meta.url).then(e => e.default || e.default || e)),
    hE = Qt(() => Ht(() => import("./K07fp1Ap.js").then(e => e.A), __vite__mapDeps([64, 56, 35, 36, 57, 4, 5, 49, 30, 50, 65, 66, 67, 68]), import.meta.url).then(e => e.default || e.default || e)),
    dE = Qt(() => Ht(() => import("./BUNtUlDr.js"), __vite__mapDeps([69, 53, 54, 5, 30, 55, 70, 71, 72]), import.meta.url).then(e => e.default || e.default || e)),
    pE = Qt(() => Ht(() => import("./DgAnreGg.js"), __vite__mapDeps([73, 6, 7, 8, 74]), import.meta.url).then(e => e.default || e.default || e)),
    gE = Qt(() => Ht(() => import("./CMvzZAs8.js"), __vite__mapDeps([75, 53, 54, 5, 30, 55, 35, 36, 6, 7, 8, 76]), import.meta.url).then(e => e.default || e.default || e)),
    _E = Qt(() => Ht(() => import("./B9gymHIf.js"), __vite__mapDeps([77, 6, 7, 8, 15, 78]), import.meta.url).then(e => e.default || e.default || e)),
    mE = Qt(() => Ht(() => import("./CDtgf0cK.js"), __vite__mapDeps([10, 11, 12, 13]), import.meta.url).then(e => e.default || e.default || e)),
    yE = Qt(() => Ht(() => import("./CuLQ2xRM.js"), __vite__mapDeps([79, 80]), import.meta.url).then(e => e.default || e.default || e)),
    vE = Qt(() => Ht(() => import("./CUin20Dn.js"), __vite__mapDeps([81, 53, 54, 5, 30, 55, 6, 7, 8, 82]), import.meta.url).then(e => e.default || e.default || e)),
    bE = Qt(() => Ht(() => import("./CY839viz.js"), __vite__mapDeps([83, 53, 54, 5, 30, 55, 35, 36, 70, 71, 84]), import.meta.url).then(e => e.default || e.default || e)),
    wE = Qt(() => Ht(() => import("./DiV6peeD.js"), __vite__mapDeps([85, 65, 66, 67, 86]), import.meta.url).then(e => e.default || e.default || e)),
    DE = Qt(() => Ht(() => import("./D8QKpbM8.js"), __vite__mapDeps([87, 88, 53, 54, 5, 30, 55, 35, 36, 89, 7, 15, 90]), import.meta.url).then(e => e.default || e.default || e)),
    xE = Qt(() => Ht(() => import("./SQ03s_T8.js"), __vite__mapDeps([91, 30, 88, 53, 54, 5, 55, 35, 36, 7, 15, 92]), import.meta.url).then(e => e.default || e.default || e)),
    EE = Qt(() => Ht(() => import("./BNXqlk-8.js"), __vite__mapDeps([93, 53, 54, 5, 30, 55, 60, 61, 35, 36, 9, 10, 11, 12, 13, 14, 94]), import.meta.url).then(e => e.default || e.default || e)),
    CE = Qt(() => Ht(() => import("./O9wTcfQ-.js"), __vite__mapDeps([95, 96, 97, 53, 54, 5, 30, 55, 9, 10, 11, 12, 13, 14, 89, 98]), import.meta.url).then(e => e.default || e.default || e)),
    SE = Qt(() => Ht(() => import("./Epde3gza.js"), __vite__mapDeps([99, 35, 36, 9, 10, 11, 12, 13, 14, 15, 7, 100]), import.meta.url).then(e => e.default || e.default || e)),
    TE = Qt(() => Ht(() => import("./CywgcAEJ.js"), __vite__mapDeps([101, 99, 35, 36, 9, 10, 11, 12, 13, 14, 15, 7, 100]), import.meta.url).then(e => e.default || e.default || e)),
    PE = Qt(() => Ht(() => import("./CezZK4Sj.js"), __vite__mapDeps([102, 53, 54, 5, 30, 55, 96, 97, 70, 71, 9, 10, 11, 12, 13, 14, 103]), import.meta.url).then(e => e.default || e.default || e)),
    kE = Qt(() => Ht(() => import("./75yDIck1.js"), __vite__mapDeps([104, 53, 54, 5, 30, 55, 70, 71, 105]), import.meta.url).then(e => e.default || e.default || e)),
    AE = Qt(() => Ht(() => import("./HzBEyAR6.js"), __vite__mapDeps([106, 107, 30, 108, 70, 71, 109, 110]), import.meta.url).then(e => e.default || e.default || e)),
    RE = Qt(() => Ht(() => import("./R75sOFzz.js"), __vite__mapDeps([111, 112, 29, 30, 31, 53, 54, 5, 55, 35, 36, 89, 88, 67, 113]), import.meta.url).then(e => e.default || e.default || e)),
    OE = Qt(() => Ht(() => import("./BQHk-wu6.js"), __vite__mapDeps([114, 107, 30, 108, 115]), import.meta.url).then(e => e.default || e.default || e)),
    ME = Qt(() => Ht(() => import("./AmwY7etT.js"), __vite__mapDeps([116, 33, 34, 54, 5, 11, 12, 117]), import.meta.url).then(e => e.default || e.default || e)),
    LE = Qt(() => Ht(() => import("./B5ylfTjW.js").then(e => e.N), __vite__mapDeps([112, 29, 30, 31, 53, 54, 5, 55, 35, 36, 89, 88, 67, 113]), import.meta.url).then(e => e.default || e.default || e)),
    FE = Qt(() => Ht(() => import("./1u1MFduc.js"), __vite__mapDeps([118, 107, 30, 108, 4, 5, 56, 35, 36, 57, 49, 50, 9, 10, 11, 12, 13, 14, 112, 29, 31, 53, 54, 55, 89, 88, 67, 113, 119, 6, 7, 8, 70, 71, 15, 120, 121]), import.meta.url).then(e => e.default || e.default || e)),
    IE = Qt(() => Ht(() => import("./Cr_E8Qix.js"), __vite__mapDeps([122, 35, 36, 32, 33, 34, 11, 12, 37, 123]), import.meta.url).then(e => e.default || e.default || e)),
    NE = Qt(() => Ht(() => import("./Ceg0M1cG.js"), __vite__mapDeps([124, 107, 30, 108, 7, 15, 125]), import.meta.url).then(e => e.default || e.default || e)),
    BE = Qt(() => Ht(() => import("./De6l7h9o.js"), __vite__mapDeps([126, 53, 54, 5, 30, 55, 70, 71, 127]), import.meta.url).then(e => e.default || e.default || e)),
    $E = Qt(() => Ht(() => import("./CBNTcaav.js"), __vite__mapDeps([128, 6, 7, 8, 107, 30, 108, 129]), import.meta.url).then(e => e.default || e.default || e)),
    HE = Qt(() => Ht(() => import("./CIuVaXvz.js"), __vite__mapDeps([119, 6, 7, 8, 53, 54, 5, 30, 55, 107, 108, 35, 36, 70, 71, 15, 120]), import.meta.url).then(e => e.default || e.default || e)),
    VE = Qt(() => Ht(() => import("./D4WxWABM.js"), __vite__mapDeps([130, 6, 7, 8, 53, 54, 5, 30, 55, 70, 71, 15, 35, 36, 131]), import.meta.url).then(e => e.default || e.default || e)),
    zE = Qt(() => Ht(() => import("./CVXjVMRE.js"), __vite__mapDeps([132, 70, 71, 133]), import.meta.url).then(e => e.default || e.default || e)),
    jE = Qt(() => Ht(() => import("./CV3AvXfp.js"), __vite__mapDeps([134, 135, 136, 96, 97, 9, 10, 11, 12, 13, 14, 137]), import.meta.url).then(e => e.default || e.default || e)),
    UE = Qt(() => Ht(() => import("./Dw9hZgUs.js"), __vite__mapDeps([138, 53, 54, 5, 30, 55, 70, 71, 35, 36, 139]), import.meta.url).then(e => e.default || e.default || e)),
    WE = Qt(() => Ht(() => import("./BN2tpE7T.js"), __vite__mapDeps([140, 35, 36, 53, 54, 5, 30, 55, 9, 10, 11, 12, 13, 14, 7, 15, 141]), import.meta.url).then(e => e.default || e.default || e)),
    qE = Qt(() => Ht(() => import("./DbX3hBKO.js"), [], import.meta.url).then(e => e.default || e.default || e)),
    GE = Qt(() => Ht(() => import("./CDegGHr3.js"), __vite__mapDeps([142, 15, 7, 143]), import.meta.url).then(e => e.default || e.default || e)),
    YE = Qt(() => Ht(() => import("./CnAtRxFS.js"), __vite__mapDeps([144, 135, 136, 145]), import.meta.url).then(e => e.default || e.default || e)),
    XE = Qt(() => Ht(() => import("./DsfgKBdb.js"), __vite__mapDeps([146, 107, 30, 108, 70, 71, 109, 147]), import.meta.url).then(e => e.default || e.default || e)),
    KE = [
        ["AppLoader", qx],
        ["AppTransition", Gx],
        ["BorderHover", Yx],
        ["ButtonTilt", Xx],
        ["Container", Kx],
        ["CrossFlicker", Qx],
        ["DSButton", Jx],
        ["DSDropdownButton", Zx],
        ["DesignGrid", eE],
        ["Logo", tE],
        ["LogoLettering", nE],
        ["LogoOutline", rE],
        ["Media", iE],
        ["RichTextParagraph", sE],
        ["SiteFooter", oE],
        ["SiteHeader", aE],
        ["TagButtonList", lE],
        ["TextReveal", uE],
        ["TextRevealChar", cE],
        ["AboutLeaders", fE],
        ["AllResources", hE],
        ["BigImageWithContent", dE],
        ["BigText", pE],
        ["CaseStudy", gE],
        ["ComparisonTable", _E],
        ["ContentExpander", mE],
        ["ContentExpanderStandAlone", yE],
        ["ExpandableFeatureCards", vE],
        ["FeatureSection", bE],
        ["FeaturedBlogPosts", wE],
        ["FeaturesCarousel", DE],
        ["FeaturesCarouselExpandable", xE],
        ["FeaturesGrid", EE],
        ["FeaturesSteps", CE],
        ["FormBuilder", SE],
        ["FormReference", TE],
        ["FullscreenFeatures", PE],
        ["HeroImage", kE],
        ["InfoSection", AE],
        ["LatestNews", RE],
        ["LinksList", OE],
        ["LogoGrid", ME],
        ["NewsSection", LE],
        ["Post", FE],
        ["PressSection", IE],
        ["ProofPoints", NE],
        ["Quote", BE],
        ["ResultsSection", $E],
        ["SectionIntroduction", HE],
        ["SectionsGrid", VE],
        ["SeparatorNotch", zE],
        ["SolutionsFeatures", jE],
        ["SolutionsFull", UE],
        ["SolutionsValue", WE],
        ["StoryblokPage", qE],
        ["TabbedAccordion", GE],
        ["VideoCarousel", YE],
        ["YOSSection", XE]
    ],
    QE = Di({
        name: "nuxt:global-components",
        setup(e) {
            for (const [t, n] of KE) e.vueApp.component(t, n), e.vueApp.component("Lazy" + t, n)
        }
    }),
    Io = {
        default: Qt(() => Ht(() => import("./BxLGiDcZ.js"), __vite__mapDeps([148, 149]), import.meta.url).then(e => e.default || e))
    },
    JE = Di({
        name: "nuxt:prefetch",
        setup(e) {
            const t = Qi();
            e.hooks.hook("app:mounted", () => {
                t.beforeEach(async n => {
                    var i;
                    const r = (i = n == null ? void 0 : n.meta) == null ? void 0 : i.layout;
                    r && typeof Io[r] == "function" && await Io[r]()
                })
            }), e.hooks.hook("link:prefetch", n => {
                if (Qs(n)) return;
                const r = t.resolve(n);
                if (!r) return;
                const i = r.meta.layout;
                let s = Gh(r.meta.middleware);
                s = s.filter(a => typeof a == "string");
                for (const a of s) typeof Bl[a] == "function" && Bl[a]();
                i && typeof Io[i] == "function" && Io[i]()
            })
        }
    });

function _f(...e) {
    var t;
    (t = window.dataLayer) == null || t.push(arguments)
}

function ZE({
    tags: e
}) {
    window.dataLayer = window.dataLayer || [];
    for (const t of e)
        for (const n of t.initCommands ?? []) _f(...n);
    _f("js", new Date);
    for (const t of e) _f("config", t.id, t.config ?? {})
}

function eC(e) {
    const t = Bn(e),
        n = t.tags.filter(Boolean).map(r => typeof r == "string" ? {
            id: r
        } : r);
    if (t.id) {
        const {
            id: r,
            config: i,
            initCommands: s
        } = t;
        n.unshift({
            id: r,
            config: i,
            initCommands: s
        })
    }
    return n
}
const tC = Di({
    parallel: !0,
    setup() {
        const e = Bs().public.gtag,
            t = eC(e);
        if (!t.length || (ZE({
                tags: t
            }), e.initMode === "manual")) return;
        const n = e.loadingStrategy === "async" ? "async" : "defer";
        D0({
            link: [{
                rel: "preload",
                as: "script",
                href: Yl(e.url, {
                    id: t[0].id
                })
            }],
            script: [{
                src: Yl(e.url, {
                    id: t[0].id
                }),
                [n]: !0,
                "data-gtag": ""
            }]
        })
    }
});

function nC(e, t) {
    if (!t) return {
        src: e,
        attrs: {}
    };
    let n = 0,
        r = 0;
    const i = {},
        s = [];

    function a(u, p, d, g, m) {
        typeof u != "number" || u <= p || u >= d ? console.warn(`[StoryblokRichText] - ${g.charAt(0).toUpperCase()+g.slice(1)} value must be a number between ${p} and ${d} (inclusive)`) : m.push(`${g}(${u})`)
    }
    if (typeof t == "object") {
        if (typeof t.width == "number" && t.width > 0 ? (i.width = t.width, n = t.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than 0"), t.height && typeof t.height == "number" && t.height > 0 ? (i.height = t.height, r = t.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than 0"), t.loading && ["lazy", "eager"].includes(t.loading) && (i.loading = t.loading), t.class && (i.class = t.class), t.filters) {
            const {
                filters: u
            } = t || {}, {
                blur: p,
                brightness: d,
                fill: g,
                format: m,
                grayscale: E,
                quality: L,
                rotate: b
            } = u || {};
            p && a(p, 0, 100, "blur", s), L && a(L, 0, 100, "quality", s), d && a(d, 0, 100, "brightness", s), g && s.push(`fill(${g})`), E && s.push("grayscale()"), b && [0, 90, 180, 270].includes(t.filters.rotate || 0) && s.push(`rotate(${b})`), m && ["webp", "png", "jpeg"].includes(m) && s.push(`format(${m})`)
        }
        t.srcset && (i.srcset = t.srcset.map(u => {
            if (typeof u == "number") return `${e}/m/${u}x0/${s.length>0?`filters:${s.join(":")}`:""} ${u}w`;
            if (Array.isArray(u) && u.length === 2) {
                const [p, d] = u;
                return `${e}/m/${p}x${d}/${s.length>0?`filters:${s.join(":")}`:""} ${p}w`
            } else {
                console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
                return
            }
        }).join(", ")), t.sizes && (i.sizes = t.sizes.join(", "))
    }
    let c = `${e}/m/`;
    return n > 0 && r > 0 && (c = `${c}${n}x${r}/`), s.length > 0 && (c = `${c}filters:${s.join(":")}`), {
        src: c,
        attrs: i
    }
}
var hi = (e => (e.DOCUMENT = "doc", e.HEADING = "heading", e.PARAGRAPH = "paragraph", e.QUOTE = "blockquote", e.OL_LIST = "ordered_list", e.UL_LIST = "bullet_list", e.LIST_ITEM = "list_item", e.CODE_BLOCK = "code_block", e.HR = "horizontal_rule", e.BR = "hard_break", e.IMAGE = "image", e.EMOJI = "emoji", e.COMPONENT = "blok", e.TABLE = "table", e.TABLE_ROW = "tableRow", e.TABLE_CELL = "tableCell", e.TABLE_HEADER = "tableHeader", e))(hi || {}),
    us = (e => (e.BOLD = "bold", e.STRONG = "strong", e.STRIKE = "strike", e.UNDERLINE = "underline", e.ITALIC = "italic", e.CODE = "code", e.LINK = "link", e.ANCHOR = "anchor", e.STYLED = "styled", e.SUPERSCRIPT = "superscript", e.SUBSCRIPT = "subscript", e.TEXT_STYLE = "textStyle", e.HIGHLIGHT = "highlight", e))(us || {}),
    U0 = (e => (e.TEXT = "text", e))(U0 || {}),
    ml = (e => (e.URL = "url", e.STORY = "story", e.ASSET = "asset", e.EMAIL = "email", e))(ml || {});
const rC = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"],
    iC = (e = {}) => Object.keys(e).map(t => `${t}="${e[t]}"`).join(" "),
    sC = (e = {}) => Object.keys(e).map(t => `${t}: ${e[t]}`).join("; ");

function oC(e) {
    return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;")
}
const Ou = e => Object.fromEntries(Object.entries(e).filter(([t, n]) => n !== void 0));

function kp(e, t = {}, n) {
    const r = iC(t),
        i = r ? `${e} ${r}` : e,
        s = Array.isArray(n) ? n.join("") : n || "";
    if (e) {
        if (rC.includes(e)) return `<${i}>`
    } else return s;
    return `<${i}>${s}</${e}>`
}

function aC(e = {}) {
    const t = new Map,
        {
            renderFn: n = kp,
            textFn: r = oC,
            resolvers: i = {},
            optimizeImages: s = !1,
            keyedResolvers: a = !1
        } = e,
        c = n !== kp,
        u = Q => (ne, re) => {
            const K = ne.attrs || {};
            return re.render(Q, K, ne.children || null)
        },
        p = (Q, ne) => {
            const {
                src: re,
                alt: K,
                title: te,
                srcset: G,
                sizes: ce
            } = Q.attrs || {};
            let le = re,
                ve = {};
            if (s) {
                const {
                    src: ht,
                    attrs: lt
                } = nC(re, s);
                le = ht, ve = lt
            }
            const tt = {
                src: le,
                alt: K,
                title: te,
                srcset: G,
                sizes: ce,
                ...ve
            };
            return ne.render("img", Ou(tt))
        },
        d = (Q, ne) => {
            const {
                level: re,
                ...K
            } = Q.attrs || {};
            return ne.render(`h${re}`, K, Q.children)
        },
        g = (Q, ne) => {
            var re, K, te, G;
            const ce = ne.render("img", {
                src: (re = Q.attrs) == null ? void 0 : re.fallbackImage,
                alt: (K = Q.attrs) == null ? void 0 : K.alt,
                style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
                draggable: "false",
                loading: "lazy"
            });
            return ne.render("span", {
                "data-type": "emoji",
                "data-name": (te = Q.attrs) == null ? void 0 : te.name,
                "data-emoji": (G = Q.attrs) == null ? void 0 : G.emoji
            }, ce)
        },
        m = (Q, ne) => ne.render("pre", Q.attrs || {}, ne.render("code", {}, Q.children || "")),
        E = (Q, ne = !1) => ({
            text: re,
            attrs: K
        }, te) => {
            const {
                class: G,
                id: ce,
                ...le
            } = K || {}, ve = ne ? {
                class: G,
                id: ce,
                style: sC(le) || void 0
            } : K || {};
            return te.render(Q, Ou(ve), re)
        },
        L = Q => me(Q),
        b = Q => {
            const {
                marks: ne,
                ...re
            } = Q;
            if ("text" in Q) {
                if (ne) return ne.reduce((te, G) => L({
                    ...G,
                    text: te
                }), L({
                    ...re,
                    children: re.children
                }));
                const K = Q.attrs || {};
                if (a) {
                    const te = t.get("txt") || 0;
                    t.set("txt", te + 1), K.key = `txt-${te}`
                }
                return r(re.text, K)
            }
            return ""
        },
        j = (Q, ne) => {
            const {
                linktype: re,
                href: K,
                anchor: te,
                ...G
            } = Q.attrs || {};
            let ce = "";
            switch (re) {
                case ml.ASSET:
                case ml.URL:
                    ce = K;
                    break;
                case ml.EMAIL:
                    ce = `mailto:${K}`;
                    break;
                case ml.STORY:
                    ce = K, te && (ce = `${ce}#${te}`);
                    break;
                default:
                    ce = K;
                    break
            }
            const le = {
                ...G
            };
            return ce && (le.href = ce), ne.render("a", le, Q.text)
        },
        A = (Q, ne) => {
            var re, K;
            return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"), ne.render("span", {
                blok: (re = Q == null ? void 0 : Q.attrs) == null ? void 0 : re.body[0],
                id: (K = Q.attrs) == null ? void 0 : K.id,
                style: "display: none"
            })
        },
        $ = (Q, ne) => {
            const re = {},
                K = ne.render("tbody", {}, Q.children);
            return ne.render("table", re, K)
        },
        w = (Q, ne) => {
            const re = {};
            return ne.render("tr", re, Q.children)
        },
        k = (Q, ne) => {
            const {
                colspan: re,
                rowspan: K,
                colwidth: te,
                backgroundColor: G,
                ...ce
            } = Q.attrs || {}, le = {
                ...ce
            };
            re > 1 && (le.colspan = re), K > 1 && (le.rowspan = K);
            const ve = [];
            return te && ve.push(`width: ${te}px;`), G && ve.push(`background-color: ${G};`), ve.length > 0 && (le.style = ve.join(" ")), ne.render("td", Ou(le), Q.children)
        },
        S = (Q, ne) => {
            const {
                colspan: re,
                rowspan: K,
                colwidth: te,
                backgroundColor: G,
                ...ce
            } = Q.attrs || {}, le = {
                ...ce
            };
            re > 1 && (le.colspan = re), K > 1 && (le.rowspan = K);
            const ve = [];
            return te && ve.push(`width: ${te}px;`), G && ve.push(`background-color: ${G};`), ve.length > 0 && (le.style = ve.join(" ")), ne.render("th", Ou(le), Q.children)
        },
        X = new Map([
            [hi.DOCUMENT, u("")],
            [hi.HEADING, d],
            [hi.PARAGRAPH, u("p")],
            [hi.UL_LIST, u("ul")],
            [hi.OL_LIST, u("ol")],
            [hi.LIST_ITEM, u("li")],
            [hi.IMAGE, p],
            [hi.EMOJI, g],
            [hi.CODE_BLOCK, m],
            [hi.HR, u("hr")],
            [hi.BR, u("br")],
            [hi.QUOTE, u("blockquote")],
            [hi.COMPONENT, A],
            [U0.TEXT, b],
            [us.LINK, j],
            [us.ANCHOR, j],
            [us.STYLED, E("span", !0)],
            [us.BOLD, E("strong")],
            [us.TEXT_STYLE, E("span", !0)],
            [us.ITALIC, E("em")],
            [us.UNDERLINE, E("u")],
            [us.STRIKE, E("s")],
            [us.CODE, E("code")],
            [us.SUPERSCRIPT, E("sup")],
            [us.SUBSCRIPT, E("sub")],
            [us.HIGHLIGHT, E("mark")],
            [hi.TABLE, $],
            [hi.TABLE_ROW, w],
            [hi.TABLE_CELL, k],
            [hi.TABLE_HEADER, S]
        ]),
        J = new Map([...X, ...Object.entries(i).map(([Q, ne]) => [Q, ne])]),
        xe = () => ({
            render: (Q, ne = {}, re) => {
                if (a && Q) {
                    const K = t.get(Q) || 0;
                    t.set(Q, K + 1), ne.key = `${Q}-${K}`
                }
                return n(Q, ne, re)
            },
            originalResolvers: X,
            mergedResolvers: J
        });

    function he(Q) {
        const ne = J.get(Q.type);
        if (!ne) return console.error("<Storyblok>", `No resolver found for node type ${Q.type}`), "";
        const re = xe();
        if (Q.type === "text") return ne(Q, re);
        const K = Q.content ? Q.content.map(me) : void 0;
        return ne({
            ...Q,
            children: K
        }, re)
    }

    function me(Q) {
        return Q.type === "doc" ? c ? Q.content.map(he) : Q.content.map(he).join("") : Array.isArray(Q) ? Q.map(he) : he(Q)
    }
    return {
        render: me
    }
}
let Ap = !1;
const Rp = [],
    lC = e => new Promise((t, n) => {
        if (typeof window > "u") {
            n(new Error("Cannot load Storyblok bridge: window is undefined (server-side environment)"));
            return
        }
        if (window.storyblokRegisterEvent = i => {
                if (window.location === window.parent.location) {
                    console.warn("You are not in Draft Mode or in the Visual Editor.");
                    return
                }
                Ap ? i() : Rp.push(i)
            }, document.getElementById("storyblok-javascript-bridge")) {
            t(void 0);
            return
        }
        const r = document.createElement("script");
        r.async = !0, r.src = e, r.id = "storyblok-javascript-bridge", r.onerror = i => n(i), r.onload = i => {
            Rp.forEach(s => s()), Ap = !0, t(i)
        }, document.getElementsByTagName("head")[0].appendChild(r)
    });
var uC = Object.defineProperty,
    cC = (e, t, n) => t in e ? uC(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    Nr = (e, t, n) => cC(e, typeof t != "symbol" ? t + "" : t, n);
class fC extends Error {
    constructor(t) {
        super(t), this.name = "AbortError"
    }
}

function hC(e, t, n) {
    if (!Number.isFinite(t)) throw new TypeError("Expected `limit` to be a finite number");
    if (!Number.isFinite(n)) throw new TypeError("Expected `interval` to be a finite number");
    const r = [];
    let i = [],
        s = 0,
        a = !1;
    const c = async () => {
        s++;
        const p = r.shift();
        if (p) try {
            const g = await e(...p.args);
            p.resolve(g)
        } catch (g) {
            p.reject(g)
        }
        const d = setTimeout(() => {
            s--, r.length > 0 && c(), i = i.filter(g => g !== d)
        }, n);
        i.includes(d) || i.push(d)
    }, u = (...p) => a ? Promise.reject(new Error("Throttled function is already aborted and not accepting new promises")) : new Promise((d, g) => {
        r.push({
            resolve: d,
            reject: g,
            args: p
        }), s < t && c()
    });
    return u.abort = () => {
        a = !0, i.forEach(clearTimeout), i = [], r.forEach(p => p.reject(() => new fC("Throttle function aborted"))), r.length = 0
    }, u
}
const dC = (e = "") => e.includes("/cdn/"),
    pC = (e, t = 25, n = 1) => ({
        ...e,
        per_page: t,
        page: n
    }),
    gC = e => new Promise(t => setTimeout(t, e)),
    _C = (e = 0, t) => Array.from({
        length: e
    }, t),
    mC = (e = 0, t = e) => {
        const n = Math.abs(t - e) || 0,
            r = e < t ? 1 : -1;
        return _C(n, (i, s) => s * r + e)
    },
    yC = async (e, t) => Promise.all(e.map(t)), vC = (e = [], t) => e.map(t).reduce((n, r) => [...n, ...r], []), Yh = (e, t, n) => {
        const r = [];
        for (const i in e) {
            if (!Object.prototype.hasOwnProperty.call(e, i)) continue;
            const s = e[i];
            if (s == null) continue;
            const a = n ? "" : encodeURIComponent(i);
            let c;
            typeof s == "object" ? c = Yh(s, t ? t + encodeURIComponent(`[${a}]`) : a, Array.isArray(s)) : c = `${t?t+encodeURIComponent(`[${a}]`):a}=${encodeURIComponent(s)}`, r.push(c)
        }
        return r.join("&")
    }, Op = e => {
        const t = {
            eu: "api.storyblok.com",
            us: "api-us.storyblok.com",
            cn: "app.storyblokchina.cn",
            ap: "api-ap.storyblok.com",
            ca: "api-ca.storyblok.com"
        };
        return t[e] ?? t.eu
    };
class bC {
    constructor(t) {
        Nr(this, "baseURL"), Nr(this, "timeout"), Nr(this, "headers"), Nr(this, "responseInterceptor"), Nr(this, "fetch"), Nr(this, "ejectInterceptor"), Nr(this, "url"), Nr(this, "parameters"), Nr(this, "fetchOptions"), this.baseURL = t.baseURL, this.headers = t.headers || new Headers, this.timeout = t != null && t.timeout ? t.timeout * 1e3 : 0, this.responseInterceptor = t.responseInterceptor, this.fetch = (...n) => t.fetch ? t.fetch(...n) : fetch(...n), this.ejectInterceptor = !1, this.url = "", this.parameters = {}, this.fetchOptions = {}
    }
    get(t, n) {
        return this.url = t, this.parameters = n, this._methodHandler("get")
    }
    post(t, n) {
        return this.url = t, this.parameters = n, this._methodHandler("post")
    }
    put(t, n) {
        return this.url = t, this.parameters = n, this._methodHandler("put")
    }
    delete(t, n) {
        return this.url = t, this.parameters = n ?? {}, this._methodHandler("delete")
    }
    async _responseHandler(t) {
        const n = [],
            r = {
                data: {},
                headers: {},
                status: 0,
                statusText: ""
            };
        t.status !== 204 && await t.json().then(i => {
            r.data = i
        });
        for (const i of t.headers.entries()) n[i[0]] = i[1];
        return r.headers = {
            ...n
        }, r.status = t.status, r.statusText = t.statusText, r
    }
    async _methodHandler(t) {
        let n = `${this.baseURL}${this.url}`,
            r = null;
        t === "get" ? n = `${this.baseURL}${this.url}?${Yh(this.parameters)}` : r = JSON.stringify(this.parameters);
        const i = new URL(n),
            s = new AbortController,
            {
                signal: a
            } = s;
        let c;
        this.timeout && (c = setTimeout(() => s.abort(), this.timeout));
        try {
            const u = await this.fetch(`${i}`, {
                method: t,
                headers: this.headers,
                body: r,
                signal: a,
                ...this.fetchOptions
            });
            this.timeout && clearTimeout(c);
            const p = await this._responseHandler(u);
            return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(p)) : this._statusHandler(p)
        } catch (u) {
            return {
                message: u
            }
        }
    }
    setFetchOptions(t = {}) {
        Object.keys(t).length > 0 && "method" in t && delete t.method, this.fetchOptions = {
            ...t
        }
    }
    eject() {
        this.ejectInterceptor = !0
    }
    _normalizeErrorMessage(t) {
        if (Array.isArray(t)) return t[0] || "Unknown error";
        if (t && typeof t == "object") {
            if (t.error) return t.error;
            for (const n in t) {
                if (Array.isArray(t[n])) return `${n}: ${t[n][0]}`;
                if (typeof t[n] == "string") return `${n}: ${t[n]}`
            }
            if (t.slug) return t.slug
        }
        return "Unknown error"
    }
    _statusHandler(t) {
        const n = /20[0-6]/g;
        return new Promise((r, i) => {
            if (n.test(`${t.status}`)) return r(t);
            const s = {
                message: this._normalizeErrorMessage(t.data),
                status: t.status,
                response: t
            };
            i(s)
        })
    }
}
const Mp = "SB-Agent",
    mf = {
        defaultAgentName: "SB-JS-CLIENT",
        defaultAgentVersion: "SB-Agent-Version",
        packageVersion: "6.0.0"
    },
    wC = {
        DRAFT: "draft"
    };
let Mu = {};
const Eo = {};
class DC {
    constructor(t, n) {
        Nr(this, "client"), Nr(this, "maxRetries"), Nr(this, "retriesDelay"), Nr(this, "throttle"), Nr(this, "accessToken"), Nr(this, "cache"), Nr(this, "resolveCounter"), Nr(this, "relations"), Nr(this, "links"), Nr(this, "version"), Nr(this, "richTextResolver"), Nr(this, "resolveNestedRelations"), Nr(this, "stringifiedStoriesCache"), Nr(this, "inlineAssets");
        let r = t.endpoint || n;
        if (!r) {
            const a = t.https === !1 ? "http" : "https";
            t.oauthToken ? r = `${a}://${Op(t.region)}/v1` : r = `${a}://${Op(t.region)}/v2`
        }
        const i = new Headers;
        i.set("Content-Type", "application/json"), i.set("Accept", "application/json"), t.headers && (t.headers.constructor.name === "Headers" ? t.headers.entries().toArray() : Object.entries(t.headers)).forEach(([a, c]) => {
            i.set(a, c)
        }), i.has(Mp) || (i.set(Mp, mf.defaultAgentName), i.set(mf.defaultAgentVersion, mf.packageVersion));
        let s = 5;
        t.oauthToken && (i.set("Authorization", t.oauthToken), s = 3), t.rateLimit && (s = t.rateLimit), this.maxRetries = t.maxRetries || 10, this.retriesDelay = 300, this.throttle = hC(this.throttledRequest.bind(this), s, 1e3), this.accessToken = t.accessToken || "", this.relations = {}, this.links = {}, this.cache = t.cache || {
            clear: "manual"
        }, this.resolveCounter = 0, this.resolveNestedRelations = t.resolveNestedRelations || !0, this.stringifiedStoriesCache = {}, this.version = t.version || wC.DRAFT, this.inlineAssets = t.inlineAssets || !1, this.client = new bC({
            baseURL: r,
            timeout: t.timeout || 0,
            headers: i,
            responseInterceptor: t.responseInterceptor,
            fetch: t.fetch
        })
    }
    parseParams(t) {
        return t.token || (t.token = this.getToken()), t.cv || (t.cv = Eo[t.token]), Array.isArray(t.resolve_relations) && (t.resolve_relations = t.resolve_relations.join(",")), typeof t.resolve_relations < "u" && (t.resolve_level = 2), t
    }
    factoryParamOptions(t, n) {
        return dC(t) ? this.parseParams(n) : n
    }
    makeRequest(t, n, r, i, s) {
        const a = this.factoryParamOptions(t, pC(n, r, i));
        return this.cacheResponse(t, a, void 0, s)
    }
    get(t, n = {}, r) {
        n || (n = {});
        const i = `/${t}`;
        n.version = n.version || this.version;
        const s = this.factoryParamOptions(i, n);
        return this.cacheResponse(i, s, void 0, r)
    }
    async getAll(t, n = {}, r, i) {
        const s = (n == null ? void 0 : n.per_page) || 25,
            a = `/${t}`.replace(/\/$/, ""),
            c = r ?? a.substring(a.lastIndexOf("/") + 1);
        n.version = n.version || this.version;
        const u = 1,
            p = await this.makeRequest(a, n, s, u, i),
            d = p.total ? Math.ceil(p.total / s) : 1,
            g = await yC(mC(u, d), m => this.makeRequest(a, n, s, m + 1, i));
        return vC([p, ...g], m => Object.values(m.data[c]))
    }
    post(t, n = {}, r) {
        const i = `/${t}`;
        return this.throttle("post", i, n, r)
    }
    put(t, n = {}, r) {
        const i = `/${t}`;
        return this.throttle("put", i, n, r)
    }
    delete(t, n = {}, r) {
        n || (n = {});
        const i = `/${t}`;
        return this.throttle("delete", i, n, r)
    }
    getStories(t = {}, n) {
        return this._addResolveLevel(t), this.get("cdn/stories", t, n)
    }
    getStory(t, n = {}, r) {
        return this._addResolveLevel(n), this.get(`cdn/stories/${t}`, n, r)
    }
    getToken() {
        return this.accessToken
    }
    ejectInterceptor() {
        this.client.eject()
    }
    _addResolveLevel(t) {
        typeof t.resolve_relations < "u" && (t.resolve_level = 2)
    }
    _cleanCopy(t) {
        return JSON.parse(JSON.stringify(t))
    }
    _insertLinks(t, n, r) {
        const i = t[n];
        i && i.fieldtype === "multilink" && i.linktype === "story" && typeof i.id == "string" && this.links[r][i.id] ? i.story = this._cleanCopy(this.links[r][i.id]) : i && i.linktype === "story" && typeof i.uuid == "string" && this.links[r][i.uuid] && (i.story = this._cleanCopy(this.links[r][i.uuid]))
    }
    getStoryReference(t, n) {
        return this.relations[t][n] ? JSON.parse(this.stringifiedStoriesCache[n] || JSON.stringify(this.relations[t][n])) : n
    }
    _resolveField(t, n, r) {
        const i = t[n];
        typeof i == "string" ? t[n] = this.getStoryReference(r, i) : Array.isArray(i) && (t[n] = i.map(s => this.getStoryReference(r, s)).filter(Boolean))
    }
    _insertRelations(t, n, r, i) {
        if (Array.isArray(r) ? r.find(a => a.endsWith(`.${n}`)) : r.endsWith(`.${n}`)) {
            this._resolveField(t, n, i);
            return
        }
        const s = t.component ? `${t.component}.${n}` : n;
        (Array.isArray(r) ? r.includes(s) : r === s) && this._resolveField(t, n, i)
    }
    iterateTree(t, n, r) {
        const i = (s, a = "") => {
            if (!(!s || s._stopResolving)) {
                if (Array.isArray(s)) s.forEach((c, u) => i(c, `${a}[${u}]`));
                else if (typeof s == "object")
                    for (const c in s) {
                        const u = a ? `${a}.${c}` : c;
                        (s.component && s._uid || s.type === "link") && (this._insertRelations(s, c, n, r), this._insertLinks(s, c, r)), i(s[c], u)
                    }
            }
        };
        i(t.content)
    }
    async resolveLinks(t, n, r) {
        let i = [];
        if (t.link_uuids) {
            const s = t.link_uuids.length,
                a = [],
                c = 50;
            for (let u = 0; u < s; u += c) {
                const p = Math.min(s, u + c);
                a.push(t.link_uuids.slice(u, p))
            }
            for (let u = 0; u < a.length; u++)(await this.getStories({
                per_page: c,
                language: n.language,
                version: n.version,
                starts_with: n.starts_with,
                by_uuids: a[u].join(",")
            })).data.stories.forEach(p => {
                i.push(p)
            })
        } else i = t.links;
        i.forEach(s => {
            this.links[r][s.uuid] = {
                ...s,
                _stopResolving: !0
            }
        })
    }
    async resolveRelations(t, n, r) {
        let i = [];
        if (t.rel_uuids) {
            const s = t.rel_uuids.length,
                a = [],
                c = 50;
            for (let u = 0; u < s; u += c) {
                const p = Math.min(s, u + c);
                a.push(t.rel_uuids.slice(u, p))
            }
            for (let u = 0; u < a.length; u++)(await this.getStories({
                per_page: c,
                language: n.language,
                version: n.version,
                starts_with: n.starts_with,
                by_uuids: a[u].join(","),
                excluding_fields: n.excluding_fields
            })).data.stories.forEach(p => {
                i.push(p)
            });
            i.length > 0 && (t.rels = i, delete t.rel_uuids)
        } else i = t.rels;
        i && i.length > 0 && i.forEach(s => {
            this.relations[r][s.uuid] = {
                ...s,
                _stopResolving: !0
            }
        })
    }
    async resolveStories(t, n, r) {
        var i, s;
        let a = [];
        if (this.links[r] = {}, this.relations[r] = {}, typeof n.resolve_relations < "u" && n.resolve_relations.length > 0 && (typeof n.resolve_relations == "string" && (a = n.resolve_relations.split(",")), await this.resolveRelations(t, n, r)), n.resolve_links && ["1", "story", "url", "link"].includes(n.resolve_links) && ((i = t.links) != null && i.length || (s = t.link_uuids) != null && s.length) && await this.resolveLinks(t, n, r), this.resolveNestedRelations)
            for (const c in this.relations[r]) this.iterateTree(this.relations[r][c], a, r);
        t.story ? this.iterateTree(t.story, a, r) : t.stories.forEach(c => {
            this.iterateTree(c, a, r)
        }), this.stringifiedStoriesCache = {}, delete this.links[r], delete this.relations[r]
    }
    async cacheResponse(t, n, r, i) {
        const s = Yh({
                url: t,
                params: n
            }),
            a = this.cacheProvider();
        if (n.version === "published" && t !== "/cdn/spaces/me") {
            const c = await a.get(s);
            if (c) return Promise.resolve(c)
        }
        return new Promise(async (c, u) => {
            var p;
            try {
                const d = await this.throttle("get", t, n, i);
                if (d.status !== 200) return u(d);
                let g = {
                    data: d.data,
                    headers: d.headers
                };
                if ((p = d.headers) != null && p["per-page"] && (g = Object.assign({}, g, {
                        perPage: d.headers["per-page"] ? Number.parseInt(d.headers["per-page"]) : 0,
                        total: d.headers["per-page"] ? Number.parseInt(d.headers.total) : 0
                    })), g.data.story || g.data.stories) {
                    const E = this.resolveCounter = ++this.resolveCounter % 1e3;
                    await this.resolveStories(g.data, n, `${E}`), g = await this.processInlineAssets(g)
                }
                n.version === "published" && t !== "/cdn/spaces/me" && await a.set(s, g);
                const m = this.cache.clear === "onpreview" && n.version === "draft" || this.cache.clear === "auto";
                return n.token && g.data.cv && (m && Eo[n.token] && Eo[n.token] !== g.data.cv && await this.flushCache(), Eo[n.token] = g.data.cv), c(g)
            } catch (d) {
                if (d.response && d.status === 429 && (r = typeof r > "u" ? 0 : r + 1, r < this.maxRetries)) return console.log(`Hit rate limit. Retrying in ${this.retriesDelay/1e3} seconds.`), await gC(this.retriesDelay), this.cacheResponse(t, n, r).then(c).catch(u);
                u(d)
            }
        })
    }
    throttledRequest(t, n, r, i) {
        return this.client.setFetchOptions(i), this.client[t](n, r)
    }
    cacheVersions() {
        return Eo
    }
    cacheVersion() {
        return Eo[this.accessToken]
    }
    setCacheVersion(t) {
        this.accessToken && (Eo[this.accessToken] = t)
    }
    clearCacheVersion() {
        this.accessToken && (Eo[this.accessToken] = 0)
    }
    cacheProvider() {
        switch (this.cache.type) {
            case "memory":
                return {
                    get(t) {
                        return Promise.resolve(Mu[t])
                    }, getAll() {
                        return Promise.resolve(Mu)
                    }, set(t, n) {
                        return Mu[t] = n, Promise.resolve(void 0)
                    }, flush() {
                        return Mu = {}, Promise.resolve(void 0)
                    }
                };
            case "custom":
                if (this.cache.custom) return this.cache.custom;
            default:
                return {
                    get() {
                        return Promise.resolve()
                    }, getAll() {
                        return Promise.resolve(void 0)
                    }, set() {
                        return Promise.resolve(void 0)
                    }, flush() {
                        return Promise.resolve(void 0)
                    }
                }
        }
    }
    async flushCache() {
        return await this.cacheProvider().flush(), this.clearCacheVersion(), this
    }
    async processInlineAssets(t) {
        if (!this.inlineAssets) return t;
        const n = r => {
            if (!r || typeof r != "object") return r;
            if (Array.isArray(r)) return r.map(s => n(s));
            let i = {
                ...r
            };
            i.fieldtype === "asset" && Array.isArray(t.data.assets) && (i = {
                ...i,
                ...t.data.assets.find(s => s.id === i.id)
            });
            for (const s in i) typeof i[s] == "object" && (i[s] = n(i[s]));
            return i
        };
        return t.data.story && (t.data.story.content = n(t.data.story.content)), t.data.stories && (t.data.stories = t.data.stories.map(r => (r.content = n(r.content), r))), t
    }
}
const xC = (e = {}) => {
        const {
            apiOptions: t
        } = e;
        if (!t || !t.accessToken) {
            console.error("You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication");
            return
        }
        return {
            storyblokApi: new DC(t)
        }
    },
    EC = e => {
        if (typeof e != "object" || typeof e._editable > "u") return {};
        try {
            const t = JSON.parse(e._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, ""));
            return t ? {
                "data-blok-c": JSON.stringify(t),
                "data-blok-uid": `${t.id}-${t.uid}`
            } : {}
        } catch {
            return {}
        }
    };
let Lp = "https://app.storyblok.com/f/storyblok-v2-latest.js";
const vP = (e, t, n = {}) => {
        var r;
        const i = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u",
            s = new URL((r = window.location) == null ? void 0 : r.href).searchParams.get("_storyblok"),
            a = s !== null && +s === e;
        if (!(!i || !a)) {
            if (!e) {
                console.warn("Story ID is not defined. Please provide a valid ID.");
                return
            }
            window.storyblokRegisterEvent(() => {
                new window.StoryblokBridge(n).on(["input", "published", "change"], c => {
                    var u;
                    c && (c.action === "input" && ((u = c.story) == null ? void 0 : u.id) === e ? t(c.story) : (c.action === "change" || c.action === "published") && c.storyId === e && window.location.reload())
                })
            })
        }
    },
    CC = (e = {}) => {
        var t, n;
        const {
            bridge: r,
            accessToken: i,
            use: s = [],
            apiOptions: a = {},
            bridgeUrl: c
        } = e;
        a.accessToken = a.accessToken || i;
        const u = {
            bridge: r,
            apiOptions: a
        };
        let p = {};
        s.forEach(g => {
            p = {
                ...p,
                ...g(u)
            }
        }), c && (Lp = c);
        const d = !(typeof window > "u") && ((n = (t = window.location) == null ? void 0 : t.search) == null ? void 0 : n.includes("_storyblok_tk"));
        return r !== !1 && d && lC(Lp), p
    },
    W0 = Jr({
        __name: "StoryblokComponent",
        props: {
            blok: {}
        },
        setup(e, {
            expose: t
        }) {
            const n = e,
                r = kn();
            t({
                value: r
            });
            const i = typeof Al(n.blok.component) != "string",
                s = Er("VueSDKOptions"),
                a = kn(n.blok.component);
            return !i && s && (s.enableFallbackComponent ? (a.value = s.customFallbackComponent ?? "FallbackComponent", typeof Al(a.value) == "string" && console.error(`Is the Fallback component "${a.value}" registered properly?`)) : console.error(`Component could not be found for blok "${n.blok.component}"! Is it defined in main.ts as "app.component("${n.blok.component}", ${n.blok.component});"?`)), (c, u) => (Mn(), cs(Al(a.value), Fh({
                ref_key: "blokRef",
                ref: r
            }, {
                ...c.$props,
                ...c.$attrs
            }), null, 16))
        }
    }),
    SC = e => {
        var t, n;
        return jr(W0, {
            blok: (t = e == null ? void 0 : e.attrs) == null ? void 0 : t.body[0],
            id: (n = e.attrs) == null ? void 0 : n.id
        }, e.children)
    };

function TC(e) {
    const t = {
        renderFn: jr,
        textFn: Gl,
        keyedResolvers: !0,
        resolvers: {
            [hi.COMPONENT]: SC,
            ...e.resolvers
        }
    };
    return aC(t)
}
const PC = Jr({
        __name: "StoryblokRichText",
        props: {
            doc: {},
            resolvers: {}
        },
        setup(e) {
            const t = e,
                n = kn(),
                r = () => n.value;
            return Qr([() => t.doc, () => t.resolvers], ([i, s]) => {
                const {
                    render: a
                } = TC({
                    resolvers: s ?? {}
                });
                n.value = a(i)
            }, {
                immediate: !0,
                deep: !0
            }), (i, s) => (Mn(), cs(r))
        }
    }),
    kC = {
        beforeMount(e, t) {
            if (t.value) {
                const n = EC(t.value);
                Object.keys(n).length > 0 && (e.setAttribute("data-blok-c", n["data-blok-c"]), e.setAttribute("data-blok-uid", n["data-blok-uid"]), e.classList.add("storyblok__outline"))
            }
        }
    },
    AC = e => {
        console.error(`You can't use ${e} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.
    `)
    };
let lh = null;
const RC = () => (lh || AC("useStoryblokApi"), lh),
    OC = {
        install(e, t = {}) {
            e.directive("editable", kC), e.component("StoryblokComponent", W0), e.component("StoryblokRichText", PC), t.enableFallbackComponent && !t.customFallbackComponent && e.component("FallbackComponent", Qt(() => Ht(() => import("./CVyOrWfs.js"), [], import.meta.url)));
            const {
                storyblokApi: n
            } = CC(t);
            lh = n || null, e.provide("VueSDKOptions", t)
        }
    },
    MC = Di(({
        vueApp: e
    }) => {
        let {
            storyblok: t
        } = Bs().public;
        t = JSON.parse(JSON.stringify(t)), e.use(OC, {
            ...t,
            use: [xC]
        })
    });
var LC = "1.3.1";

function q0(e, t, n) {
    return Math.max(e, Math.min(t, n))
}

function FC(e, t, n) {
    return (1 - n) * e + n * t
}

function IC(e, t, n, r) {
    return FC(e, t, 1 - Math.exp(-n * r))
}

function NC(e, t) {
    return (e % t + t) % t
}
var BC = class {
    constructor() {
        Ct(this, "isRunning", !1);
        Ct(this, "value", 0);
        Ct(this, "from", 0);
        Ct(this, "to", 0);
        Ct(this, "currentTime", 0);
        Ct(this, "lerp");
        Ct(this, "duration");
        Ct(this, "easing");
        Ct(this, "onUpdate")
    }
    advance(e) {
        var n;
        if (!this.isRunning) return;
        let t = !1;
        if (this.duration && this.easing) {
            this.currentTime += e;
            const r = q0(0, this.currentTime / this.duration, 1);
            t = r >= 1;
            const i = t ? 1 : this.easing(r);
            this.value = this.from + (this.to - this.from) * i
        } else this.lerp ? (this.value = IC(this.value, this.to, this.lerp * 60, e), Math.round(this.value) === this.to && (this.value = this.to, t = !0)) : (this.value = this.to, t = !0);
        t && this.stop(), (n = this.onUpdate) == null || n.call(this, this.value, t)
    }
    stop() {
        this.isRunning = !1
    }
    fromTo(e, t, {
        lerp: n,
        duration: r,
        easing: i,
        onStart: s,
        onUpdate: a
    }) {
        this.from = this.value = e, this.to = t, this.lerp = n, this.duration = r, this.easing = i, this.currentTime = 0, this.isRunning = !0, s == null || s(), this.onUpdate = a
    }
};

function $C(e, t) {
    let n;
    return function(...r) {
        let i = this;
        clearTimeout(n), n = setTimeout(() => {
            n = void 0, e.apply(i, r)
        }, t)
    }
}
var HC = class {
        constructor(e, t, {
            autoResize: n = !0,
            debounce: r = 250
        } = {}) {
            Ct(this, "width", 0);
            Ct(this, "height", 0);
            Ct(this, "scrollHeight", 0);
            Ct(this, "scrollWidth", 0);
            Ct(this, "debouncedResize");
            Ct(this, "wrapperResizeObserver");
            Ct(this, "contentResizeObserver");
            Ct(this, "resize", () => {
                this.onWrapperResize(), this.onContentResize()
            });
            Ct(this, "onWrapperResize", () => {
                this.wrapper instanceof Window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
            });
            Ct(this, "onContentResize", () => {
                this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
            });
            this.wrapper = e, this.content = t, n && (this.debouncedResize = $C(this.resize, r), this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
        }
        destroy() {
            var e, t;
            (e = this.wrapperResizeObserver) == null || e.disconnect(), (t = this.contentResizeObserver) == null || t.disconnect(), this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1)
        }
        get limit() {
            return {
                x: this.scrollWidth - this.width,
                y: this.scrollHeight - this.height
            }
        }
    },
    G0 = class {
        constructor() {
            Ct(this, "events", {})
        }
        emit(e, ...t) {
            var r;
            let n = this.events[e] || [];
            for (let i = 0, s = n.length; i < s; i++)(r = n[i]) == null || r.call(n, ...t)
        }
        on(e, t) {
            var n;
            return (n = this.events[e]) != null && n.push(t) || (this.events[e] = [t]), () => {
                var r;
                this.events[e] = (r = this.events[e]) == null ? void 0 : r.filter(i => t !== i)
            }
        }
        off(e, t) {
            var n;
            this.events[e] = (n = this.events[e]) == null ? void 0 : n.filter(r => t !== r)
        }
        destroy() {
            this.events = {}
        }
    },
    Fp = 100 / 6,
    Co = {
        passive: !1
    },
    VC = class {
        constructor(e, t = {
            wheelMultiplier: 1,
            touchMultiplier: 1
        }) {
            Ct(this, "touchStart", {
                x: 0,
                y: 0
            });
            Ct(this, "lastDelta", {
                x: 0,
                y: 0
            });
            Ct(this, "window", {
                width: 0,
                height: 0
            });
            Ct(this, "emitter", new G0);
            Ct(this, "onTouchStart", e => {
                const {
                    clientX: t,
                    clientY: n
                } = e.targetTouches ? e.targetTouches[0] : e;
                this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = {
                    x: 0,
                    y: 0
                }, this.emitter.emit("scroll", {
                    deltaX: 0,
                    deltaY: 0,
                    event: e
                })
            });
            Ct(this, "onTouchMove", e => {
                const {
                    clientX: t,
                    clientY: n
                } = e.targetTouches ? e.targetTouches[0] : e, r = -(t - this.touchStart.x) * this.options.touchMultiplier, i = -(n - this.touchStart.y) * this.options.touchMultiplier;
                this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = {
                    x: r,
                    y: i
                }, this.emitter.emit("scroll", {
                    deltaX: r,
                    deltaY: i,
                    event: e
                })
            });
            Ct(this, "onTouchEnd", e => {
                this.emitter.emit("scroll", {
                    deltaX: this.lastDelta.x,
                    deltaY: this.lastDelta.y,
                    event: e
                })
            });
            Ct(this, "onWheel", e => {
                let {
                    deltaX: t,
                    deltaY: n,
                    deltaMode: r
                } = e;
                const i = r === 1 ? Fp : r === 2 ? this.window.width : 1,
                    s = r === 1 ? Fp : r === 2 ? this.window.height : 1;
                t *= i, n *= s, t *= this.options.wheelMultiplier, n *= this.options.wheelMultiplier, this.emitter.emit("scroll", {
                    deltaX: t,
                    deltaY: n,
                    event: e
                })
            });
            Ct(this, "onWindowResize", () => {
                this.window = {
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            });
            this.element = e, this.options = t, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, Co), this.element.addEventListener("touchstart", this.onTouchStart, Co), this.element.addEventListener("touchmove", this.onTouchMove, Co), this.element.addEventListener("touchend", this.onTouchEnd, Co)
        }
        on(e, t) {
            return this.emitter.on(e, t)
        }
        destroy() {
            this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, Co), this.element.removeEventListener("touchstart", this.onTouchStart, Co), this.element.removeEventListener("touchmove", this.onTouchMove, Co), this.element.removeEventListener("touchend", this.onTouchEnd, Co)
        }
    },
    zC = class {
        constructor({
            wrapper: e = window,
            content: t = document.documentElement,
            eventsTarget: n = e,
            smoothWheel: r = !0,
            syncTouch: i = !1,
            syncTouchLerp: s = .075,
            touchInertiaMultiplier: a = 35,
            duration: c,
            easing: u = xe => Math.min(1, 1.001 - Math.pow(2, -10 * xe)),
            lerp: p = .1,
            infinite: d = !1,
            orientation: g = "vertical",
            gestureOrientation: m = "vertical",
            touchMultiplier: E = 1,
            wheelMultiplier: L = 1,
            autoResize: b = !0,
            prevent: j,
            virtualScroll: A,
            overscroll: $ = !0,
            autoRaf: w = !1,
            anchors: k = !1,
            autoToggle: S = !1,
            allowNestedScroll: X = !1,
            __experimental__naiveDimensions: J = !1
        } = {}) {
            Ct(this, "_isScrolling", !1);
            Ct(this, "_isStopped", !1);
            Ct(this, "_isLocked", !1);
            Ct(this, "_preventNextNativeScrollEvent", !1);
            Ct(this, "_resetVelocityTimeout", null);
            Ct(this, "__rafID", null);
            Ct(this, "isTouching");
            Ct(this, "time", 0);
            Ct(this, "userData", {});
            Ct(this, "lastVelocity", 0);
            Ct(this, "velocity", 0);
            Ct(this, "direction", 0);
            Ct(this, "options");
            Ct(this, "targetScroll");
            Ct(this, "animatedScroll");
            Ct(this, "animate", new BC);
            Ct(this, "emitter", new G0);
            Ct(this, "dimensions");
            Ct(this, "virtualScroll");
            Ct(this, "onScrollEnd", e => {
                e instanceof CustomEvent || (this.isScrolling === "smooth" || this.isScrolling === !1) && e.stopPropagation()
            });
            Ct(this, "dispatchScrollendEvent", () => {
                this.options.wrapper.dispatchEvent(new CustomEvent("scrollend", {
                    bubbles: this.options.wrapper === window,
                    detail: {
                        lenisScrollEnd: !0
                    }
                }))
            });
            Ct(this, "onTransitionEnd", e => {
                if (e.propertyName.includes("overflow")) {
                    const t = this.isHorizontal ? "overflow-x" : "overflow-y",
                        n = getComputedStyle(this.rootElement)[t];
                    ["hidden", "clip"].includes(n) ? this.stop() : this.start()
                }
            });
            Ct(this, "onClick", e => {
                const n = e.composedPath().find(r => {
                    var i, s, a;
                    return r instanceof HTMLAnchorElement && (((i = r.getAttribute("href")) == null ? void 0 : i.startsWith("#")) || ((s = r.getAttribute("href")) == null ? void 0 : s.startsWith("/#")) || ((a = r.getAttribute("href")) == null ? void 0 : a.startsWith("./#")))
                });
                if (n) {
                    const r = n.getAttribute("href");
                    if (r) {
                        const i = typeof this.options.anchors == "object" && this.options.anchors ? this.options.anchors : void 0;
                        let s = `#${r.split("#")[1]}`;
                        ["#", "/#", "./#", "#top", "/#top", "./#top"].includes(r) && (s = 0), this.scrollTo(s, i)
                    }
                }
            });
            Ct(this, "onPointerDown", e => {
                e.button === 1 && this.reset()
            });
            Ct(this, "onVirtualScroll", e => {
                if (typeof this.options.virtualScroll == "function" && this.options.virtualScroll(e) === !1) return;
                const {
                    deltaX: t,
                    deltaY: n,
                    event: r
                } = e;
                if (this.emitter.emit("virtual-scroll", {
                        deltaX: t,
                        deltaY: n,
                        event: r
                    }), r.ctrlKey || r.lenisStopPropagation) return;
                const i = r.type.includes("touch"),
                    s = r.type.includes("wheel");
                this.isTouching = r.type === "touchstart" || r.type === "touchmove";
                const a = t === 0 && n === 0;
                if (this.options.syncTouch && i && r.type === "touchstart" && a && !this.isStopped && !this.isLocked) {
                    this.reset();
                    return
                }
                const u = this.options.gestureOrientation === "vertical" && n === 0 || this.options.gestureOrientation === "horizontal" && t === 0;
                if (a || u) return;
                let p = r.composedPath();
                p = p.slice(0, p.indexOf(this.rootElement));
                const d = this.options.prevent;
                if (p.find(j => {
                        var A, $, w;
                        return j instanceof HTMLElement && (typeof d == "function" && (d == null ? void 0 : d(j)) || ((A = j.hasAttribute) == null ? void 0 : A.call(j, "data-lenis-prevent")) || i && (($ = j.hasAttribute) == null ? void 0 : $.call(j, "data-lenis-prevent-touch")) || s && ((w = j.hasAttribute) == null ? void 0 : w.call(j, "data-lenis-prevent-wheel")) || this.options.allowNestedScroll && this.checkNestedScroll(j, {
                            deltaX: t,
                            deltaY: n
                        }))
                    })) return;
                if (this.isStopped || this.isLocked) {
                    r.preventDefault();
                    return
                }
                if (!(this.options.syncTouch && i || this.options.smoothWheel && s)) {
                    this.isScrolling = "native", this.animate.stop(), r.lenisStopPropagation = !0;
                    return
                }
                let m = n;
                this.options.gestureOrientation === "both" ? m = Math.abs(n) > Math.abs(t) ? n : t : this.options.gestureOrientation === "horizontal" && (m = t), (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && n > 0 || this.animatedScroll === this.limit && n < 0)) && (r.lenisStopPropagation = !0), r.preventDefault();
                const E = i && this.options.syncTouch,
                    b = i && r.type === "touchend" && Math.abs(m) > 5;
                b && (m = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + m, {
                    programmatic: !1,
                    ...E ? {
                        lerp: b ? this.options.syncTouchLerp : 1
                    } : {
                        lerp: this.options.lerp,
                        duration: this.options.duration,
                        easing: this.options.easing
                    }
                })
            });
            Ct(this, "onNativeScroll", () => {
                if (this._resetVelocityTimeout !== null && (clearTimeout(this._resetVelocityTimeout), this._resetVelocityTimeout = null), this._preventNextNativeScrollEvent) {
                    this._preventNextNativeScrollEvent = !1;
                    return
                }
                if (this.isScrolling === !1 || this.isScrolling === "native") {
                    const e = this.animatedScroll;
                    this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - e, this.direction = Math.sign(this.animatedScroll - e), this.isStopped || (this.isScrolling = "native"), this.emit(), this.velocity !== 0 && (this._resetVelocityTimeout = setTimeout(() => {
                        this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = !1, this.emit()
                    }, 400))
                }
            });
            Ct(this, "raf", e => {
                const t = e - (this.time || e);
                this.time = e, this.animate.advance(t * .001), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
            });
            window.lenisVersion = LC, (!e || e === document.documentElement) && (e = window), this.options = {
                wrapper: e,
                content: t,
                eventsTarget: n,
                smoothWheel: r,
                syncTouch: i,
                syncTouchLerp: s,
                touchInertiaMultiplier: a,
                duration: c,
                easing: u,
                lerp: p,
                infinite: d,
                gestureOrientation: m,
                orientation: g,
                touchMultiplier: E,
                wheelMultiplier: L,
                autoResize: b,
                prevent: j,
                virtualScroll: A,
                overscroll: $,
                autoRaf: w,
                anchors: k,
                autoToggle: S,
                allowNestedScroll: X,
                __experimental__naiveDimensions: J
            }, this.dimensions = new HC(e, t, {
                autoResize: b
            }), this.updateClassName(), this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, {
                capture: !0
            }), this.options.anchors && this.options.wrapper === window && this.options.wrapper.addEventListener("click", this.onClick, !1), this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1), this.virtualScroll = new VC(n, {
                touchMultiplier: E,
                wheelMultiplier: L
            }), this.virtualScroll.on("scroll", this.onVirtualScroll), this.options.autoToggle && this.rootElement.addEventListener("transitionend", this.onTransitionEnd, {
                passive: !0
            }), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
        }
        destroy() {
            this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, {
                capture: !0
            }), this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1), this.options.anchors && this.options.wrapper === window && this.options.wrapper.removeEventListener("click", this.onClick, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName(), this.__rafID && cancelAnimationFrame(this.__rafID)
        }
        on(e, t) {
            return this.emitter.on(e, t)
        }
        off(e, t) {
            return this.emitter.off(e, t)
        }
        setScroll(e) {
            this.isHorizontal ? this.options.wrapper.scrollTo({
                left: e,
                behavior: "instant"
            }) : this.options.wrapper.scrollTo({
                top: e,
                behavior: "instant"
            })
        }
        resize() {
            this.dimensions.resize(), this.animatedScroll = this.targetScroll = this.actualScroll, this.emit()
        }
        emit() {
            this.emitter.emit("scroll", this)
        }
        reset() {
            this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop()
        }
        start() {
            this.isStopped && (this.reset(), this.isStopped = !1)
        }
        stop() {
            this.isStopped || (this.reset(), this.isStopped = !0)
        }
        scrollTo(e, {
            offset: t = 0,
            immediate: n = !1,
            lock: r = !1,
            duration: i = this.options.duration,
            easing: s = this.options.easing,
            lerp: a = this.options.lerp,
            onStart: c,
            onComplete: u,
            force: p = !1,
            programmatic: d = !0,
            userData: g
        } = {}) {
            if (!((this.isStopped || this.isLocked) && !p)) {
                if (typeof e == "string" && ["top", "left", "start"].includes(e)) e = 0;
                else if (typeof e == "string" && ["bottom", "right", "end"].includes(e)) e = this.limit;
                else {
                    let m;
                    if (typeof e == "string" ? m = document.querySelector(e) : e instanceof HTMLElement && (e != null && e.nodeType) && (m = e), m) {
                        if (this.options.wrapper !== window) {
                            const L = this.rootElement.getBoundingClientRect();
                            t -= this.isHorizontal ? L.left : L.top
                        }
                        const E = m.getBoundingClientRect();
                        e = (this.isHorizontal ? E.left : E.top) + this.animatedScroll
                    }
                }
                if (typeof e == "number") {
                    if (e += t, e = Math.round(e), this.options.infinite) {
                        if (d) {
                            this.targetScroll = this.animatedScroll = this.scroll;
                            const m = e - this.animatedScroll;
                            m > this.limit / 2 ? e = e - this.limit : m < -this.limit / 2 && (e = e + this.limit)
                        }
                    } else e = q0(0, e, this.limit);
                    if (e === this.targetScroll) {
                        c == null || c(this), u == null || u(this);
                        return
                    }
                    if (this.userData = g ?? {}, n) {
                        this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), u == null || u(this), this.userData = {}, requestAnimationFrame(() => {
                            this.dispatchScrollendEvent()
                        });
                        return
                    }
                    d || (this.targetScroll = e), this.animate.fromTo(this.animatedScroll, e, {
                        duration: i,
                        easing: s,
                        lerp: a,
                        onStart: () => {
                            r && (this.isLocked = !0), this.isScrolling = "smooth", c == null || c(this)
                        },
                        onUpdate: (m, E) => {
                            this.isScrolling = "smooth", this.lastVelocity = this.velocity, this.velocity = m - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = m, this.setScroll(this.scroll), d && (this.targetScroll = m), E || this.emit(), E && (this.reset(), this.emit(), u == null || u(this), this.userData = {}, requestAnimationFrame(() => {
                                this.dispatchScrollendEvent()
                            }), this.preventNextNativeScrollEvent())
                        }
                    })
                }
            }
        }
        preventNextNativeScrollEvent() {
            this._preventNextNativeScrollEvent = !0, requestAnimationFrame(() => {
                this._preventNextNativeScrollEvent = !1
            })
        }
        checkNestedScroll(e, {
            deltaX: t,
            deltaY: n
        }) {
            const r = Date.now(),
                i = e._lenis ?? (e._lenis = {});
            let s, a, c, u, p, d, g, m;
            const E = this.options.gestureOrientation;
            if (r - (i.time ?? 0) > 2e3) {
                i.time = Date.now();
                const S = window.getComputedStyle(e);
                i.computedStyle = S;
                const X = S.overflowX,
                    J = S.overflowY;
                if (s = ["auto", "overlay", "scroll"].includes(X), a = ["auto", "overlay", "scroll"].includes(J), i.hasOverflowX = s, i.hasOverflowY = a, !s && !a || E === "vertical" && !a || E === "horizontal" && !s) return !1;
                p = e.scrollWidth, d = e.scrollHeight, g = e.clientWidth, m = e.clientHeight, c = p > g, u = d > m, i.isScrollableX = c, i.isScrollableY = u, i.scrollWidth = p, i.scrollHeight = d, i.clientWidth = g, i.clientHeight = m
            } else c = i.isScrollableX, u = i.isScrollableY, s = i.hasOverflowX, a = i.hasOverflowY, p = i.scrollWidth, d = i.scrollHeight, g = i.clientWidth, m = i.clientHeight;
            if (!s && !a || !c && !u || E === "vertical" && (!a || !u) || E === "horizontal" && (!s || !c)) return !1;
            let L;
            if (E === "horizontal") L = "x";
            else if (E === "vertical") L = "y";
            else {
                const S = t !== 0,
                    X = n !== 0;
                S && s && c && (L = "x"), X && a && u && (L = "y")
            }
            if (!L) return !1;
            let b, j, A, $, w;
            if (L === "x") b = e.scrollLeft, j = p - g, A = t, $ = s, w = c;
            else if (L === "y") b = e.scrollTop, j = d - m, A = n, $ = a, w = u;
            else return !1;
            return (A > 0 ? b < j : b > 0) && $ && w
        }
        get rootElement() {
            return this.options.wrapper === window ? document.documentElement : this.options.wrapper
        }
        get limit() {
            return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
        }
        get isHorizontal() {
            return this.options.orientation === "horizontal"
        }
        get actualScroll() {
            const e = this.options.wrapper;
            return this.isHorizontal ? e.scrollX ?? e.scrollLeft : e.scrollY ?? e.scrollTop
        }
        get scroll() {
            return this.options.infinite ? NC(this.animatedScroll, this.limit) : this.animatedScroll
        }
        get progress() {
            return this.limit === 0 ? 1 : this.scroll / this.limit
        }
        get isScrolling() {
            return this._isScrolling
        }
        set isScrolling(e) {
            this._isScrolling !== e && (this._isScrolling = e, this.updateClassName())
        }
        get isStopped() {
            return this._isStopped
        }
        set isStopped(e) {
            this._isStopped !== e && (this._isStopped = e, this.updateClassName())
        }
        get isLocked() {
            return this._isLocked
        }
        set isLocked(e) {
            this._isLocked !== e && (this._isLocked = e, this.updateClassName())
        }
        get isSmooth() {
            return this.isScrolling === "smooth"
        }
        get className() {
            let e = "lenis";
            return this.options.autoToggle && (e += " lenis-autoToggle"), this.isStopped && (e += " lenis-stopped"), this.isLocked && (e += " lenis-locked"), this.isScrolling && (e += " lenis-scrolling"), this.isScrolling === "smooth" && (e += " lenis-smooth"), e
        }
        updateClassName() {
            this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim()
        }
        cleanUpClassName() {
            this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
        }
    },
    uh = Ur(),
    ch = Ur(),
    fh = Ur(),
    Xh = Symbol("LenisContext"),
    Kh = Symbol("AddCallback"),
    Qh = Symbol("RemoveCallback"),
    Y0 = Jr({
        name: "VueLenis",
        props: {
            root: {
                type: Boolean,
                default: !1
            },
            autoRaf: {
                type: Boolean,
                default: !0
            },
            options: {
                type: Object,
                default: () => ({})
            },
            props: {
                type: Object,
                default: () => ({})
            }
        },
        setup(e, {
            slots: t,
            expose: n
        }) {
            const r = Ur(),
                i = kn(),
                s = kn();
            n({
                lenis: r,
                wrapper: i,
                content: s
            }), Qr([() => e.options, i, s], () => {
                var g;
                typeof window < "u" && (!e.root && (!i.value || !s.value) || (r.value = new zC({
                    ...e.options,
                    ...e.root ? {} : {
                        wrapper: i.value,
                        content: s.value
                    },
                    autoRaf: ((g = e.options) == null ? void 0 : g.autoRaf) ?? e.autoRaf
                }), za(() => {
                    var m;
                    (m = r.value) == null || m.destroy(), r.value = void 0
                })))
            }, {
                deep: !0,
                immediate: !0
            });
            const a = mi([]);

            function c(d, g) {
                a.push({
                    callback: d,
                    priority: g
                }), a.sort((m, E) => m.priority - E.priority)
            }

            function u(d) {
                a.splice(a.findIndex(g => g.callback === d), 1)
            }
            const p = d => {
                var g;
                for (let m = 0; m < a.length; m++)(g = a[m]) == null || g.callback(d)
            };
            return Qr([r, () => e.root], ([d, g]) => {
                d == null || d.on("scroll", p), g && (uh.value = d, ch.value = c, fh.value = u, za(() => {
                    uh.value = void 0, ch.value = void 0, fh.value = void 0
                }))
            }, {
                immediate: !0
            }), e.root || (ws(Xh, r), ws(Kh, c), ws(Qh, u)), () => {
                var d, g;
                return e.root ? (d = t.default) == null ? void 0 : d.call(t) : jr("div", {
                    ref: i,
                    ...e == null ? void 0 : e.props
                }, [jr("div", {
                    ref: s
                }, (g = t.default) == null ? void 0 : g.call(t))])
            }
        }
    }),
    jC = e => {
        e.component("vue-lenis", Y0), e.provide(Xh, Ur(void 0)), e.provide(Kh, void 0), e.provide(Qh, void 0)
    };

function Bc(e, t = 0) {
    const n = Er(Xh),
        r = Er(Kh),
        i = Er(Qh),
        s = xn(() => r || ch.value),
        a = xn(() => i || fh.value),
        c = xn(() => n != null && n.value ? n.value : uh.value);
    return typeof window < "u" && ss(() => {
        ss(() => {
            c.value || console.warn("No lenis instance found, either mount a root lenis instance or wrap your component in a lenis provider")
        })
    }), Qr([c, s, a], ([u, p, d]) => {
        !u || !p || !d || !e || (p == null || p(e, t), e == null || e(u), za(() => {
            d == null || d(e)
        }))
    }, {
        immediate: !0
    }), c
}
var UC = Di({
        setup(e) {
            e.vueApp.use(jC)
        }
    }),
    WC = UC;

function Go(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var yl = {
        exports: {}
    },
    qC = yl.exports,
    Ip;

function GC() {
    return Ip || (Ip = 1, function(e, t) {
        (function(n, r) {
            r(t)
        })(qC, function(n) {
            function r(V, o) {
                V.prototype = Object.create(o.prototype), V.prototype.constructor = V, V.__proto__ = o
            }

            function i(V) {
                if (V === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return V
            }
            /*!
             * GSAP 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var s = {
                    autoSleep: 120,
                    force3D: "auto",
                    nullTargetWarn: 1,
                    units: {
                        lineHeight: ""
                    }
                },
                a = {
                    duration: .5,
                    overwrite: !1,
                    delay: 0
                },
                c, u, p, d = 1e8,
                g = 1 / d,
                m = Math.PI * 2,
                E = m / 4,
                L = 0,
                b = Math.sqrt,
                j = Math.cos,
                A = Math.sin,
                $ = function(o) {
                    return typeof o == "string"
                },
                w = function(o) {
                    return typeof o == "function"
                },
                k = function(o) {
                    return typeof o == "number"
                },
                S = function(o) {
                    return typeof o > "u"
                },
                X = function(o) {
                    return typeof o == "object"
                },
                J = function(o) {
                    return o !== !1
                },
                xe = function() {
                    return typeof window < "u"
                },
                he = function(o) {
                    return w(o) || $(o)
                },
                me = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {},
                Q = Array.isArray,
                ne = /(?:-?\.?\d|\.)+/gi,
                re = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
                K = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                te = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
                G = /[+-]=-?[.\d]+/,
                ce = /[^,'"\[\]\s]+/gi,
                le = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
                ve, tt, ht, lt, _t = {},
                mt = {},
                Pt, St = function(o) {
                    return (mt = ge(o, _t)) && mn
                },
                de = function(o, l) {
                    return console.warn("Invalid property", o, "set to", l, "Missing plugin? gsap.registerPlugin()")
                },
                ye = function(o, l) {
                    return !l && console.warn(o)
                },
                oe = function(o, l) {
                    return o && (_t[o] = l) && mt && (mt[o] = l) || _t
                },
                ze = function() {
                    return 0
                },
                Se = {
                    suppressEvents: !0,
                    isStart: !0,
                    kill: !1
                },
                Ke = {
                    suppressEvents: !0,
                    kill: !1
                },
                M = {
                    suppressEvents: !0
                },
                I = {},
                fe = [],
                Oe = {},
                Te, Ie = {},
                st = {},
                nt = 30,
                je = [],
                We = "",
                bt = function(o) {
                    var l = o[0],
                        f, h;
                    if (X(l) || w(l) || (o = [o]), !(f = (l._gsap || {}).harness)) {
                        for (h = je.length; h-- && !je[h].targetTest(l););
                        f = je[h]
                    }
                    for (h = o.length; h--;) o[h] && (o[h]._gsap || (o[h]._gsap = new tl(o[h], f))) || o.splice(h, 1);
                    return o
                },
                Ze = function(o) {
                    return o._gsap || bt(ct(o))[0]._gsap
                },
                wt = function(o, l, f) {
                    return (f = o[l]) && w(f) ? o[l]() : S(f) && o.getAttribute && o.getAttribute(l) || f
                },
                Et = function(o, l) {
                    return (o = o.split(",")).forEach(l) || o
                },
                Ot = function(o) {
                    return Math.round(o * 1e5) / 1e5 || 0
                },
                qt = function(o) {
                    return Math.round(o * 1e7) / 1e7 || 0
                },
                an = function(o, l) {
                    var f = l.charAt(0),
                        h = parseFloat(l.substr(2));
                    return o = parseFloat(o), f === "+" ? o + h : f === "-" ? o - h : f === "*" ? o * h : o / h
                },
                Rn = function(o, l) {
                    for (var f = l.length, h = 0; o.indexOf(l[h]) < 0 && ++h < f;);
                    return h < f
                },
                un = function() {
                    var o = fe.length,
                        l = fe.slice(0),
                        f, h;
                    for (Oe = {}, fe.length = 0, f = 0; f < o; f++) h = l[f], h && h._lazy && (h.render(h._lazy[0], h._lazy[1], !0)._lazy = 0)
                },
                An = function(o) {
                    return !!(o._initted || o._startAt || o.add)
                },
                Un = function(o, l, f, h) {
                    fe.length && !u && un(), o.render(l, f, !!(u && l < 0 && An(o))), fe.length && !u && un()
                },
                er = function(o) {
                    var l = parseFloat(o);
                    return (l || l === 0) && (o + "").match(ce).length < 2 ? l : $(o) ? o.trim() : o
                },
                ft = function(o) {
                    return o
                },
                Y = function(o, l) {
                    for (var f in l) f in o || (o[f] = l[f]);
                    return o
                },
                ie = function(o) {
                    return function(l, f) {
                        for (var h in f) h in l || h === "duration" && o || h === "ease" || (l[h] = f[h])
                    }
                },
                ge = function(o, l) {
                    for (var f in l) o[f] = l[f];
                    return o
                },
                ke = function V(o, l) {
                    for (var f in l) f !== "__proto__" && f !== "constructor" && f !== "prototype" && (o[f] = X(l[f]) ? V(o[f] || (o[f] = {}), l[f]) : l[f]);
                    return o
                },
                Le = function(o, l) {
                    var f = {},
                        h;
                    for (h in o) h in l || (f[h] = o[h]);
                    return f
                },
                Ee = function(o) {
                    var l = o.parent || ve,
                        f = o.keyframes ? ie(Q(o.keyframes)) : Y;
                    if (J(o.inherit))
                        for (; l;) f(o, l.vars.defaults), l = l.parent || l._dp;
                    return o
                },
                Ne = function(o, l) {
                    for (var f = o.length, h = f === l.length; h && f-- && o[f] === l[f];);
                    return f < 0
                },
                qe = function(o, l, f, h, _) {
                    var v = o[h],
                        D;
                    if (_)
                        for (D = l[_]; v && v[_] > D;) v = v._prev;
                    return v ? (l._next = v._next, v._next = l) : (l._next = o[f], o[f] = l), l._next ? l._next._prev = l : o[h] = l, l._prev = v, l.parent = l._dp = o, l
                },
                Ve = function(o, l, f, h) {
                    f === void 0 && (f = "_first"), h === void 0 && (h = "_last");
                    var _ = l._prev,
                        v = l._next;
                    _ ? _._next = v : o[f] === l && (o[f] = v), v ? v._prev = _ : o[h] === l && (o[h] = _), l._next = l._prev = l.parent = null
                },
                yt = function(o, l) {
                    o.parent && (!l || o.parent.autoRemoveChildren) && o.parent.remove && o.parent.remove(o), o._act = 0
                },
                rt = function(o, l) {
                    if (o && (!l || l._end > o._dur || l._start < 0))
                        for (var f = o; f;) f._dirty = 1, f = f.parent;
                    return o
                },
                He = function(o) {
                    for (var l = o.parent; l && l.parent;) l._dirty = 1, l.totalDuration(), l = l.parent;
                    return o
                },
                ot = function(o, l, f, h) {
                    return o._startAt && (u ? o._startAt.revert(Ke) : o.vars.immediateRender && !o.vars.autoRevert || o._startAt.render(l, !0, h))
                },
                Mt = function V(o) {
                    return !o || o._ts && V(o.parent)
                },
                ut = function(o) {
                    return o._repeat ? pt(o._tTime, o = o.duration() + o._rDelay) * o : 0
                },
                pt = function(o, l) {
                    var f = Math.floor(o = qt(o / l));
                    return o && f === o ? f - 1 : f
                },
                Qe = function(o, l) {
                    return (o - l._start) * l._ts + (l._ts >= 0 ? 0 : l._dirty ? l.totalDuration() : l._tDur)
                },
                Re = function(o) {
                    return o._end = qt(o._start + (o._tDur / Math.abs(o._ts || o._rts || g) || 0))
                },
                T = function(o, l) {
                    var f = o._dp;
                    return f && f.smoothChildTiming && o._ts && (o._start = qt(f._time - (o._ts > 0 ? l / o._ts : ((o._dirty ? o.totalDuration() : o._tDur) - l) / -o._ts)), Re(o), f._dirty || rt(f, o)), o
                },
                z = function(o, l) {
                    var f;
                    if ((l._time || !l._dur && l._initted || l._start < o._time && (l._dur || !l.add)) && (f = Qe(o.rawTime(), l), (!l._dur || Ce(0, l.totalDuration(), f) - l._tTime > g) && l.render(f, !0)), rt(o, l)._dp && o._initted && o._time >= o._dur && o._ts) {
                        if (o._dur < o.duration())
                            for (f = o; f._dp;) f.rawTime() >= 0 && f.totalTime(f._tTime), f = f._dp;
                        o._zTime = -1e-8
                    }
                },
                R = function(o, l, f, h) {
                    return l.parent && yt(l), l._start = qt((k(f) ? f : f || o !== ve ? q(o, f, l) : o._time) + l._delay), l._end = qt(l._start + (l.totalDuration() / Math.abs(l.timeScale()) || 0)), qe(o, l, "_first", "_last", o._sort ? "_start" : 0), at(l) || (o._recent = l), h || z(o, l), o._ts < 0 && T(o, o._tTime), o
                },
                ee = function(o, l) {
                    return (_t.ScrollTrigger || de("scrollTrigger", l)) && _t.ScrollTrigger.create(l, o)
                },
                ae = function(o, l, f, h, _) {
                    if (Ko(o, l, _), !o._initted) return 1;
                    if (!f && o._pt && !u && (o._dur && o.vars.lazy !== !1 || !o._dur && o.vars.lazy) && Te !== En.frame) return fe.push(o), o._lazy = [_, h], 1
                },
                Fe = function V(o) {
                    var l = o.parent;
                    return l && l._ts && l._initted && !l._lock && (l.rawTime() < 0 || V(l))
                },
                at = function(o) {
                    var l = o.data;
                    return l === "isFromStart" || l === "isStart"
                },
                O = function(o, l, f, h) {
                    var _ = o.ratio,
                        v = l < 0 || !l && (!o._start && Fe(o) && !(!o._initted && at(o)) || (o._ts < 0 || o._dp._ts < 0) && !at(o)) ? 0 : 1,
                        D = o._rDelay,
                        N = 0,
                        U, W, De;
                    if (D && o._repeat && (N = Ce(0, o._tDur, l), W = pt(N, D), o._yoyo && W & 1 && (v = 1 - v), W !== pt(o._tTime, D) && (_ = 1 - v, o.vars.repeatRefresh && o._initted && o.invalidate())), v !== _ || u || h || o._zTime === g || !l && o._zTime) {
                        if (!o._initted && ae(o, l, h, f, N)) return;
                        for (De = o._zTime, o._zTime = l || (f ? g : 0), f || (f = l && !De), o.ratio = v, o._from && (v = 1 - v), o._time = 0, o._tTime = N, U = o._pt; U;) U.r(v, U.d), U = U._next;
                        l < 0 && ot(o, l, f, !0), o._onUpdate && !f && nr(o, "onUpdate"), N && o._repeat && !f && o.parent && nr(o, "onRepeat"), (l >= o._tDur || l < 0) && o.ratio === v && (v && yt(o, 1), !f && !u && (nr(o, v ? "onComplete" : "onReverseComplete", !0), o._prom && o._prom()))
                    } else o._zTime || (o._zTime = l)
                },
                y = function(o, l, f) {
                    var h;
                    if (f > l)
                        for (h = o._first; h && h._start <= f;) {
                            if (h.data === "isPause" && h._start > l) return h;
                            h = h._next
                        } else
                            for (h = o._last; h && h._start >= f;) {
                                if (h.data === "isPause" && h._start < l) return h;
                                h = h._prev
                            }
                },
                x = function(o, l, f, h) {
                    var _ = o._repeat,
                        v = qt(l) || 0,
                        D = o._tTime / o._tDur;
                    return D && !h && (o._time *= v / o._dur), o._dur = v, o._tDur = _ ? _ < 0 ? 1e10 : qt(v * (_ + 1) + o._rDelay * _) : v, D > 0 && !h && T(o, o._tTime = o._tDur * D), o.parent && Re(o), f || rt(o.parent, o), o
                },
                P = function(o) {
                    return o instanceof Zr ? rt(o) : x(o, o._dur)
                },
                B = {
                    _start: 0,
                    endTime: ze,
                    totalDuration: ze
                },
                q = function V(o, l, f) {
                    var h = o.labels,
                        _ = o._recent || B,
                        v = o.duration() >= d ? _.endTime(!1) : o._dur,
                        D, N, U;
                    return $(l) && (isNaN(l) || l in h) ? (N = l.charAt(0), U = l.substr(-1) === "%", D = l.indexOf("="), N === "<" || N === ">" ? (D >= 0 && (l = l.replace(/=/, "")), (N === "<" ? _._start : _.endTime(_._repeat >= 0)) + (parseFloat(l.substr(1)) || 0) * (U ? (D < 0 ? _ : f).totalDuration() / 100 : 1)) : D < 0 ? (l in h || (h[l] = v), h[l]) : (N = parseFloat(l.charAt(D - 1) + l.substr(D + 1)), U && f && (N = N / 100 * (Q(f) ? f[0] : f).totalDuration()), D > 1 ? V(o, l.substr(0, D - 1), f) + N : v + N)) : l == null ? v : +l
                },
                ue = function(o, l, f) {
                    var h = k(l[1]),
                        _ = (h ? 2 : 1) + (o < 2 ? 0 : 1),
                        v = l[_],
                        D, N;
                    if (h && (v.duration = l[1]), v.parent = f, o) {
                        for (D = v, N = f; N && !("immediateRender" in D);) D = N.vars.defaults || {}, N = J(N.vars.inherit) && N.parent;
                        v.immediateRender = J(D.immediateRender), o < 2 ? v.runBackwards = 1 : v.startAt = l[_ - 1]
                    }
                    return new Lr(l[0], v, l[_ + 1])
                },
                be = function(o, l) {
                    return o || o === 0 ? l(o) : l
                },
                Ce = function(o, l, f) {
                    return f < o ? o : f > l ? l : f
                },
                se = function(o, l) {
                    return !$(o) || !(l = le.exec(o)) ? "" : l[1]
                },
                Ue = function(o, l, f) {
                    return be(f, function(h) {
                        return Ce(o, l, h)
                    })
                },
                _e = [].slice,
                Xe = function(o, l) {
                    return o && X(o) && "length" in o && (!l && !o.length || o.length - 1 in o && X(o[0])) && !o.nodeType && o !== tt
                },
                Je = function(o, l, f) {
                    return f === void 0 && (f = []), o.forEach(function(h) {
                        var _;
                        return $(h) && !l || Xe(h, 1) ? (_ = f).push.apply(_, ct(h)) : f.push(h)
                    }) || f
                },
                ct = function(o, l, f) {
                    return p && !l && p.selector ? p.selector(o) : $(o) && !f && (ht || !Es()) ? _e.call((l || lt).querySelectorAll(o), 0) : Q(o) ? Je(o, f) : Xe(o) ? _e.call(o, 0) : o ? [o] : []
                },
                dt = function(o) {
                    return o = ct(o)[0] || ye("Invalid scope") || {},
                        function(l) {
                            var f = o.current || o.nativeElement || o;
                            return ct(l, f.querySelectorAll ? f : f === o ? ye("Invalid scope") || lt.createElement("div") : o)
                        }
                },
                Bt = function(o) {
                    return o.sort(function() {
                        return .5 - Math.random()
                    })
                },
                Lt = function(o) {
                    if (w(o)) return o;
                    var l = X(o) ? o : {
                            each: o
                        },
                        f = Vs(l.ease),
                        h = l.from || 0,
                        _ = parseFloat(l.base) || 0,
                        v = {},
                        D = h > 0 && h < 1,
                        N = isNaN(h) || D,
                        U = l.axis,
                        W = h,
                        De = h;
                    return $(h) ? W = De = {
                            center: .5,
                            edges: .5,
                            end: 1
                        } [h] || 0 : !D && N && (W = h[0], De = h[1]),
                        function(Me, $e, et) {
                            var pe = (et || l).length,
                                it = v[pe],
                                Dt, xt, kt, At, vt, Vt, zt, Ut, Rt;
                            if (!it) {
                                if (Rt = l.grid === "auto" ? 0 : (l.grid || [1, d])[1], !Rt) {
                                    for (zt = -1e8; zt < (zt = et[Rt++].getBoundingClientRect().left) && Rt < pe;);
                                    Rt < pe && Rt--
                                }
                                for (it = v[pe] = [], Dt = N ? Math.min(Rt, pe) * W - .5 : h % Rt, xt = Rt === d ? 0 : N ? pe * De / Rt - .5 : h / Rt | 0, zt = 0, Ut = d, Vt = 0; Vt < pe; Vt++) kt = Vt % Rt - Dt, At = xt - (Vt / Rt | 0), it[Vt] = vt = U ? Math.abs(U === "y" ? At : kt) : b(kt * kt + At * At), vt > zt && (zt = vt), vt < Ut && (Ut = vt);
                                h === "random" && Bt(it), it.max = zt - Ut, it.min = Ut, it.v = pe = (parseFloat(l.amount) || parseFloat(l.each) * (Rt > pe ? pe - 1 : U ? U === "y" ? pe / Rt : Rt : Math.max(Rt, pe / Rt)) || 0) * (h === "edges" ? -1 : 1), it.b = pe < 0 ? _ - pe : _, it.u = se(l.amount || l.each) || 0, f = f && pe < 0 ? Hs(f) : f
                            }
                            return pe = (it[Me] - it.min) / it.max || 0, qt(it.b + (f ? f(pe) : pe) * it.v) + it.u
                        }
                },
                Tt = function(o) {
                    var l = Math.pow(10, ((o + "").split(".")[1] || "").length);
                    return function(f) {
                        var h = qt(Math.round(parseFloat(f) / o) * o * l);
                        return (h - h % 1) / l + (k(f) ? 0 : se(f))
                    }
                },
                It = function(o, l) {
                    var f = Q(o),
                        h, _;
                    return !f && X(o) && (h = f = o.radius || d, o.values ? (o = ct(o.values), (_ = !k(o[0])) && (h *= h)) : o = Tt(o.increment)), be(l, f ? w(o) ? function(v) {
                        return _ = o(v), Math.abs(_ - v) <= h ? _ : v
                    } : function(v) {
                        for (var D = parseFloat(_ ? v.x : v), N = parseFloat(_ ? v.y : 0), U = d, W = 0, De = o.length, Me, $e; De--;) _ ? (Me = o[De].x - D, $e = o[De].y - N, Me = Me * Me + $e * $e) : Me = Math.abs(o[De] - D), Me < U && (U = Me, W = De);
                        return W = !h || U <= h ? o[W] : v, _ || W === v || k(v) ? W : W + se(v)
                    } : Tt(o))
                },
                Ft = function(o, l, f, h) {
                    return be(Q(o) ? !l : f === !0 ? !!(f = 0) : !h, function() {
                        return Q(o) ? o[~~(Math.random() * o.length)] : (f = f || 1e-5) && (h = f < 1 ? Math.pow(10, (f + "").length - 2) : 1) && Math.floor(Math.round((o - f / 2 + Math.random() * (l - o + f * .99)) / f) * f * h) / h
                    })
                },
                Jt = function() {
                    for (var o = arguments.length, l = new Array(o), f = 0; f < o; f++) l[f] = arguments[f];
                    return function(h) {
                        return l.reduce(function(_, v) {
                            return v(_)
                        }, h)
                    }
                },
                Gt = function(o, l) {
                    return function(f) {
                        return o(parseFloat(f)) + (l || se(f))
                    }
                },
                jt = function(o, l, f) {
                    return fr(o, l, 0, 1, f)
                },
                rn = function(o, l, f) {
                    return be(f, function(h) {
                        return o[~~l(h)]
                    })
                },
                cn = function V(o, l, f) {
                    var h = l - o;
                    return Q(o) ? rn(o, V(0, o.length), l) : be(f, function(_) {
                        return (h + (_ - o) % h) % h + o
                    })
                },
                Mr = function V(o, l, f) {
                    var h = l - o,
                        _ = h * 2;
                    return Q(o) ? rn(o, V(0, o.length - 1), l) : be(f, function(v) {
                        return v = (_ + (v - o) % _) % _ || 0, o + (v > h ? _ - v : v)
                    })
                },
                tr = function(o) {
                    for (var l = 0, f = "", h, _, v, D; ~(h = o.indexOf("random(", l));) v = o.indexOf(")", h), D = o.charAt(h + 7) === "[", _ = o.substr(h + 7, v - h - 7).match(D ? ce : ne), f += o.substr(l, h - l) + Ft(D ? _ : +_[0], D ? 0 : +_[1], +_[2] || 1e-5), l = v + 1;
                    return f + o.substr(l, o.length - l)
                },
                fr = function(o, l, f, h, _) {
                    var v = l - o,
                        D = h - f;
                    return be(_, function(N) {
                        return f + ((N - o) / v * D || 0)
                    })
                },
                hr = function V(o, l, f, h) {
                    var _ = isNaN(o + l) ? 0 : function($e) {
                        return (1 - $e) * o + $e * l
                    };
                    if (!_) {
                        var v = $(o),
                            D = {},
                            N, U, W, De, Me;
                        if (f === !0 && (h = 1) && (f = null), v) o = {
                            p: o
                        }, l = {
                            p: l
                        };
                        else if (Q(o) && !Q(l)) {
                            for (W = [], De = o.length, Me = De - 2, U = 1; U < De; U++) W.push(V(o[U - 1], o[U]));
                            De--, _ = function(et) {
                                et *= De;
                                var pe = Math.min(Me, ~~et);
                                return W[pe](et - pe)
                            }, f = l
                        } else h || (o = ge(Q(o) ? [] : {}, o));
                        if (!W) {
                            for (N in l) Ts.call(D, o, N, "get", l[N]);
                            _ = function(et) {
                                return xa(et, D) || (v ? o.p : o)
                            }
                        }
                    }
                    return be(f, _)
                },
                br = function(o, l, f) {
                    var h = o.labels,
                        _ = d,
                        v, D, N;
                    for (v in h) D = h[v] - l, D < 0 == !!f && D && _ > (D = Math.abs(D)) && (N = v, _ = D);
                    return N
                },
                nr = function(o, l, f) {
                    var h = o.vars,
                        _ = h[l],
                        v = p,
                        D = o._ctx,
                        N, U, W;
                    if (_) return N = h[l + "Params"], U = h.callbackScope || o, f && fe.length && un(), D && (p = D), W = N ? _.apply(U, N) : _.call(U), p = v, W
                },
                rr = function(o) {
                    return yt(o), o.scrollTrigger && o.scrollTrigger.kill(!!u), o.progress() < 1 && nr(o, "onInterrupt"), o
                },
                Vn, Ln = [],
                qn = function(o) {
                    if (o)
                        if (o = !o.name && o.default || o, xe() || o.headless) {
                            var l = o.name,
                                f = w(o),
                                h = l && !f && o.init ? function() {
                                    this._props = []
                                } : o,
                                _ = {
                                    init: ze,
                                    render: xa,
                                    add: Ts,
                                    kill: Ea,
                                    modifier: sl,
                                    rawVars: 0
                                },
                                v = {
                                    targetTest: 0,
                                    get: 0,
                                    getSetter: Da,
                                    aliases: {},
                                    register: 0
                                };
                            if (Es(), o !== h) {
                                if (Ie[l]) return;
                                Y(h, Y(Le(o, _), v)), ge(h.prototype, ge(_, Le(o, v))), Ie[h.prop = l] = h, o.targetTest && (je.push(h), I[l] = 1), l = (l === "css" ? "CSS" : l.charAt(0).toUpperCase() + l.substr(1)) + "Plugin"
                            }
                            oe(l, h), o.register && o.register(mn, h, Ai)
                        } else Ln.push(o)
                },
                Yt = 255,
                Cr = {
                    aqua: [0, Yt, Yt],
                    lime: [0, Yt, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, Yt],
                    navy: [0, 0, 128],
                    white: [Yt, Yt, Yt],
                    olive: [128, 128, 0],
                    yellow: [Yt, Yt, 0],
                    orange: [Yt, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [Yt, 0, 0],
                    pink: [Yt, 192, 203],
                    cyan: [0, Yt, Yt],
                    transparent: [Yt, Yt, Yt, 0]
                },
                oi = function(o, l, f) {
                    return o += o < 0 ? 1 : o > 1 ? -1 : 0, (o * 6 < 1 ? l + (f - l) * o * 6 : o < .5 ? f : o * 3 < 2 ? l + (f - l) * (2 / 3 - o) * 6 : l) * Yt + .5 | 0
                },
                ar = function(o, l, f) {
                    var h = o ? k(o) ? [o >> 16, o >> 8 & Yt, o & Yt] : 0 : Cr.black,
                        _, v, D, N, U, W, De, Me, $e, et;
                    if (!h) {
                        if (o.substr(-1) === "," && (o = o.substr(0, o.length - 1)), Cr[o]) h = Cr[o];
                        else if (o.charAt(0) === "#") {
                            if (o.length < 6 && (_ = o.charAt(1), v = o.charAt(2), D = o.charAt(3), o = "#" + _ + _ + v + v + D + D + (o.length === 5 ? o.charAt(4) + o.charAt(4) : "")), o.length === 9) return h = parseInt(o.substr(1, 6), 16), [h >> 16, h >> 8 & Yt, h & Yt, parseInt(o.substr(7), 16) / 255];
                            o = parseInt(o.substr(1), 16), h = [o >> 16, o >> 8 & Yt, o & Yt]
                        } else if (o.substr(0, 3) === "hsl") {
                            if (h = et = o.match(ne), !l) N = +h[0] % 360 / 360, U = +h[1] / 100, W = +h[2] / 100, v = W <= .5 ? W * (U + 1) : W + U - W * U, _ = W * 2 - v, h.length > 3 && (h[3] *= 1), h[0] = oi(N + 1 / 3, _, v), h[1] = oi(N, _, v), h[2] = oi(N - 1 / 3, _, v);
                            else if (~o.indexOf("=")) return h = o.match(re), f && h.length < 4 && (h[3] = 1), h
                        } else h = o.match(ne) || Cr.transparent;
                        h = h.map(Number)
                    }
                    return l && !et && (_ = h[0] / Yt, v = h[1] / Yt, D = h[2] / Yt, De = Math.max(_, v, D), Me = Math.min(_, v, D), W = (De + Me) / 2, De === Me ? N = U = 0 : ($e = De - Me, U = W > .5 ? $e / (2 - De - Me) : $e / (De + Me), N = De === _ ? (v - D) / $e + (v < D ? 6 : 0) : De === v ? (D - _) / $e + 2 : (_ - v) / $e + 4, N *= 60), h[0] = ~~(N + .5), h[1] = ~~(U * 100 + .5), h[2] = ~~(W * 100 + .5)), f && h.length < 4 && (h[3] = 1), h
                },
                Pi = function(o) {
                    var l = [],
                        f = [],
                        h = -1;
                    return o.split(Gn).forEach(function(_) {
                        var v = _.match(K) || [];
                        l.push.apply(l, v), f.push(h += v.length + 1)
                    }), l.c = f, l
                },
                zn = function(o, l, f) {
                    var h = "",
                        _ = (o + h).match(Gn),
                        v = l ? "hsla(" : "rgba(",
                        D = 0,
                        N, U, W, De;
                    if (!_) return o;
                    if (_ = _.map(function(Me) {
                            return (Me = ar(Me, l, 1)) && v + (l ? Me[0] + "," + Me[1] + "%," + Me[2] + "%," + Me[3] : Me.join(",")) + ")"
                        }), f && (W = Pi(o), N = f.c, N.join(h) !== W.c.join(h)))
                        for (U = o.replace(Gn, "1").split(K), De = U.length - 1; D < De; D++) h += U[D] + (~N.indexOf(D) ? _.shift() || v + "0,0,0,0)" : (W.length ? W : _.length ? _ : f).shift());
                    if (!U)
                        for (U = o.split(Gn), De = U.length - 1; D < De; D++) h += U[D] + _[D];
                    return h + U[De]
                },
                Gn = function() {
                    var V = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
                        o;
                    for (o in Cr) V += "|" + o + "\\b";
                    return new RegExp(V + ")", "gi")
                }(),
                xs = /hsl[a]?\(/,
                fn = function(o) {
                    var l = o.join(" "),
                        f;
                    if (Gn.lastIndex = 0, Gn.test(l)) return f = xs.test(l), o[1] = zn(o[1], f), o[0] = zn(o[0], f, Pi(o[1])), !0
                },
                Wr, En = function() {
                    var V = Date.now,
                        o = 500,
                        l = 33,
                        f = V(),
                        h = f,
                        _ = 1e3 / 240,
                        v = _,
                        D = [],
                        N, U, W, De, Me, $e, et = function pe(it) {
                            var Dt = V() - h,
                                xt = it === !0,
                                kt, At, vt, Vt;
                            if ((Dt > o || Dt < 0) && (f += Dt - l), h += Dt, vt = h - f, kt = vt - v, (kt > 0 || xt) && (Vt = ++De.frame, Me = vt - De.time * 1e3, De.time = vt = vt / 1e3, v += kt + (kt >= _ ? 4 : _ - kt), At = 1), xt || (N = U(pe)), At)
                                for ($e = 0; $e < D.length; $e++) D[$e](vt, Me, Vt, it)
                        };
                    return De = {
                        time: 0,
                        frame: 0,
                        tick: function() {
                            et(!0)
                        },
                        deltaRatio: function(it) {
                            return Me / (1e3 / (it || 60))
                        },
                        wake: function() {
                            Pt && (!ht && xe() && (tt = ht = window, lt = tt.document || {}, _t.gsap = mn, (tt.gsapVersions || (tt.gsapVersions = [])).push(mn.version), St(mt || tt.GreenSockGlobals || !tt.gsap && tt || {}), Ln.forEach(qn)), W = typeof requestAnimationFrame < "u" && requestAnimationFrame, N && De.sleep(), U = W || function(it) {
                                return setTimeout(it, v - De.time * 1e3 + 1 | 0)
                            }, Wr = 1, et(2))
                        },
                        sleep: function() {
                            (W ? cancelAnimationFrame : clearTimeout)(N), Wr = 0, U = ze
                        },
                        lagSmoothing: function(it, Dt) {
                            o = it || 1 / 0, l = Math.min(Dt || 33, o)
                        },
                        fps: function(it) {
                            _ = 1e3 / (it || 240), v = De.time * 1e3 + _
                        },
                        add: function(it, Dt, xt) {
                            var kt = Dt ? function(At, vt, Vt, zt) {
                                it(At, vt, Vt, zt), De.remove(kt)
                            } : it;
                            return De.remove(it), D[xt ? "unshift" : "push"](kt), Es(), kt
                        },
                        remove: function(it, Dt) {
                            ~(Dt = D.indexOf(it)) && D.splice(Dt, 1) && $e >= Dt && $e--
                        },
                        _listeners: D
                    }, De
                }(),
                Es = function() {
                    return !Wr && En.wake()
                },
                _n = {},
                bn = /^[\d.\-M][\d.\-,\s]/,
                $s = /["']/g,
                Js = function(o) {
                    for (var l = {}, f = o.substr(1, o.length - 3).split(":"), h = f[0], _ = 1, v = f.length, D, N, U; _ < v; _++) N = f[_], D = _ !== v - 1 ? N.lastIndexOf(",") : N.length, U = N.substr(0, D), l[h] = isNaN(U) ? U.replace($s, "").trim() : +U, h = N.substr(D + 1).trim();
                    return l
                },
                Vc = function(o) {
                    var l = o.indexOf("(") + 1,
                        f = o.indexOf(")"),
                        h = o.indexOf("(", l);
                    return o.substring(l, ~h && h < f ? o.indexOf(")", f + 1) : f)
                },
                fu = function(o) {
                    var l = (o + "").split("("),
                        f = _n[l[0]];
                    return f && l.length > 1 && f.config ? f.config.apply(null, ~o.indexOf("{") ? [Js(l[1])] : Vc(o).split(",").map(er)) : _n._CE && bn.test(o) ? _n._CE("", o) : f
                },
                Hs = function(o) {
                    return function(l) {
                        return 1 - o(1 - l)
                    }
                },
                ki = function V(o, l) {
                    for (var f = o._first, h; f;) f instanceof Zr ? V(f, l) : f.vars.yoyoEase && (!f._yoyo || !f._repeat) && f._yoyo !== l && (f.timeline ? V(f.timeline, l) : (h = f._ease, f._ease = f._yEase, f._yEase = h, f._yoyo = l)), f = f._next
                },
                Vs = function(o, l) {
                    return o && (w(o) ? o : _n[o] || fu(o)) || l
                },
                Cs = function(o, l, f, h) {
                    f === void 0 && (f = function(N) {
                        return 1 - l(1 - N)
                    }), h === void 0 && (h = function(N) {
                        return N < .5 ? l(N * 2) / 2 : 1 - l((1 - N) * 2) / 2
                    });
                    var _ = {
                            easeIn: l,
                            easeOut: f,
                            easeInOut: h
                        },
                        v;
                    return Et(o, function(D) {
                        _n[D] = _t[D] = _, _n[v = D.toLowerCase()] = f;
                        for (var N in _) _n[v + (N === "easeIn" ? ".in" : N === "easeOut" ? ".out" : ".inOut")] = _n[D + "." + N] = _[N]
                    }), _
                },
                el = function(o) {
                    return function(l) {
                        return l < .5 ? (1 - o(1 - l * 2)) / 2 : .5 + o((l - .5) * 2) / 2
                    }
                },
                ai = function V(o, l, f) {
                    var h = l >= 1 ? l : 1,
                        _ = (f || (o ? .3 : .45)) / (l < 1 ? l : 1),
                        v = _ / m * (Math.asin(1 / h) || 0),
                        D = function(W) {
                            return W === 1 ? 1 : h * Math.pow(2, -10 * W) * A((W - v) * _) + 1
                        },
                        N = o === "out" ? D : o === "in" ? function(U) {
                            return 1 - D(1 - U)
                        } : el(D);
                    return _ = m / _, N.config = function(U, W) {
                        return V(o, U, W)
                    }, N
                },
                Ss = function V(o, l) {
                    l === void 0 && (l = 1.70158);
                    var f = function(v) {
                            return v ? --v * v * ((l + 1) * v + l) + 1 : 0
                        },
                        h = o === "out" ? f : o === "in" ? function(_) {
                            return 1 - f(1 - _)
                        } : el(f);
                    return h.config = function(_) {
                        return V(o, _)
                    }, h
                };
            Et("Linear,Quad,Cubic,Quart,Quint,Strong", function(V, o) {
                    var l = o < 5 ? o + 1 : o;
                    Cs(V + ",Power" + (l - 1), o ? function(f) {
                        return Math.pow(f, l)
                    } : function(f) {
                        return f
                    }, function(f) {
                        return 1 - Math.pow(1 - f, l)
                    }, function(f) {
                        return f < .5 ? Math.pow(f * 2, l) / 2 : 1 - Math.pow((1 - f) * 2, l) / 2
                    })
                }), _n.Linear.easeNone = _n.none = _n.Linear.easeIn, Cs("Elastic", ai("in"), ai("out"), ai()),
                function(V, o) {
                    var l = 1 / o,
                        f = 2 * l,
                        h = 2.5 * l,
                        _ = function(D) {
                            return D < l ? V * D * D : D < f ? V * Math.pow(D - 1.5 / o, 2) + .75 : D < h ? V * (D -= 2.25 / o) * D + .9375 : V * Math.pow(D - 2.625 / o, 2) + .984375
                        };
                    Cs("Bounce", function(v) {
                        return 1 - _(1 - v)
                    }, _)
                }(7.5625, 2.75), Cs("Expo", function(V) {
                    return Math.pow(2, 10 * (V - 1)) * V + V * V * V * V * V * V * (1 - V)
                }), Cs("Circ", function(V) {
                    return -(b(1 - V * V) - 1)
                }), Cs("Sine", function(V) {
                    return V === 1 ? 1 : -j(V * E) + 1
                }), Cs("Back", Ss("in"), Ss("out"), Ss()), _n.SteppedEase = _n.steps = _t.SteppedEase = {
                    config: function(o, l) {
                        o === void 0 && (o = 1);
                        var f = 1 / o,
                            h = o + (l ? 0 : 1),
                            _ = l ? 1 : 0,
                            v = 1 - g;
                        return function(D) {
                            return ((h * Ce(0, v, D) | 0) + _) * f
                        }
                    }
                }, a.ease = _n["quad.out"], Et("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(V) {
                    return We += V + "," + V + "Params,"
                });
            var tl = function(o, l) {
                    this.id = L++, o._gsap = this, this.target = o, this.harness = l, this.get = l ? l.get : wt, this.set = l ? l.getSetter : Da
                },
                Yo = function() {
                    function V(l) {
                        this.vars = l, this._delay = +l.delay || 0, (this._repeat = l.repeat === 1 / 0 ? -2 : l.repeat || 0) && (this._rDelay = l.repeatDelay || 0, this._yoyo = !!l.yoyo || !!l.yoyoEase), this._ts = 1, x(this, +l.duration, 1, 1), this.data = l.data, p && (this._ctx = p, p.data.push(this)), Wr || En.wake()
                    }
                    var o = V.prototype;
                    return o.delay = function(f) {
                        return f || f === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + f - this._delay), this._delay = f, this) : this._delay
                    }, o.duration = function(f) {
                        return arguments.length ? this.totalDuration(this._repeat > 0 ? f + (f + this._rDelay) * this._repeat : f) : this.totalDuration() && this._dur
                    }, o.totalDuration = function(f) {
                        return arguments.length ? (this._dirty = 0, x(this, this._repeat < 0 ? f : (f - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                    }, o.totalTime = function(f, h) {
                        if (Es(), !arguments.length) return this._tTime;
                        var _ = this._dp;
                        if (_ && _.smoothChildTiming && this._ts) {
                            for (T(this, f), !_._dp || _.parent || z(_, this); _ && _.parent;) _.parent._time !== _._start + (_._ts >= 0 ? _._tTime / _._ts : (_.totalDuration() - _._tTime) / -_._ts) && _.totalTime(_._tTime, !0), _ = _.parent;
                            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && f < this._tDur || this._ts < 0 && f > 0 || !this._tDur && !f) && R(this._dp, this, this._start - this._delay)
                        }
                        return (this._tTime !== f || !this._dur && !h || this._initted && Math.abs(this._zTime) === g || !f && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = f), Un(this, f, h)), this
                    }, o.time = function(f, h) {
                        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), f + ut(this)) % (this._dur + this._rDelay) || (f ? this._dur : 0), h) : this._time
                    }, o.totalProgress = function(f, h) {
                        return arguments.length ? this.totalTime(this.totalDuration() * f, h) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0
                    }, o.progress = function(f, h) {
                        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - f : f) + ut(this), h) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
                    }, o.iteration = function(f, h) {
                        var _ = this.duration() + this._rDelay;
                        return arguments.length ? this.totalTime(this._time + (f - 1) * _, h) : this._repeat ? pt(this._tTime, _) + 1 : 1
                    }, o.timeScale = function(f, h) {
                        if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts;
                        if (this._rts === f) return this;
                        var _ = this.parent && this._ts ? Qe(this.parent._time, this) : this._tTime;
                        return this._rts = +f || 0, this._ts = this._ps || f === -1e-8 ? 0 : this._rts, this.totalTime(Ce(-Math.abs(this._delay), this.totalDuration(), _), h !== !1), Re(this), He(this)
                    }, o.paused = function(f) {
                        return arguments.length ? (this._ps !== f && (this._ps = f, f ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Es(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== g && (this._tTime -= g)))), this) : this._ps
                    }, o.startTime = function(f) {
                        if (arguments.length) {
                            this._start = f;
                            var h = this.parent || this._dp;
                            return h && (h._sort || !this.parent) && R(h, this, f - this._delay), this
                        }
                        return this._start
                    }, o.endTime = function(f) {
                        return this._start + (J(f) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                    }, o.rawTime = function(f) {
                        var h = this.parent || this._dp;
                        return h ? f && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Qe(h.rawTime(f), this) : this._tTime : this._tTime
                    }, o.revert = function(f) {
                        f === void 0 && (f = M);
                        var h = u;
                        return u = f, An(this) && (this.timeline && this.timeline.revert(f), this.totalTime(-.01, f.suppressEvents)), this.data !== "nested" && f.kill !== !1 && this.kill(), u = h, this
                    }, o.globalTime = function(f) {
                        for (var h = this, _ = arguments.length ? f : h.rawTime(); h;) _ = h._start + _ / (Math.abs(h._ts) || 1), h = h._dp;
                        return !this.parent && this._sat ? this._sat.globalTime(f) : _
                    }, o.repeat = function(f) {
                        return arguments.length ? (this._repeat = f === 1 / 0 ? -2 : f, P(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
                    }, o.repeatDelay = function(f) {
                        if (arguments.length) {
                            var h = this._time;
                            return this._rDelay = f, P(this), h ? this.time(h) : this
                        }
                        return this._rDelay
                    }, o.yoyo = function(f) {
                        return arguments.length ? (this._yoyo = f, this) : this._yoyo
                    }, o.seek = function(f, h) {
                        return this.totalTime(q(this, f), J(h))
                    }, o.restart = function(f, h) {
                        return this.play().totalTime(f ? -this._delay : 0, J(h)), this._dur || (this._zTime = -1e-8), this
                    }, o.play = function(f, h) {
                        return f != null && this.seek(f, h), this.reversed(!1).paused(!1)
                    }, o.reverse = function(f, h) {
                        return f != null && this.seek(f || this.totalDuration(), h), this.reversed(!0).paused(!1)
                    }, o.pause = function(f, h) {
                        return f != null && this.seek(f, h), this.paused(!0)
                    }, o.resume = function() {
                        return this.paused(!1)
                    }, o.reversed = function(f) {
                        return arguments.length ? (!!f !== this.reversed() && this.timeScale(-this._rts || (f ? -1e-8 : 0)), this) : this._rts < 0
                    }, o.invalidate = function() {
                        return this._initted = this._act = 0, this._zTime = -1e-8, this
                    }, o.isActive = function() {
                        var f = this.parent || this._dp,
                            h = this._start,
                            _;
                        return !!(!f || this._ts && this._initted && f.isActive() && (_ = f.rawTime(!0)) >= h && _ < this.endTime(!0) - g)
                    }, o.eventCallback = function(f, h, _) {
                        var v = this.vars;
                        return arguments.length > 1 ? (h ? (v[f] = h, _ && (v[f + "Params"] = _), f === "onUpdate" && (this._onUpdate = h)) : delete v[f], this) : v[f]
                    }, o.then = function(f) {
                        var h = this;
                        return new Promise(function(_) {
                            var v = w(f) ? f : ft,
                                D = function() {
                                    var U = h.then;
                                    h.then = null, w(v) && (v = v(h)) && (v.then || v === h) && (h.then = U), _(v), h.then = U
                                };
                            h._initted && h.totalProgress() === 1 && h._ts >= 0 || !h._tTime && h._ts < 0 ? D() : h._prom = D
                        })
                    }, o.kill = function() {
                        rr(this)
                    }, V
                }();
            Y(Yo.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: null,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -1e-8,
                _prom: 0,
                _ps: !1,
                _rts: 1
            });
            var Zr = function(V) {
                r(o, V);

                function o(f, h) {
                    var _;
                    return f === void 0 && (f = {}), _ = V.call(this, f) || this, _.labels = {}, _.smoothChildTiming = !!f.smoothChildTiming, _.autoRemoveChildren = !!f.autoRemoveChildren, _._sort = J(f.sortChildren), ve && R(f.parent || ve, i(_), h), f.reversed && _.reverse(), f.paused && _.paused(!0), f.scrollTrigger && ee(i(_), f.scrollTrigger), _
                }
                var l = o.prototype;
                return l.to = function(h, _, v) {
                    return ue(0, arguments, this), this
                }, l.from = function(h, _, v) {
                    return ue(1, arguments, this), this
                }, l.fromTo = function(h, _, v, D) {
                    return ue(2, arguments, this), this
                }, l.set = function(h, _, v) {
                    return _.duration = 0, _.parent = this, Ee(_).repeatDelay || (_.repeat = 0), _.immediateRender = !!_.immediateRender, new Lr(h, _, q(this, v), 1), this
                }, l.call = function(h, _, v) {
                    return R(this, Lr.delayedCall(0, h, _), v)
                }, l.staggerTo = function(h, _, v, D, N, U, W) {
                    return v.duration = _, v.stagger = v.stagger || D, v.onComplete = U, v.onCompleteParams = W, v.parent = this, new Lr(h, v, q(this, N)), this
                }, l.staggerFrom = function(h, _, v, D, N, U, W) {
                    return v.runBackwards = 1, Ee(v).immediateRender = J(v.immediateRender), this.staggerTo(h, _, v, D, N, U, W)
                }, l.staggerFromTo = function(h, _, v, D, N, U, W, De) {
                    return D.startAt = v, Ee(D).immediateRender = J(D.immediateRender), this.staggerTo(h, _, D, N, U, W, De)
                }, l.render = function(h, _, v) {
                    var D = this._time,
                        N = this._dirty ? this.totalDuration() : this._tDur,
                        U = this._dur,
                        W = h <= 0 ? 0 : qt(h),
                        De = this._zTime < 0 != h < 0 && (this._initted || !U),
                        Me, $e, et, pe, it, Dt, xt, kt, At, vt, Vt, zt;
                    if (this !== ve && W > N && h >= 0 && (W = N), W !== this._tTime || v || De) {
                        if (D !== this._time && U && (W += this._time - D, h += this._time - D), Me = W, At = this._start, kt = this._ts, Dt = !kt, De && (U || (D = this._zTime), (h || !_) && (this._zTime = h)), this._repeat) {
                            if (Vt = this._yoyo, it = U + this._rDelay, this._repeat < -1 && h < 0) return this.totalTime(it * 100 + h, _, v);
                            if (Me = qt(W % it), W === N ? (pe = this._repeat, Me = U) : (vt = qt(W / it), pe = ~~vt, pe && pe === vt && (Me = U, pe--), Me > U && (Me = U)), vt = pt(this._tTime, it), !D && this._tTime && vt !== pe && this._tTime - vt * it - this._dur <= 0 && (vt = pe), Vt && pe & 1 && (Me = U - Me, zt = 1), pe !== vt && !this._lock) {
                                var Ut = Vt && vt & 1,
                                    Rt = Ut === (Vt && pe & 1);
                                if (pe < vt && (Ut = !Ut), D = Ut ? 0 : W % U ? U : W, this._lock = 1, this.render(D || (zt ? 0 : qt(pe * it)), _, !U)._lock = 0, this._tTime = W, !_ && this.parent && nr(this, "onRepeat"), this.vars.repeatRefresh && !zt && (this.invalidate()._lock = 1), D && D !== this._time || Dt !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                                if (U = this._dur, N = this._tDur, Rt && (this._lock = 2, D = Ut ? U : -1e-4, this.render(D, !0), this.vars.repeatRefresh && !zt && this.invalidate()), this._lock = 0, !this._ts && !Dt) return this;
                                ki(this, zt)
                            }
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (xt = y(this, qt(D), qt(Me)), xt && (W -= Me - (Me = xt._start))), this._tTime = W, this._time = Me, this._act = !kt, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = h, D = 0), !D && W && !_ && !vt && (nr(this, "onStart"), this._tTime !== W)) return this;
                        if (Me >= D && h >= 0)
                            for ($e = this._first; $e;) {
                                if (et = $e._next, ($e._act || Me >= $e._start) && $e._ts && xt !== $e) {
                                    if ($e.parent !== this) return this.render(h, _, v);
                                    if ($e.render($e._ts > 0 ? (Me - $e._start) * $e._ts : ($e._dirty ? $e.totalDuration() : $e._tDur) + (Me - $e._start) * $e._ts, _, v), Me !== this._time || !this._ts && !Dt) {
                                        xt = 0, et && (W += this._zTime = -1e-8);
                                        break
                                    }
                                }
                                $e = et
                            } else {
                                $e = this._last;
                                for (var Yn = h < 0 ? h : Me; $e;) {
                                    if (et = $e._prev, ($e._act || Yn <= $e._end) && $e._ts && xt !== $e) {
                                        if ($e.parent !== this) return this.render(h, _, v);
                                        if ($e.render($e._ts > 0 ? (Yn - $e._start) * $e._ts : ($e._dirty ? $e.totalDuration() : $e._tDur) + (Yn - $e._start) * $e._ts, _, v || u && An($e)), Me !== this._time || !this._ts && !Dt) {
                                            xt = 0, et && (W += this._zTime = Yn ? -1e-8 : g);
                                            break
                                        }
                                    }
                                    $e = et
                                }
                            }
                        if (xt && !_ && (this.pause(), xt.render(Me >= D ? 0 : -1e-8)._zTime = Me >= D ? 1 : -1, this._ts)) return this._start = At, Re(this), this.render(h, _, v);
                        this._onUpdate && !_ && nr(this, "onUpdate", !0), (W === N && this._tTime >= this.totalDuration() || !W && D) && (At === this._start || Math.abs(kt) !== Math.abs(this._ts)) && (this._lock || ((h || !U) && (W === N && this._ts > 0 || !W && this._ts < 0) && yt(this, 1), !_ && !(h < 0 && !D) && (W || D || !N) && (nr(this, W === N && h >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(W < N && this.timeScale() > 0) && this._prom())))
                    }
                    return this
                }, l.add = function(h, _) {
                    var v = this;
                    if (k(_) || (_ = q(this, _, h)), !(h instanceof Yo)) {
                        if (Q(h)) return h.forEach(function(D) {
                            return v.add(D, _)
                        }), this;
                        if ($(h)) return this.addLabel(h, _);
                        if (w(h)) h = Lr.delayedCall(0, h);
                        else return this
                    }
                    return this !== h ? R(this, h, _) : this
                }, l.getChildren = function(h, _, v, D) {
                    h === void 0 && (h = !0), _ === void 0 && (_ = !0), v === void 0 && (v = !0), D === void 0 && (D = -1e8);
                    for (var N = [], U = this._first; U;) U._start >= D && (U instanceof Lr ? _ && N.push(U) : (v && N.push(U), h && N.push.apply(N, U.getChildren(!0, _, v)))), U = U._next;
                    return N
                }, l.getById = function(h) {
                    for (var _ = this.getChildren(1, 1, 1), v = _.length; v--;)
                        if (_[v].vars.id === h) return _[v]
                }, l.remove = function(h) {
                    return $(h) ? this.removeLabel(h) : w(h) ? this.killTweensOf(h) : (h.parent === this && Ve(this, h), h === this._recent && (this._recent = this._last), rt(this))
                }, l.totalTime = function(h, _) {
                    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = qt(En.time - (this._ts > 0 ? h / this._ts : (this.totalDuration() - h) / -this._ts))), V.prototype.totalTime.call(this, h, _), this._forcing = 0, this) : this._tTime
                }, l.addLabel = function(h, _) {
                    return this.labels[h] = q(this, _), this
                }, l.removeLabel = function(h) {
                    return delete this.labels[h], this
                }, l.addPause = function(h, _, v) {
                    var D = Lr.delayedCall(0, _ || ze, v);
                    return D.data = "isPause", this._hasPause = 1, R(this, D, q(this, h))
                }, l.removePause = function(h) {
                    var _ = this._first;
                    for (h = q(this, h); _;) _._start === h && _.data === "isPause" && yt(_), _ = _._next
                }, l.killTweensOf = function(h, _, v) {
                    for (var D = this.getTweensOf(h, v), N = D.length; N--;) Ji !== D[N] && D[N].kill(h, _);
                    return this
                }, l.getTweensOf = function(h, _) {
                    for (var v = [], D = ct(h), N = this._first, U = k(_), W; N;) N instanceof Lr ? Rn(N._targets, D) && (U ? (!Ji || N._initted && N._ts) && N.globalTime(0) <= _ && N.globalTime(N.totalDuration()) > _ : !_ || N.isActive()) && v.push(N) : (W = N.getTweensOf(D, _)).length && v.push.apply(v, W), N = N._next;
                    return v
                }, l.tweenTo = function(h, _) {
                    _ = _ || {};
                    var v = this,
                        D = q(v, h),
                        N = _,
                        U = N.startAt,
                        W = N.onStart,
                        De = N.onStartParams,
                        Me = N.immediateRender,
                        $e, et = Lr.to(v, Y({
                            ease: _.ease || "none",
                            lazy: !1,
                            immediateRender: !1,
                            time: D,
                            overwrite: "auto",
                            duration: _.duration || Math.abs((D - (U && "time" in U ? U.time : v._time)) / v.timeScale()) || g,
                            onStart: function() {
                                if (v.pause(), !$e) {
                                    var it = _.duration || Math.abs((D - (U && "time" in U ? U.time : v._time)) / v.timeScale());
                                    et._dur !== it && x(et, it, 0, 1).render(et._time, !0, !0), $e = 1
                                }
                                W && W.apply(et, De || [])
                            }
                        }, _));
                    return Me ? et.render(0) : et
                }, l.tweenFromTo = function(h, _, v) {
                    return this.tweenTo(_, Y({
                        startAt: {
                            time: q(this, h)
                        }
                    }, v))
                }, l.recent = function() {
                    return this._recent
                }, l.nextLabel = function(h) {
                    return h === void 0 && (h = this._time), br(this, q(this, h))
                }, l.previousLabel = function(h) {
                    return h === void 0 && (h = this._time), br(this, q(this, h), 1)
                }, l.currentLabel = function(h) {
                    return arguments.length ? this.seek(h, !0) : this.previousLabel(this._time + g)
                }, l.shiftChildren = function(h, _, v) {
                    v === void 0 && (v = 0);
                    for (var D = this._first, N = this.labels, U; D;) D._start >= v && (D._start += h, D._end += h), D = D._next;
                    if (_)
                        for (U in N) N[U] >= v && (N[U] += h);
                    return rt(this)
                }, l.invalidate = function(h) {
                    var _ = this._first;
                    for (this._lock = 0; _;) _.invalidate(h), _ = _._next;
                    return V.prototype.invalidate.call(this, h)
                }, l.clear = function(h) {
                    h === void 0 && (h = !0);
                    for (var _ = this._first, v; _;) v = _._next, this.remove(_), _ = v;
                    return this._dp && (this._time = this._tTime = this._pTime = 0), h && (this.labels = {}), rt(this)
                }, l.totalDuration = function(h) {
                    var _ = 0,
                        v = this,
                        D = v._last,
                        N = d,
                        U, W, De;
                    if (arguments.length) return v.timeScale((v._repeat < 0 ? v.duration() : v.totalDuration()) / (v.reversed() ? -h : h));
                    if (v._dirty) {
                        for (De = v.parent; D;) U = D._prev, D._dirty && D.totalDuration(), W = D._start, W > N && v._sort && D._ts && !v._lock ? (v._lock = 1, R(v, D, W - D._delay, 1)._lock = 0) : N = W, W < 0 && D._ts && (_ -= W, (!De && !v._dp || De && De.smoothChildTiming) && (v._start += W / v._ts, v._time -= W, v._tTime -= W), v.shiftChildren(-W, !1, -1 / 0), N = 0), D._end > _ && D._ts && (_ = D._end), D = U;
                        x(v, v === ve && v._time > _ ? v._time : _, 1, 1), v._dirty = 0
                    }
                    return v._tDur
                }, o.updateRoot = function(h) {
                    if (ve._ts && (Un(ve, Qe(h, ve)), Te = En.frame), En.frame >= nt) {
                        nt += s.autoSleep || 120;
                        var _ = ve._first;
                        if ((!_ || !_._ts) && s.autoSleep && En._listeners.length < 2) {
                            for (; _ && !_._ts;) _ = _._next;
                            _ || En.sleep()
                        }
                    }
                }, o
            }(Yo);
            Y(Zr.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });
            var hu = function(o, l, f, h, _, v, D) {
                    var N = new Ai(this._pt, o, l, 0, 1, Cn, null, _),
                        U = 0,
                        W = 0,
                        De, Me, $e, et, pe, it, Dt, xt;
                    for (N.b = f, N.e = h, f += "", h += "", (Dt = ~h.indexOf("random(")) && (h = tr(h)), v && (xt = [f, h], v(xt, o, l), f = xt[0], h = xt[1]), Me = f.match(te) || []; De = te.exec(h);) et = De[0], pe = h.substring(U, De.index), $e ? $e = ($e + 1) % 5 : pe.substr(-5) === "rgba(" && ($e = 1), et !== Me[W++] && (it = parseFloat(Me[W - 1]) || 0, N._pt = {
                        _next: N._pt,
                        p: pe || W === 1 ? pe : ",",
                        s: it,
                        c: et.charAt(1) === "=" ? an(it, et) - it : parseFloat(et) - it,
                        m: $e && $e < 4 ? Math.round : 0
                    }, U = te.lastIndex);
                    return N.c = U < h.length ? h.substring(U, h.length) : "", N.fp = D, (G.test(h) || Dt) && (N.e = 0), this._pt = N, N
                },
                Ts = function(o, l, f, h, _, v, D, N, U, W) {
                    w(h) && (h = h(_ || 0, o, v));
                    var De = o[l],
                        Me = f !== "get" ? f : w(De) ? U ? o[l.indexOf("set") || !w(o["get" + l.substr(3)]) ? l : "get" + l.substr(3)](U) : o[l]() : De,
                        $e = w(De) ? U ? jc : il : bo,
                        et;
                    if ($(h) && (~h.indexOf("random(") && (h = tr(h)), h.charAt(1) === "=" && (et = an(Me, h) + (se(Me) || 0), (et || et === 0) && (h = et))), !W || Me !== h || os) return !isNaN(Me * h) && h !== "" ? (et = new Ai(this._pt, o, l, +Me || 0, h - (Me || 0), typeof De == "boolean" ? pu : Zo, 0, $e), U && (et.fp = U), D && et.modifier(D, this, o), this._pt = et) : (!De && !(l in o) && de(l, h), hu.call(this, o, l, Me, h, $e, N || s.stringFilter, U))
                },
                nl = function(o, l, f, h, _) {
                    if (w(o) && (o = Qo(o, _, l, f, h)), !X(o) || o.style && o.nodeType || Q(o) || me(o)) return $(o) ? Qo(o, _, l, f, h) : o;
                    var v = {},
                        D;
                    for (D in o) v[D] = Qo(o[D], _, l, f, h);
                    return v
                },
                Xo = function(o, l, f, h, _, v) {
                    var D, N, U, W;
                    if (Ie[o] && (D = new Ie[o]).init(_, D.rawVars ? l[o] : nl(l[o], h, _, v, f), f, h, v) !== !1 && (f._pt = N = new Ai(f._pt, _, o, 0, 1, D.render, D, 0, D.priority), f !== Vn))
                        for (U = f._ptLookup[f._targets.indexOf(_)], W = D._props.length; W--;) U[D._props[W]] = N;
                    return D
                },
                Ji, os, Ko = function V(o, l, f) {
                    var h = o.vars,
                        _ = h.ease,
                        v = h.startAt,
                        D = h.immediateRender,
                        N = h.lazy,
                        U = h.onUpdate,
                        W = h.runBackwards,
                        De = h.yoyoEase,
                        Me = h.keyframes,
                        $e = h.autoRevert,
                        et = o._dur,
                        pe = o._startAt,
                        it = o._targets,
                        Dt = o.parent,
                        xt = Dt && Dt.data === "nested" ? Dt.vars.targets : it,
                        kt = o._overwrite === "auto" && !c,
                        At = o.timeline,
                        vt, Vt, zt, Ut, Rt, Yn, Or, pr, gr, Ti, vi, ii, bi;
                    if (At && (!Me || !_) && (_ = "none"), o._ease = Vs(_, a.ease), o._yEase = De ? Hs(Vs(De === !0 ? _ : De, a.ease)) : 0, De && o._yoyo && !o._repeat && (De = o._yEase, o._yEase = o._ease, o._ease = De), o._from = !At && !!h.runBackwards, !At || Me && !h.stagger) {
                        if (pr = it[0] ? Ze(it[0]).harness : 0, ii = pr && h[pr.prop], vt = Le(h, I), pe && (pe._zTime < 0 && pe.progress(1), l < 0 && W && D && !$e ? pe.render(-1, !0) : pe.revert(W && et ? Ke : Se), pe._lazy = 0), v) {
                            if (yt(o._startAt = Lr.set(it, Y({
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: Dt,
                                    immediateRender: !0,
                                    lazy: !pe && J(N),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: U && function() {
                                        return nr(o, "onUpdate")
                                    },
                                    stagger: 0
                                }, v))), o._startAt._dp = 0, o._startAt._sat = o, l < 0 && (u || !D && !$e) && o._startAt.revert(Ke), D && et && l <= 0 && f <= 0) {
                                l && (o._zTime = l);
                                return
                            }
                        } else if (W && et && !pe) {
                            if (l && (D = !1), zt = Y({
                                    overwrite: !1,
                                    data: "isFromStart",
                                    lazy: D && !pe && J(N),
                                    immediateRender: D,
                                    stagger: 0,
                                    parent: Dt
                                }, vt), ii && (zt[pr.prop] = ii), yt(o._startAt = Lr.set(it, zt)), o._startAt._dp = 0, o._startAt._sat = o, l < 0 && (u ? o._startAt.revert(Ke) : o._startAt.render(-1, !0)), o._zTime = l, !D) V(o._startAt, g, g);
                            else if (!l) return
                        }
                        for (o._pt = o._ptCache = 0, N = et && J(N) || N && !et, Vt = 0; Vt < it.length; Vt++) {
                            if (Rt = it[Vt], Or = Rt._gsap || bt(it)[Vt]._gsap, o._ptLookup[Vt] = Ti = {}, Oe[Or.id] && fe.length && un(), vi = xt === it ? Vt : xt.indexOf(Rt), pr && (gr = new pr).init(Rt, ii || vt, o, vi, xt) !== !1 && (o._pt = Ut = new Ai(o._pt, Rt, gr.name, 0, 1, gr.render, gr, 0, gr.priority), gr._props.forEach(function(Rs) {
                                    Ti[Rs] = Ut
                                }), gr.priority && (Yn = 1)), !pr || ii)
                                for (zt in vt) Ie[zt] && (gr = Xo(zt, vt, o, vi, Rt, xt)) ? gr.priority && (Yn = 1) : Ti[zt] = Ut = Ts.call(o, Rt, zt, "get", vt[zt], vi, xt, 0, h.stringFilter);
                            o._op && o._op[Vt] && o.kill(Rt, o._op[Vt]), kt && o._pt && (Ji = o, ve.killTweensOf(Rt, Ti, o.globalTime(l)), bi = !o.parent, Ji = 0), o._pt && N && (Oe[Or.id] = 1)
                        }
                        Yn && ol(o), o._onInit && o._onInit(o)
                    }
                    o._onUpdate = U, o._initted = (!o._op || o._pt) && !bi, Me && l <= 0 && At.render(d, !0, !0)
                },
                wa = function(o, l, f, h, _, v, D, N) {
                    var U = (o._pt && o._ptCache || (o._ptCache = {}))[l],
                        W, De, Me, $e;
                    if (!U)
                        for (U = o._ptCache[l] = [], Me = o._ptLookup, $e = o._targets.length; $e--;) {
                            if (W = Me[$e][l], W && W.d && W.d._pt)
                                for (W = W.d._pt; W && W.p !== l && W.fp !== l;) W = W._next;
                            if (!W) return os = 1, o.vars[l] = "+=0", Ko(o, D), os = 0, N ? ye(l + " not eligible for reset") : 1;
                            U.push(W)
                        }
                    for ($e = U.length; $e--;) De = U[$e], W = De._pt || De, W.s = (h || h === 0) && !_ ? h : W.s + (h || 0) + v * W.c, W.c = f - W.s, De.e && (De.e = Ot(f) + se(De.e)), De.b && (De.b = W.s + se(De.b))
                },
                zc = function(o, l) {
                    var f = o[0] ? Ze(o[0]).harness : 0,
                        h = f && f.aliases,
                        _, v, D, N;
                    if (!h) return l;
                    _ = ge({}, l);
                    for (v in h)
                        if (v in _)
                            for (N = h[v].split(","), D = N.length; D--;) _[N[D]] = _[v];
                    return _
                },
                rl = function(o, l, f, h) {
                    var _ = l.ease || h || "power1.inOut",
                        v, D;
                    if (Q(l)) D = f[o] || (f[o] = []), l.forEach(function(N, U) {
                        return D.push({
                            t: U / (l.length - 1) * 100,
                            v: N,
                            e: _
                        })
                    });
                    else
                        for (v in l) D = f[v] || (f[v] = []), v === "ease" || D.push({
                            t: parseFloat(o),
                            v: l[v],
                            e: _
                        })
                },
                Qo = function(o, l, f, h, _) {
                    return w(o) ? o.call(l, f, h, _) : $(o) && ~o.indexOf("random(") ? tr(o) : o
                },
                Zs = We + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
                Jo = {};
            Et(Zs + ",id,stagger,delay,duration,paused,scrollTrigger", function(V) {
                return Jo[V] = 1
            });
            var Lr = function(V) {
                r(o, V);

                function o(f, h, _, v) {
                    var D;
                    typeof h == "number" && (_.duration = h, h = _, _ = null), D = V.call(this, v ? h : Ee(h)) || this;
                    var N = D.vars,
                        U = N.duration,
                        W = N.delay,
                        De = N.immediateRender,
                        Me = N.stagger,
                        $e = N.overwrite,
                        et = N.keyframes,
                        pe = N.defaults,
                        it = N.scrollTrigger,
                        Dt = N.yoyoEase,
                        xt = h.parent || ve,
                        kt = (Q(f) || me(f) ? k(f[0]) : "length" in h) ? [f] : ct(f),
                        At, vt, Vt, zt, Ut, Rt, Yn, Or;
                    if (D._targets = kt.length ? bt(kt) : ye("GSAP target " + f + " not found. https://gsap.com", !s.nullTargetWarn) || [], D._ptLookup = [], D._overwrite = $e, et || Me || he(U) || he(W)) {
                        if (h = D.vars, At = D.timeline = new Zr({
                                data: "nested",
                                defaults: pe || {},
                                targets: xt && xt.data === "nested" ? xt.vars.targets : kt
                            }), At.kill(), At.parent = At._dp = i(D), At._start = 0, Me || he(U) || he(W)) {
                            if (zt = kt.length, Yn = Me && Lt(Me), X(Me))
                                for (Ut in Me) ~Zs.indexOf(Ut) && (Or || (Or = {}), Or[Ut] = Me[Ut]);
                            for (vt = 0; vt < zt; vt++) Vt = Le(h, Jo), Vt.stagger = 0, Dt && (Vt.yoyoEase = Dt), Or && ge(Vt, Or), Rt = kt[vt], Vt.duration = +Qo(U, i(D), vt, Rt, kt), Vt.delay = (+Qo(W, i(D), vt, Rt, kt) || 0) - D._delay, !Me && zt === 1 && Vt.delay && (D._delay = W = Vt.delay, D._start += W, Vt.delay = 0), At.to(Rt, Vt, Yn ? Yn(vt, Rt, kt) : 0), At._ease = _n.none;
                            At.duration() ? U = W = 0 : D.timeline = 0
                        } else if (et) {
                            Ee(Y(At.vars.defaults, {
                                ease: "none"
                            })), At._ease = Vs(et.ease || h.ease || "none");
                            var pr = 0,
                                gr, Ti, vi;
                            if (Q(et)) et.forEach(function(ii) {
                                return At.to(kt, ii, ">")
                            }), At.duration();
                            else {
                                Vt = {};
                                for (Ut in et) Ut === "ease" || Ut === "easeEach" || rl(Ut, et[Ut], Vt, et.easeEach);
                                for (Ut in Vt)
                                    for (gr = Vt[Ut].sort(function(ii, bi) {
                                            return ii.t - bi.t
                                        }), pr = 0, vt = 0; vt < gr.length; vt++) Ti = gr[vt], vi = {
                                        ease: Ti.e,
                                        duration: (Ti.t - (vt ? gr[vt - 1].t : 0)) / 100 * U
                                    }, vi[Ut] = Ti.v, At.to(kt, vi, pr), pr += vi.duration;
                                At.duration() < U && At.to({}, {
                                    duration: U - At.duration()
                                })
                            }
                        }
                        U || D.duration(U = At.duration())
                    } else D.timeline = 0;
                    return $e === !0 && !c && (Ji = i(D), ve.killTweensOf(kt), Ji = 0), R(xt, i(D), _), h.reversed && D.reverse(), h.paused && D.paused(!0), (De || !U && !et && D._start === qt(xt._time) && J(De) && Mt(i(D)) && xt.data !== "nested") && (D._tTime = -1e-8, D.render(Math.max(0, -W) || 0)), it && ee(i(D), it), D
                }
                var l = o.prototype;
                return l.render = function(h, _, v) {
                    var D = this._time,
                        N = this._tDur,
                        U = this._dur,
                        W = h < 0,
                        De = h > N - g && !W ? N : h < g ? 0 : h,
                        Me, $e, et, pe, it, Dt, xt, kt, At;
                    if (!U) O(this, h, _, v);
                    else if (De !== this._tTime || !h || v || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== W || this._lazy) {
                        if (Me = De, kt = this.timeline, this._repeat) {
                            if (pe = U + this._rDelay, this._repeat < -1 && W) return this.totalTime(pe * 100 + h, _, v);
                            if (Me = qt(De % pe), De === N ? (et = this._repeat, Me = U) : (it = qt(De / pe), et = ~~it, et && et === it ? (Me = U, et--) : Me > U && (Me = U)), Dt = this._yoyo && et & 1, Dt && (At = this._yEase, Me = U - Me), it = pt(this._tTime, pe), Me === D && !v && this._initted && et === it) return this._tTime = De, this;
                            et !== it && (kt && this._yEase && ki(kt, Dt), this.vars.repeatRefresh && !Dt && !this._lock && Me !== pe && this._initted && (this._lock = v = 1, this.render(qt(pe * et), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (ae(this, W ? h : Me, v, _, De)) return this._tTime = 0, this;
                            if (D !== this._time && !(v && this.vars.repeatRefresh && et !== it)) return this;
                            if (U !== this._dur) return this.render(h, _, v)
                        }
                        if (this._tTime = De, this._time = Me, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = xt = (At || this._ease)(Me / U), this._from && (this.ratio = xt = 1 - xt), !D && De && !_ && !it && (nr(this, "onStart"), this._tTime !== De)) return this;
                        for ($e = this._pt; $e;) $e.r(xt, $e.d), $e = $e._next;
                        kt && kt.render(h < 0 ? h : kt._dur * kt._ease(Me / this._dur), _, v) || this._startAt && (this._zTime = h), this._onUpdate && !_ && (W && ot(this, h, _, v), nr(this, "onUpdate")), this._repeat && et !== it && this.vars.onRepeat && !_ && this.parent && nr(this, "onRepeat"), (De === this._tDur || !De) && this._tTime === De && (W && !this._onUpdate && ot(this, h, !0, !0), (h || !U) && (De === this._tDur && this._ts > 0 || !De && this._ts < 0) && yt(this, 1), !_ && !(W && !D) && (De || D || Dt) && (nr(this, De === N ? "onComplete" : "onReverseComplete", !0), this._prom && !(De < N && this.timeScale() > 0) && this._prom()))
                    }
                    return this
                }, l.targets = function() {
                    return this._targets
                }, l.invalidate = function(h) {
                    return (!h || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(h), V.prototype.invalidate.call(this, h)
                }, l.resetTo = function(h, _, v, D, N) {
                    Wr || En.wake(), this._ts || this.play();
                    var U = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
                        W;
                    return this._initted || Ko(this, U), W = this._ease(U / this._dur), wa(this, h, _, v, D, W, U, N) ? this.resetTo(h, _, v, D, 1) : (T(this, 0), this.parent || qe(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
                }, l.kill = function(h, _) {
                    if (_ === void 0 && (_ = "all"), !h && (!_ || _ === "all")) return this._lazy = this._pt = 0, this.parent ? rr(this) : this.scrollTrigger && this.scrollTrigger.kill(!!u), this;
                    if (this.timeline) {
                        var v = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(h, _, Ji && Ji.vars.overwrite !== !0)._first || rr(this), this.parent && v !== this.timeline.totalDuration() && x(this, this._dur * this.timeline._tDur / v, 0, 1), this
                    }
                    var D = this._targets,
                        N = h ? ct(h) : D,
                        U = this._ptLookup,
                        W = this._pt,
                        De, Me, $e, et, pe, it, Dt;
                    if ((!_ || _ === "all") && Ne(D, N)) return _ === "all" && (this._pt = 0), rr(this);
                    for (De = this._op = this._op || [], _ !== "all" && ($(_) && (pe = {}, Et(_, function(xt) {
                            return pe[xt] = 1
                        }), _ = pe), _ = zc(D, _)), Dt = D.length; Dt--;)
                        if (~N.indexOf(D[Dt])) {
                            Me = U[Dt], _ === "all" ? (De[Dt] = _, et = Me, $e = {}) : ($e = De[Dt] = De[Dt] || {}, et = _);
                            for (pe in et) it = Me && Me[pe], it && ((!("kill" in it.d) || it.d.kill(pe) === !0) && Ve(this, it, "_pt"), delete Me[pe]), $e !== "all" && ($e[pe] = 1)
                        } return this._initted && !this._pt && W && rr(this), this
                }, o.to = function(h, _) {
                    return new o(h, _, arguments[2])
                }, o.from = function(h, _) {
                    return ue(1, arguments)
                }, o.delayedCall = function(h, _, v, D) {
                    return new o(_, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: h,
                        onComplete: _,
                        onReverseComplete: _,
                        onCompleteParams: v,
                        onReverseCompleteParams: v,
                        callbackScope: D
                    })
                }, o.fromTo = function(h, _, v) {
                    return ue(2, arguments)
                }, o.set = function(h, _) {
                    return _.duration = 0, _.repeatDelay || (_.repeat = 0), new o(h, _)
                }, o.killTweensOf = function(h, _, v) {
                    return ve.killTweensOf(h, _, v)
                }, o
            }(Yo);
            Y(Lr.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }), Et("staggerTo,staggerFrom,staggerFromTo", function(V) {
                Lr[V] = function() {
                    var o = new Zr,
                        l = _e.call(arguments, 0);
                    return l.splice(V === "staggerFromTo" ? 5 : 4, 0, 0), o[V].apply(o, l)
                }
            });
            var bo = function(o, l, f) {
                    return o[l] = f
                },
                il = function(o, l, f) {
                    return o[l](f)
                },
                jc = function(o, l, f, h) {
                    return o[l](h.fp, f)
                },
                du = function(o, l, f) {
                    return o.setAttribute(l, f)
                },
                Da = function(o, l) {
                    return w(o[l]) ? il : S(o[l]) && o.setAttribute ? du : bo
                },
                Zo = function(o, l) {
                    return l.set(l.t, l.p, Math.round((l.s + l.c * o) * 1e6) / 1e6, l)
                },
                pu = function(o, l) {
                    return l.set(l.t, l.p, !!(l.s + l.c * o), l)
                },
                Cn = function(o, l) {
                    var f = l._pt,
                        h = "";
                    if (!o && l.b) h = l.b;
                    else if (o === 1 && l.e) h = l.e;
                    else {
                        for (; f;) h = f.p + (f.m ? f.m(f.s + f.c * o) : Math.round((f.s + f.c * o) * 1e4) / 1e4) + h, f = f._next;
                        h += l.c
                    }
                    l.set(l.t, l.p, h, l)
                },
                xa = function(o, l) {
                    for (var f = l._pt; f;) f.r(o, f.d), f = f._next
                },
                sl = function(o, l, f, h) {
                    for (var _ = this._pt, v; _;) v = _._next, _.p === h && _.modifier(o, l, f), _ = v
                },
                Ea = function(o) {
                    for (var l = this._pt, f, h; l;) h = l._next, l.p === o && !l.op || l.op === o ? Ve(this, l, "_pt") : l.dep || (f = 1), l = h;
                    return !f
                },
                Uc = function(o, l, f, h) {
                    h.mSet(o, l, h.m.call(h.tween, f, h.mt), h)
                },
                ol = function(o) {
                    for (var l = o._pt, f, h, _, v; l;) {
                        for (f = l._next, h = _; h && h.pr > l.pr;) h = h._next;
                        (l._prev = h ? h._prev : v) ? l._prev._next = l: _ = l, (l._next = h) ? h._prev = l : v = l, l = f
                    }
                    o._pt = _
                },
                Ai = function() {
                    function V(l, f, h, _, v, D, N, U, W) {
                        this.t = f, this.s = _, this.c = v, this.p = h, this.r = D || Zo, this.d = N || this, this.set = U || bo, this.pr = W || 0, this._next = l, l && (l._prev = this)
                    }
                    var o = V.prototype;
                    return o.modifier = function(f, h, _) {
                        this.mSet = this.mSet || this.set, this.set = Uc, this.m = f, this.mt = _, this.tween = h
                    }, V
                }();
            Et(We + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(V) {
                return I[V] = 1
            }), _t.TweenMax = _t.TweenLite = Lr, _t.TimelineLite = _t.TimelineMax = Zr, ve = new Zr({
                sortChildren: !1,
                defaults: a,
                autoRemoveChildren: !0,
                id: "root",
                smoothChildTiming: !0
            }), s.stringFilter = fn;
            var zs = [],
                ea = {},
                Wc = [],
                Pe = 0,
                C = 0,
                Z = function(o) {
                    return (ea[o] || Wc).map(function(l) {
                        return l()
                    })
                },
                F = function() {
                    var o = Date.now(),
                        l = [];
                    o - Pe > 2 && (Z("matchMediaInit"), zs.forEach(function(f) {
                        var h = f.queries,
                            _ = f.conditions,
                            v, D, N, U;
                        for (D in h) v = tt.matchMedia(h[D]).matches, v && (N = 1), v !== _[D] && (_[D] = v, U = 1);
                        U && (f.revert(), N && l.push(f))
                    }), Z("matchMediaRevert"), l.forEach(function(f) {
                        return f.onMatch(f, function(h) {
                            return f.add(null, h)
                        })
                    }), Pe = o, Z("matchMedia"))
                },
                H = function() {
                    function V(l, f) {
                        this.selector = f && dt(f), this.data = [], this._r = [], this.isReverted = !1, this.id = C++, l && this.add(l)
                    }
                    var o = V.prototype;
                    return o.add = function(f, h, _) {
                        w(f) && (_ = h, h = f, f = w);
                        var v = this,
                            D = function() {
                                var U = p,
                                    W = v.selector,
                                    De;
                                return U && U !== v && U.data.push(v), _ && (v.selector = dt(_)), p = v, De = h.apply(v, arguments), w(De) && v._r.push(De), p = U, v.selector = W, v.isReverted = !1, De
                            };
                        return v.last = D, f === w ? D(v, function(N) {
                            return v.add(null, N)
                        }) : f ? v[f] = D : D
                    }, o.ignore = function(f) {
                        var h = p;
                        p = null, f(this), p = h
                    }, o.getTweens = function() {
                        var f = [];
                        return this.data.forEach(function(h) {
                            return h instanceof V ? f.push.apply(f, h.getTweens()) : h instanceof Lr && !(h.parent && h.parent.data === "nested") && f.push(h)
                        }), f
                    }, o.clear = function() {
                        this._r.length = this.data.length = 0
                    }, o.kill = function(f, h) {
                        var _ = this;
                        if (f ? function() {
                                for (var D = _.getTweens(), N = _.data.length, U; N--;) U = _.data[N], U.data === "isFlip" && (U.revert(), U.getChildren(!0, !0, !1).forEach(function(W) {
                                    return D.splice(D.indexOf(W), 1)
                                }));
                                for (D.map(function(W) {
                                        return {
                                            g: W._dur || W._delay || W._sat && !W._sat.vars.immediateRender ? W.globalTime(0) : -1 / 0,
                                            t: W
                                        }
                                    }).sort(function(W, De) {
                                        return De.g - W.g || -1 / 0
                                    }).forEach(function(W) {
                                        return W.t.revert(f)
                                    }), N = _.data.length; N--;) U = _.data[N], U instanceof Zr ? U.data !== "nested" && (U.scrollTrigger && U.scrollTrigger.revert(), U.kill()) : !(U instanceof Lr) && U.revert && U.revert(f);
                                _._r.forEach(function(W) {
                                    return W(f, _)
                                }), _.isReverted = !0
                            }() : this.data.forEach(function(D) {
                                return D.kill && D.kill()
                            }), this.clear(), h)
                            for (var v = zs.length; v--;) zs[v].id === this.id && zs.splice(v, 1)
                    }, o.revert = function(f) {
                        this.kill(f || {})
                    }, V
                }(),
                we = function() {
                    function V(l) {
                        this.contexts = [], this.scope = l, p && p.data.push(this)
                    }
                    var o = V.prototype;
                    return o.add = function(f, h, _) {
                        X(f) || (f = {
                            matches: f
                        });
                        var v = new H(0, _ || this.scope),
                            D = v.conditions = {},
                            N, U, W;
                        p && !v.selector && (v.selector = p.selector), this.contexts.push(v), h = v.add("onMatch", h), v.queries = f;
                        for (U in f) U === "all" ? W = 1 : (N = tt.matchMedia(f[U]), N && (zs.indexOf(v) < 0 && zs.push(v), (D[U] = N.matches) && (W = 1), N.addListener ? N.addListener(F) : N.addEventListener("change", F)));
                        return W && h(v, function(De) {
                            return v.add(null, De)
                        }), this
                    }, o.revert = function(f) {
                        this.kill(f || {})
                    }, o.kill = function(f) {
                        this.contexts.forEach(function(h) {
                            return h.kill(f, !0)
                        })
                    }, V
                }(),
                Ge = {
                    registerPlugin: function() {
                        for (var o = arguments.length, l = new Array(o), f = 0; f < o; f++) l[f] = arguments[f];
                        l.forEach(function(h) {
                            return qn(h)
                        })
                    },
                    timeline: function(o) {
                        return new Zr(o)
                    },
                    getTweensOf: function(o, l) {
                        return ve.getTweensOf(o, l)
                    },
                    getProperty: function(o, l, f, h) {
                        $(o) && (o = ct(o)[0]);
                        var _ = Ze(o || {}).get,
                            v = f ? ft : er;
                        return f === "native" && (f = ""), o && (l ? v((Ie[l] && Ie[l].get || _)(o, l, f, h)) : function(D, N, U) {
                            return v((Ie[D] && Ie[D].get || _)(o, D, N, U))
                        })
                    },
                    quickSetter: function(o, l, f) {
                        if (o = ct(o), o.length > 1) {
                            var h = o.map(function(W) {
                                    return mn.quickSetter(W, l, f)
                                }),
                                _ = h.length;
                            return function(W) {
                                for (var De = _; De--;) h[De](W)
                            }
                        }
                        o = o[0] || {};
                        var v = Ie[l],
                            D = Ze(o),
                            N = D.harness && (D.harness.aliases || {})[l] || l,
                            U = v ? function(W) {
                                var De = new v;
                                Vn._pt = 0, De.init(o, f ? W + f : W, Vn, 0, [o]), De.render(1, De), Vn._pt && xa(1, Vn)
                            } : D.set(o, N);
                        return v ? U : function(W) {
                            return U(o, N, f ? W + f : W, D, 1)
                        }
                    },
                    quickTo: function(o, l, f) {
                        var h, _ = mn.to(o, Y((h = {}, h[l] = "+=0.1", h.paused = !0, h.stagger = 0, h), f || {})),
                            v = function(N, U, W) {
                                return _.resetTo(l, N, U, W)
                            };
                        return v.tween = _, v
                    },
                    isTweening: function(o) {
                        return ve.getTweensOf(o, !0).length > 0
                    },
                    defaults: function(o) {
                        return o && o.ease && (o.ease = Vs(o.ease, a.ease)), ke(a, o || {})
                    },
                    config: function(o) {
                        return ke(s, o || {})
                    },
                    registerEffect: function(o) {
                        var l = o.name,
                            f = o.effect,
                            h = o.plugins,
                            _ = o.defaults,
                            v = o.extendTimeline;
                        (h || "").split(",").forEach(function(D) {
                            return D && !Ie[D] && !_t[D] && ye(l + " effect requires " + D + " plugin.")
                        }), st[l] = function(D, N, U) {
                            return f(ct(D), Y(N || {}, _), U)
                        }, v && (Zr.prototype[l] = function(D, N, U) {
                            return this.add(st[l](D, X(N) ? N : (U = N) && {}, this), U)
                        })
                    },
                    registerEase: function(o, l) {
                        _n[o] = Vs(l)
                    },
                    parseEase: function(o, l) {
                        return arguments.length ? Vs(o, l) : _n
                    },
                    getById: function(o) {
                        return ve.getById(o)
                    },
                    exportRoot: function(o, l) {
                        o === void 0 && (o = {});
                        var f = new Zr(o),
                            h, _;
                        for (f.smoothChildTiming = J(o.smoothChildTiming), ve.remove(f), f._dp = 0, f._time = f._tTime = ve._time, h = ve._first; h;) _ = h._next, (l || !(!h._dur && h instanceof Lr && h.vars.onComplete === h._targets[0])) && R(f, h, h._start - h._delay), h = _;
                        return R(ve, f, 0), f
                    },
                    context: function(o, l) {
                        return o ? new H(o, l) : p
                    },
                    matchMedia: function(o) {
                        return new we(o)
                    },
                    matchMediaRefresh: function() {
                        return zs.forEach(function(o) {
                            var l = o.conditions,
                                f, h;
                            for (h in l) l[h] && (l[h] = !1, f = 1);
                            f && o.revert()
                        }) || F()
                    },
                    addEventListener: function(o, l) {
                        var f = ea[o] || (ea[o] = []);
                        ~f.indexOf(l) || f.push(l)
                    },
                    removeEventListener: function(o, l) {
                        var f = ea[o],
                            h = f && f.indexOf(l);
                        h >= 0 && f.splice(h, 1)
                    },
                    utils: {
                        wrap: cn,
                        wrapYoyo: Mr,
                        distribute: Lt,
                        random: Ft,
                        snap: It,
                        normalize: jt,
                        getUnit: se,
                        clamp: Ue,
                        splitColor: ar,
                        toArray: ct,
                        selector: dt,
                        mapRange: fr,
                        pipe: Jt,
                        unitize: Gt,
                        interpolate: hr,
                        shuffle: Bt
                    },
                    install: St,
                    effects: st,
                    ticker: En,
                    updateRoot: Zr.updateRoot,
                    plugins: Ie,
                    globalTimeline: ve,
                    core: {
                        PropTween: Ai,
                        globals: oe,
                        Tween: Lr,
                        Timeline: Zr,
                        Animation: Yo,
                        getCache: Ze,
                        _removeLinkedListItem: Ve,
                        reverting: function() {
                            return u
                        },
                        context: function(o) {
                            return o && p && (p.data.push(o), o._ctx = p), p
                        },
                        suppressOverwrites: function(o) {
                            return c = o
                        }
                    }
                };
            Et("to,from,fromTo,delayedCall,set,killTweensOf", function(V) {
                return Ge[V] = Lr[V]
            }), En.add(Zr.updateRoot), Vn = Ge.to({}, {
                duration: 0
            });
            var Be = function(o, l) {
                    for (var f = o._pt; f && f.p !== l && f.op !== l && f.fp !== l;) f = f._next;
                    return f
                },
                $t = function(o, l) {
                    var f = o._targets,
                        h, _, v;
                    for (h in l)
                        for (_ = f.length; _--;) v = o._ptLookup[_][h], v && (v = v.d) && (v._pt && (v = Be(v, h)), v && v.modifier && v.modifier(l[h], o, f[_], h))
                },
                on = function(o, l) {
                    return {
                        name: o,
                        headless: 1,
                        rawVars: 1,
                        init: function(h, _, v) {
                            v._onInit = function(D) {
                                var N, U;
                                if ($(_) && (N = {}, Et(_, function(W) {
                                        return N[W] = 1
                                    }), _ = N), l) {
                                    N = {};
                                    for (U in _) N[U] = l(_[U]);
                                    _ = N
                                }
                                $t(D, _)
                            }
                        }
                    }
                },
                mn = Ge.registerPlugin({
                    name: "attr",
                    init: function(o, l, f, h, _) {
                        var v, D, N;
                        this.tween = f;
                        for (v in l) N = o.getAttribute(v) || "", D = this.add(o, "setAttribute", (N || 0) + "", l[v], h, _, 0, 0, v), D.op = v, D.b = N, this._props.push(v)
                    },
                    render: function(o, l) {
                        for (var f = l._pt; f;) u ? f.set(f.t, f.p, f.b, f) : f.r(o, f.d), f = f._next
                    }
                }, {
                    name: "endArray",
                    headless: 1,
                    init: function(o, l) {
                        for (var f = l.length; f--;) this.add(o, f, o[f] || 0, l[f], 0, 0, 0, 0, 0, 1)
                    }
                }, on("roundProps", Tt), on("modifiers"), on("snap", It)) || Ge;
            Lr.version = Zr.version = mn.version = "3.13.0", Pt = 1, xe() && Es();
            var Tn = _n.Power0,
                tn = _n.Power1,
                gt = _n.Power2,
                sn = _n.Power3,
                Sr = _n.Power4,
                ir = _n.Linear,
                qr = _n.Quad,
                wr = _n.Cubic,
                li = _n.Quart,
                Dn = _n.Quint,
                Zi = _n.Strong,
                dr = _n.Elastic,
                dn = _n.Back,
                xi = _n.SteppedEase,
                Ri = _n.Bounce,
                Zt = _n.Sine,
                ei = _n.Expo,
                hn = _n.Circ,
                hs, sr, $r, ui, Fn, Fr, Tr, Ae = function() {
                    return typeof window < "u"
                },
                Zn = {},
                Hi = 180 / Math.PI,
                Vi = Math.PI / 180,
                ci = Math.atan2,
                ds = 1e8,
                ti = /([A-Z])/g,
                Hr = /(left|right|width|margin|padding|x)/i,
                Ei = /[\s,\(]\S/,
                lr = {
                    autoAlpha: "opacity,visibility",
                    scale: "scaleX,scaleY",
                    alpha: "opacity"
                },
                ps = function(o, l) {
                    return l.set(l.t, l.p, Math.round((l.s + l.c * o) * 1e4) / 1e4 + l.u, l)
                },
                Ci = function(o, l) {
                    return l.set(l.t, l.p, o === 1 ? l.e : Math.round((l.s + l.c * o) * 1e4) / 1e4 + l.u, l)
                },
                Oi = function(o, l) {
                    return l.set(l.t, l.p, o ? Math.round((l.s + l.c * o) * 1e4) / 1e4 + l.u : l.b, l)
                },
                In = function(o, l) {
                    var f = l.s + l.c * o;
                    l.set(l.t, l.p, ~~(f + (f < 0 ? -.5 : .5)) + l.u, l)
                },
                Pr = function(o, l) {
                    return l.set(l.t, l.p, o ? l.e : l.b, l)
                },
                Si = function(o, l) {
                    return l.set(l.t, l.p, o !== 1 ? l.b : l.e, l)
                },
                zi = function(o, l, f) {
                    return o.style[l] = f
                },
                Ye = function(o, l, f) {
                    return o.style.setProperty(l, f)
                },
                ji = function(o, l, f) {
                    return o._gsap[l] = f
                },
                Ps = function(o, l, f) {
                    return o._gsap.scaleX = o._gsap.scaleY = f
                },
                js = function(o, l, f, h, _) {
                    var v = o._gsap;
                    v.scaleX = v.scaleY = f, v.renderTransform(_, v)
                },
                kr = function(o, l, f, h, _) {
                    var v = o._gsap;
                    v[l] = f, v.renderTransform(_, v)
                },
                jn = "transform",
                Ir = jn + "Origin",
                eo = function V(o, l) {
                    var f = this,
                        h = this.target,
                        _ = h.style,
                        v = h._gsap;
                    if (o in Zn && _) {
                        if (this.tfm = this.tfm || {}, o !== "transform") o = lr[o] || o, ~o.indexOf(",") ? o.split(",").forEach(function(D) {
                            return f.tfm[D] = Yr(h, D)
                        }) : this.tfm[o] = v.x ? v[o] : Yr(h, o), o === Ir && (this.tfm.zOrigin = v.zOrigin);
                        else return lr.transform.split(",").forEach(function(D) {
                            return V.call(f, D, l)
                        });
                        if (this.props.indexOf(jn) >= 0) return;
                        v.svg && (this.svgo = h.getAttribute("data-svg-origin"), this.props.push(Ir, l, "")), o = jn
                    }(_ || l) && this.props.push(o, l, _[o])
                },
                Gr = function(o) {
                    o.translate && (o.removeProperty("translate"), o.removeProperty("scale"), o.removeProperty("rotate"))
                },
                Us = function() {
                    var o = this.props,
                        l = this.target,
                        f = l.style,
                        h = l._gsap,
                        _, v;
                    for (_ = 0; _ < o.length; _ += 3) o[_ + 1] ? o[_ + 1] === 2 ? l[o[_]](o[_ + 2]) : l[o[_]] = o[_ + 2] : o[_ + 2] ? f[o[_]] = o[_ + 2] : f.removeProperty(o[_].substr(0, 2) === "--" ? o[_] : o[_].replace(ti, "-$1").toLowerCase());
                    if (this.tfm) {
                        for (v in this.tfm) h[v] = this.tfm[v];
                        h.svg && (h.renderTransform(), l.setAttribute("data-svg-origin", this.svgo || "")), _ = Tr(), (!_ || !_.isStart) && !f[jn] && (Gr(f), h.zOrigin && f[Ir] && (f[Ir] += " " + h.zOrigin + "px", h.zOrigin = 0, h.renderTransform()), h.uncache = 1)
                    }
                },
                Ar = function(o, l) {
                    var f = {
                        target: o,
                        props: [],
                        revert: Us,
                        save: eo
                    };
                    return o._gsap || mn.core.getCache(o), l && o.style && o.nodeType && l.split(",").forEach(function(h) {
                        return f.save(h)
                    }), f
                },
                es, Mi = function(o, l) {
                    var f = sr.createElementNS ? sr.createElementNS((l || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), o) : sr.createElement(o);
                    return f && f.style ? f : sr.createElement(o)
                },
                Vr = function V(o, l, f) {
                    var h = getComputedStyle(o);
                    return h[l] || h.getPropertyValue(l.replace(ti, "-$1").toLowerCase()) || h.getPropertyValue(l) || !f && V(o, ur(l) || l, 1) || ""
                },
                wo = "O,Moz,ms,Ms,Webkit".split(","),
                ur = function(o, l, f) {
                    var h = l || Fn,
                        _ = h.style,
                        v = 5;
                    if (o in _ && !f) return o;
                    for (o = o.charAt(0).toUpperCase() + o.substr(1); v-- && !(wo[v] + o in _););
                    return v < 0 ? null : (v === 3 ? "ms" : v >= 0 ? wo[v] : "") + o
                },
                Do = function() {
                    Ae() && window.document && (hs = window, sr = hs.document, $r = sr.documentElement, Fn = Mi("div") || {
                        style: {}
                    }, Mi("div"), jn = ur(jn), Ir = jn + "Origin", Fn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", es = !!ur("perspective"), Tr = mn.core.reverting, ui = 1)
                },
                gs = function(o) {
                    var l = o.ownerSVGElement,
                        f = Mi("svg", l && l.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                        h = o.cloneNode(!0),
                        _;
                    h.style.display = "block", f.appendChild(h), $r.appendChild(f);
                    try {
                        _ = h.getBBox()
                    } catch {}
                    return f.removeChild(h), $r.removeChild(f), _
                },
                to = function(o, l) {
                    for (var f = l.length; f--;)
                        if (o.hasAttribute(l[f])) return o.getAttribute(l[f])
                },
                no = function(o) {
                    var l, f;
                    try {
                        l = o.getBBox()
                    } catch {
                        l = gs(o), f = 1
                    }
                    return l && (l.width || l.height) || f || (l = gs(o)), l && !l.width && !l.x && !l.y ? {
                        x: +to(o, ["x", "cx", "x1"]) || 0,
                        y: +to(o, ["y", "cy", "y1"]) || 0,
                        width: 0,
                        height: 0
                    } : l
                },
                ks = function(o) {
                    return !!(o.getCTM && (!o.parentNode || o.ownerSVGElement) && no(o))
                },
                Ui = function(o, l) {
                    if (l) {
                        var f = o.style,
                            h;
                        l in Zn && l !== Ir && (l = jn), f.removeProperty ? (h = l.substr(0, 2), (h === "ms" || l.substr(0, 6) === "webkit") && (l = "-" + l), f.removeProperty(h === "--" ? l : l.replace(ti, "-$1").toLowerCase())) : f.removeAttribute(l)
                    }
                },
                yn = function(o, l, f, h, _, v) {
                    var D = new Ai(o._pt, l, f, 0, 1, v ? Si : Pr);
                    return o._pt = D, D.b = h, D.e = _, o._props.push(f), D
                },
                Ws = {
                    deg: 1,
                    rad: 1,
                    turn: 1
                },
                as = {
                    grid: 1,
                    flex: 1
                },
                ni = function V(o, l, f, h) {
                    var _ = parseFloat(f) || 0,
                        v = (f + "").trim().substr((_ + "").length) || "px",
                        D = Fn.style,
                        N = Hr.test(l),
                        U = o.tagName.toLowerCase() === "svg",
                        W = (U ? "client" : "offset") + (N ? "Width" : "Height"),
                        De = 100,
                        Me = h === "px",
                        $e = h === "%",
                        et, pe, it, Dt;
                    if (h === v || !_ || Ws[h] || Ws[v]) return _;
                    if (v !== "px" && !Me && (_ = V(o, l, f, "px")), Dt = o.getCTM && ks(o), ($e || v === "%") && (Zn[l] || ~l.indexOf("adius"))) return et = Dt ? o.getBBox()[N ? "width" : "height"] : o[W], Ot($e ? _ / et * De : _ / 100 * et);
                    if (D[N ? "width" : "height"] = De + (Me ? v : h), pe = h !== "rem" && ~l.indexOf("adius") || h === "em" && o.appendChild && !U ? o : o.parentNode, Dt && (pe = (o.ownerSVGElement || {}).parentNode), (!pe || pe === sr || !pe.appendChild) && (pe = sr.body), it = pe._gsap, it && $e && it.width && N && it.time === En.time && !it.uncache) return Ot(_ / it.width * De);
                    if ($e && (l === "height" || l === "width")) {
                        var xt = o.style[l];
                        o.style[l] = De + h, et = o[W], xt ? o.style[l] = xt : Ui(o, l)
                    } else($e || v === "%") && !as[Vr(pe, "display")] && (D.position = Vr(o, "position")), pe === o && (D.position = "static"), pe.appendChild(Fn), et = Fn[W], pe.removeChild(Fn), D.position = "absolute";
                    return N && $e && (it = Ze(pe), it.time = En.time, it.width = pe[W]), Ot(Me ? et * _ / De : et && _ ? De / et * _ : 0)
                },
                Yr = function(o, l, f, h) {
                    var _;
                    return ui || Do(), l in lr && l !== "transform" && (l = lr[l], ~l.indexOf(",") && (l = l.split(",")[0])), Zn[l] && l !== "transform" ? (_ = Rr(o, h), _ = l !== "transformOrigin" ? _[l] : _.svg ? _.origin : Sn(Vr(o, Ir)) + " " + _.zOrigin + "px") : (_ = o.style[l], (!_ || _ === "auto" || h || ~(_ + "").indexOf("calc(")) && (_ = pn[l] && pn[l](o, l, f) || Vr(o, l) || wt(o, l) || (l === "opacity" ? 1 : 0))), f && !~(_ + "").trim().indexOf(" ") ? ni(o, l, _, f) + f : _
                },
                ro = function(o, l, f, h) {
                    if (!f || f === "none") {
                        var _ = ur(l, o, 1),
                            v = _ && Vr(o, _, 1);
                        v && v !== f ? (l = _, f = v) : l === "borderColor" && (f = Vr(o, "borderTopColor"))
                    }
                    var D = new Ai(this._pt, o.style, l, 0, 1, Cn),
                        N = 0,
                        U = 0,
                        W, De, Me, $e, et, pe, it, Dt, xt, kt, At, vt;
                    if (D.b = f, D.e = h, f += "", h += "", h.substring(0, 6) === "var(--" && (h = Vr(o, h.substring(4, h.indexOf(")")))), h === "auto" && (pe = o.style[l], o.style[l] = h, h = Vr(o, l) || h, pe ? o.style[l] = pe : Ui(o, l)), W = [f, h], fn(W), f = W[0], h = W[1], Me = f.match(K) || [], vt = h.match(K) || [], vt.length) {
                        for (; De = K.exec(h);) it = De[0], xt = h.substring(N, De.index), et ? et = (et + 1) % 5 : (xt.substr(-5) === "rgba(" || xt.substr(-5) === "hsla(") && (et = 1), it !== (pe = Me[U++] || "") && ($e = parseFloat(pe) || 0, At = pe.substr(($e + "").length), it.charAt(1) === "=" && (it = an($e, it) + At), Dt = parseFloat(it), kt = it.substr((Dt + "").length), N = K.lastIndex - kt.length, kt || (kt = kt || s.units[l] || At, N === h.length && (h += kt, D.e += kt)), At !== kt && ($e = ni(o, l, pe, kt) || 0), D._pt = {
                            _next: D._pt,
                            p: xt || U === 1 ? xt : ",",
                            s: $e,
                            c: Dt - $e,
                            m: et && et < 4 || l === "zIndex" ? Math.round : 0
                        });
                        D.c = N < h.length ? h.substring(N, h.length) : ""
                    } else D.r = l === "display" && h === "none" ? Si : Pr;
                    return G.test(h) && (D.e = 0), this._pt = D, D
                },
                io = {
                    top: "0%",
                    bottom: "100%",
                    left: "0%",
                    right: "100%",
                    center: "50%"
                },
                As = function(o) {
                    var l = o.split(" "),
                        f = l[0],
                        h = l[1] || "50%";
                    return (f === "top" || f === "bottom" || h === "left" || h === "right") && (o = f, f = h, h = o), l[0] = io[f] || f, l[1] = io[h] || h, l.join(" ")
                },
                ta = function(o, l) {
                    if (l.tween && l.tween._time === l.tween._dur) {
                        var f = l.t,
                            h = f.style,
                            _ = l.u,
                            v = f._gsap,
                            D, N, U;
                        if (_ === "all" || _ === !0) h.cssText = "", N = 1;
                        else
                            for (_ = _.split(","), U = _.length; --U > -1;) D = _[U], Zn[D] && (N = 1, D = D === "transformOrigin" ? Ir : jn), Ui(f, D);
                        N && (Ui(f, jn), v && (v.svg && f.removeAttribute("transform"), h.scale = h.rotate = h.translate = "none", Rr(f, 1), v.uncache = 1, Gr(h)))
                    }
                },
                pn = {
                    clearProps: function(o, l, f, h, _) {
                        if (_.data !== "isFromStart") {
                            var v = o._pt = new Ai(o._pt, l, f, 0, 0, ta);
                            return v.u = h, v.pr = -10, v.tween = _, o._props.push(f), 1
                        }
                    }
                },
                nn = [1, 0, 0, 1, 0, 0],
                Hn = {},
                Nt = function(o) {
                    return o === "matrix(1, 0, 0, 1, 0, 0)" || o === "none" || !o
                },
                vn = function(o) {
                    var l = Vr(o, jn);
                    return Nt(l) ? nn : l.substr(7).match(re).map(Ot)
                },
                en = function(o, l) {
                    var f = o._gsap || Ze(o),
                        h = o.style,
                        _ = vn(o),
                        v, D, N, U;
                    return f.svg && o.getAttribute("transform") ? (N = o.transform.baseVal.consolidate().matrix, _ = [N.a, N.b, N.c, N.d, N.e, N.f], _.join(",") === "1,0,0,1,0,0" ? nn : _) : (_ === nn && !o.offsetParent && o !== $r && !f.svg && (N = h.display, h.display = "block", v = o.parentNode, (!v || !o.offsetParent && !o.getBoundingClientRect().width) && (U = 1, D = o.nextElementSibling, $r.appendChild(o)), _ = vn(o), N ? h.display = N : Ui(o, "display"), U && (D ? v.insertBefore(o, D) : v ? v.appendChild(o) : $r.removeChild(o))), l && _.length > 6 ? [_[0], _[1], _[4], _[5], _[12], _[13]] : _)
                },
                gn = function(o, l, f, h, _, v) {
                    var D = o._gsap,
                        N = _ || en(o, !0),
                        U = D.xOrigin || 0,
                        W = D.yOrigin || 0,
                        De = D.xOffset || 0,
                        Me = D.yOffset || 0,
                        $e = N[0],
                        et = N[1],
                        pe = N[2],
                        it = N[3],
                        Dt = N[4],
                        xt = N[5],
                        kt = l.split(" "),
                        At = parseFloat(kt[0]) || 0,
                        vt = parseFloat(kt[1]) || 0,
                        Vt, zt, Ut, Rt;
                    f ? N !== nn && (zt = $e * it - et * pe) && (Ut = At * (it / zt) + vt * (-pe / zt) + (pe * xt - it * Dt) / zt, Rt = At * (-et / zt) + vt * ($e / zt) - ($e * xt - et * Dt) / zt, At = Ut, vt = Rt) : (Vt = no(o), At = Vt.x + (~kt[0].indexOf("%") ? At / 100 * Vt.width : At), vt = Vt.y + (~(kt[1] || kt[0]).indexOf("%") ? vt / 100 * Vt.height : vt)), h || h !== !1 && D.smooth ? (Dt = At - U, xt = vt - W, D.xOffset = De + (Dt * $e + xt * pe) - Dt, D.yOffset = Me + (Dt * et + xt * it) - xt) : D.xOffset = D.yOffset = 0, D.xOrigin = At, D.yOrigin = vt, D.smooth = !!h, D.origin = l, D.originIsAbsolute = !!f, o.style[Ir] = "0px 0px", v && (yn(v, D, "xOrigin", U, At), yn(v, D, "yOrigin", W, vt), yn(v, D, "xOffset", De, D.xOffset), yn(v, D, "yOffset", Me, D.yOffset)), o.setAttribute("data-svg-origin", At + " " + vt)
                },
                Rr = function(o, l) {
                    var f = o._gsap || new tl(o);
                    if ("x" in f && !l && !f.uncache) return f;
                    var h = o.style,
                        _ = f.scaleX < 0,
                        v = "px",
                        D = "deg",
                        N = getComputedStyle(o),
                        U = Vr(o, Ir) || "0",
                        W, De, Me, $e, et, pe, it, Dt, xt, kt, At, vt, Vt, zt, Ut, Rt, Yn, Or, pr, gr, Ti, vi, ii, bi, Rs, gu, al, ll, na, Jh, oo, ra;
                    return W = De = Me = pe = it = Dt = xt = kt = At = 0, $e = et = 1, f.svg = !!(o.getCTM && ks(o)), N.translate && ((N.translate !== "none" || N.scale !== "none" || N.rotate !== "none") && (h[jn] = (N.translate !== "none" ? "translate3d(" + (N.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (N.rotate !== "none" ? "rotate(" + N.rotate + ") " : "") + (N.scale !== "none" ? "scale(" + N.scale.split(" ").join(",") + ") " : "") + (N[jn] !== "none" ? N[jn] : "")), h.scale = h.rotate = h.translate = "none"), zt = en(o, f.svg), f.svg && (f.uncache ? (Rs = o.getBBox(), U = f.xOrigin - Rs.x + "px " + (f.yOrigin - Rs.y) + "px", bi = "") : bi = !l && o.getAttribute("data-svg-origin"), gn(o, bi || U, !!bi || f.originIsAbsolute, f.smooth !== !1, zt)), vt = f.xOrigin || 0, Vt = f.yOrigin || 0, zt !== nn && (Or = zt[0], pr = zt[1], gr = zt[2], Ti = zt[3], W = vi = zt[4], De = ii = zt[5], zt.length === 6 ? ($e = Math.sqrt(Or * Or + pr * pr), et = Math.sqrt(Ti * Ti + gr * gr), pe = Or || pr ? ci(pr, Or) * Hi : 0, xt = gr || Ti ? ci(gr, Ti) * Hi + pe : 0, xt && (et *= Math.abs(Math.cos(xt * Vi))), f.svg && (W -= vt - (vt * Or + Vt * gr), De -= Vt - (vt * pr + Vt * Ti))) : (ra = zt[6], Jh = zt[7], al = zt[8], ll = zt[9], na = zt[10], oo = zt[11], W = zt[12], De = zt[13], Me = zt[14], Ut = ci(ra, na), it = Ut * Hi, Ut && (Rt = Math.cos(-Ut), Yn = Math.sin(-Ut), bi = vi * Rt + al * Yn, Rs = ii * Rt + ll * Yn, gu = ra * Rt + na * Yn, al = vi * -Yn + al * Rt, ll = ii * -Yn + ll * Rt, na = ra * -Yn + na * Rt, oo = Jh * -Yn + oo * Rt, vi = bi, ii = Rs, ra = gu), Ut = ci(-gr, na), Dt = Ut * Hi, Ut && (Rt = Math.cos(-Ut), Yn = Math.sin(-Ut), bi = Or * Rt - al * Yn, Rs = pr * Rt - ll * Yn, gu = gr * Rt - na * Yn, oo = Ti * Yn + oo * Rt, Or = bi, pr = Rs, gr = gu), Ut = ci(pr, Or), pe = Ut * Hi, Ut && (Rt = Math.cos(Ut), Yn = Math.sin(Ut), bi = Or * Rt + pr * Yn, Rs = vi * Rt + ii * Yn, pr = pr * Rt - Or * Yn, ii = ii * Rt - vi * Yn, Or = bi, vi = Rs), it && Math.abs(it) + Math.abs(pe) > 359.9 && (it = pe = 0, Dt = 180 - Dt), $e = Ot(Math.sqrt(Or * Or + pr * pr + gr * gr)), et = Ot(Math.sqrt(ii * ii + ra * ra)), Ut = ci(vi, ii), xt = Math.abs(Ut) > 2e-4 ? Ut * Hi : 0, At = oo ? 1 / (oo < 0 ? -oo : oo) : 0), f.svg && (bi = o.getAttribute("transform"), f.forceCSS = o.setAttribute("transform", "") || !Nt(Vr(o, jn)), bi && o.setAttribute("transform", bi))), Math.abs(xt) > 90 && Math.abs(xt) < 270 && (_ ? ($e *= -1, xt += pe <= 0 ? 180 : -180, pe += pe <= 0 ? 180 : -180) : (et *= -1, xt += xt <= 0 ? 180 : -180)), l = l || f.uncache, f.x = W - ((f.xPercent = W && (!l && f.xPercent || (Math.round(o.offsetWidth / 2) === Math.round(-W) ? -50 : 0))) ? o.offsetWidth * f.xPercent / 100 : 0) + v, f.y = De - ((f.yPercent = De && (!l && f.yPercent || (Math.round(o.offsetHeight / 2) === Math.round(-De) ? -50 : 0))) ? o.offsetHeight * f.yPercent / 100 : 0) + v, f.z = Me + v, f.scaleX = Ot($e), f.scaleY = Ot(et), f.rotation = Ot(pe) + D, f.rotationX = Ot(it) + D, f.rotationY = Ot(Dt) + D, f.skewX = xt + D, f.skewY = kt + D, f.transformPerspective = At + v, (f.zOrigin = parseFloat(U.split(" ")[2]) || !l && f.zOrigin || 0) && (h[Ir] = Sn(U)), f.xOffset = f.yOffset = 0, f.force3D = s.force3D, f.renderTransform = f.svg ? xr : es ? ts : yi, f.uncache = 0, f
                },
                Sn = function(o) {
                    return (o = o.split(" "))[0] + " " + o[1]
                },
                Dr = function(o, l, f) {
                    var h = se(l);
                    return Ot(parseFloat(l) + parseFloat(ni(o, "x", f + "px", h))) + h
                },
                yi = function(o, l) {
                    l.z = "0px", l.rotationY = l.rotationX = "0deg", l.force3D = 0, ts(o, l)
                },
                Kn = "0deg",
                Qn = "0px",
                Nn = ") ",
                ts = function(o, l) {
                    var f = l || this,
                        h = f.xPercent,
                        _ = f.yPercent,
                        v = f.x,
                        D = f.y,
                        N = f.z,
                        U = f.rotation,
                        W = f.rotationY,
                        De = f.rotationX,
                        Me = f.skewX,
                        $e = f.skewY,
                        et = f.scaleX,
                        pe = f.scaleY,
                        it = f.transformPerspective,
                        Dt = f.force3D,
                        xt = f.target,
                        kt = f.zOrigin,
                        At = "",
                        vt = Dt === "auto" && o && o !== 1 || Dt === !0;
                    if (kt && (De !== Kn || W !== Kn)) {
                        var Vt = parseFloat(W) * Vi,
                            zt = Math.sin(Vt),
                            Ut = Math.cos(Vt),
                            Rt;
                        Vt = parseFloat(De) * Vi, Rt = Math.cos(Vt), v = Dr(xt, v, zt * Rt * -kt), D = Dr(xt, D, -Math.sin(Vt) * -kt), N = Dr(xt, N, Ut * Rt * -kt + kt)
                    }
                    it !== Qn && (At += "perspective(" + it + Nn), (h || _) && (At += "translate(" + h + "%, " + _ + "%) "), (vt || v !== Qn || D !== Qn || N !== Qn) && (At += N !== Qn || vt ? "translate3d(" + v + ", " + D + ", " + N + ") " : "translate(" + v + ", " + D + Nn), U !== Kn && (At += "rotate(" + U + Nn), W !== Kn && (At += "rotateY(" + W + Nn), De !== Kn && (At += "rotateX(" + De + Nn), (Me !== Kn || $e !== Kn) && (At += "skew(" + Me + ", " + $e + Nn), (et !== 1 || pe !== 1) && (At += "scale(" + et + ", " + pe + Nn), xt.style[jn] = At || "translate(0, 0)"
                },
                xr = function(o, l) {
                    var f = l || this,
                        h = f.xPercent,
                        _ = f.yPercent,
                        v = f.x,
                        D = f.y,
                        N = f.rotation,
                        U = f.skewX,
                        W = f.skewY,
                        De = f.scaleX,
                        Me = f.scaleY,
                        $e = f.target,
                        et = f.xOrigin,
                        pe = f.yOrigin,
                        it = f.xOffset,
                        Dt = f.yOffset,
                        xt = f.forceCSS,
                        kt = parseFloat(v),
                        At = parseFloat(D),
                        vt, Vt, zt, Ut, Rt;
                    N = parseFloat(N), U = parseFloat(U), W = parseFloat(W), W && (W = parseFloat(W), U += W, N += W), N || U ? (N *= Vi, U *= Vi, vt = Math.cos(N) * De, Vt = Math.sin(N) * De, zt = Math.sin(N - U) * -Me, Ut = Math.cos(N - U) * Me, U && (W *= Vi, Rt = Math.tan(U - W), Rt = Math.sqrt(1 + Rt * Rt), zt *= Rt, Ut *= Rt, W && (Rt = Math.tan(W), Rt = Math.sqrt(1 + Rt * Rt), vt *= Rt, Vt *= Rt)), vt = Ot(vt), Vt = Ot(Vt), zt = Ot(zt), Ut = Ot(Ut)) : (vt = De, Ut = Me, Vt = zt = 0), (kt && !~(v + "").indexOf("px") || At && !~(D + "").indexOf("px")) && (kt = ni($e, "x", v, "px"), At = ni($e, "y", D, "px")), (et || pe || it || Dt) && (kt = Ot(kt + et - (et * vt + pe * zt) + it), At = Ot(At + pe - (et * Vt + pe * Ut) + Dt)), (h || _) && (Rt = $e.getBBox(), kt = Ot(kt + h / 100 * Rt.width), At = Ot(At + _ / 100 * Rt.height)), Rt = "matrix(" + vt + "," + Vt + "," + zt + "," + Ut + "," + kt + "," + At + ")", $e.setAttribute("transform", Rt), xt && ($e.style[jn] = Rt)
                },
                Wi = function(o, l, f, h, _) {
                    var v = 360,
                        D = $(_),
                        N = parseFloat(_) * (D && ~_.indexOf("rad") ? Hi : 1),
                        U = N - h,
                        W = h + U + "deg",
                        De, Me;
                    return D && (De = _.split("_")[1], De === "short" && (U %= v, U !== U % (v / 2) && (U += U < 0 ? v : -360)), De === "cw" && U < 0 ? U = (U + v * ds) % v - ~~(U / v) * v : De === "ccw" && U > 0 && (U = (U - v * ds) % v - ~~(U / v) * v)), o._pt = Me = new Ai(o._pt, l, f, h, U, Ci), Me.e = W, Me.u = "deg", o._props.push(f), Me
                },
                ls = function(o, l) {
                    for (var f in l) o[f] = l[f];
                    return o
                },
                fi = function(o, l, f) {
                    var h = ls({}, f._gsap),
                        _ = "perspective,force3D,transformOrigin,svgOrigin",
                        v = f.style,
                        D, N, U, W, De, Me, $e, et;
                    h.svg ? (U = f.getAttribute("transform"), f.setAttribute("transform", ""), v[jn] = l, D = Rr(f, 1), Ui(f, jn), f.setAttribute("transform", U)) : (U = getComputedStyle(f)[jn], v[jn] = l, D = Rr(f, 1), v[jn] = U);
                    for (N in Zn) U = h[N], W = D[N], U !== W && _.indexOf(N) < 0 && ($e = se(U), et = se(W), De = $e !== et ? ni(f, N, U, et) : parseFloat(U), Me = parseFloat(W), o._pt = new Ai(o._pt, D, N, De, Me - De, ps), o._pt.u = et || 0, o._props.push(N));
                    ls(D, h)
                };
            Et("padding,margin,Width,Radius", function(V, o) {
                var l = "Top",
                    f = "Right",
                    h = "Bottom",
                    _ = "Left",
                    v = (o < 3 ? [l, f, h, _] : [l + _, l + f, h + f, h + _]).map(function(D) {
                        return o < 2 ? V + D : "border" + D + V
                    });
                pn[o > 1 ? "border" + V : V] = function(D, N, U, W, De) {
                    var Me, $e;
                    if (arguments.length < 4) return Me = v.map(function(et) {
                        return Yr(D, et, U)
                    }), $e = Me.join(" "), $e.split(Me[0]).length === 5 ? Me[0] : $e;
                    Me = (W + "").split(" "), $e = {}, v.forEach(function(et, pe) {
                        return $e[et] = Me[pe] = Me[pe] || Me[(pe - 1) / 2 | 0]
                    }), D.init(N, $e, De)
                }
            });
            var Xr = {
                name: "css",
                register: Do,
                targetTest: function(o) {
                    return o.style && o.nodeType
                },
                init: function(o, l, f, h, _) {
                    var v = this._props,
                        D = o.style,
                        N = f.vars.startAt,
                        U, W, De, Me, $e, et, pe, it, Dt, xt, kt, At, vt, Vt, zt, Ut;
                    ui || Do(), this.styles = this.styles || Ar(o), Ut = this.styles.props, this.tween = f;
                    for (pe in l)
                        if (pe !== "autoRound" && (W = l[pe], !(Ie[pe] && Xo(pe, l, f, h, o, _)))) {
                            if ($e = typeof W, et = pn[pe], $e === "function" && (W = W.call(f, h, o, _), $e = typeof W), $e === "string" && ~W.indexOf("random(") && (W = tr(W)), et) et(this, o, pe, W, f) && (zt = 1);
                            else if (pe.substr(0, 2) === "--") U = (getComputedStyle(o).getPropertyValue(pe) + "").trim(), W += "", Gn.lastIndex = 0, Gn.test(U) || (it = se(U), Dt = se(W)), Dt ? it !== Dt && (U = ni(o, pe, U, Dt) + Dt) : it && (W += it), this.add(D, "setProperty", U, W, h, _, 0, 0, pe), v.push(pe), Ut.push(pe, 0, D[pe]);
                            else if ($e !== "undefined") {
                                if (N && pe in N ? (U = typeof N[pe] == "function" ? N[pe].call(f, h, o, _) : N[pe], $(U) && ~U.indexOf("random(") && (U = tr(U)), se(U + "") || U === "auto" || (U += s.units[pe] || se(Yr(o, pe)) || ""), (U + "").charAt(1) === "=" && (U = Yr(o, pe))) : U = Yr(o, pe), Me = parseFloat(U), xt = $e === "string" && W.charAt(1) === "=" && W.substr(0, 2), xt && (W = W.substr(2)), De = parseFloat(W), pe in lr && (pe === "autoAlpha" && (Me === 1 && Yr(o, "visibility") === "hidden" && De && (Me = 0), Ut.push("visibility", 0, D.visibility), yn(this, D, "visibility", Me ? "inherit" : "hidden", De ? "inherit" : "hidden", !De)), pe !== "scale" && pe !== "transform" && (pe = lr[pe], ~pe.indexOf(",") && (pe = pe.split(",")[0]))), kt = pe in Zn, kt) {
                                    if (this.styles.save(pe), $e === "string" && W.substring(0, 6) === "var(--" && (W = Vr(o, W.substring(4, W.indexOf(")"))), De = parseFloat(W)), At || (vt = o._gsap, vt.renderTransform && !l.parseTransform || Rr(o, l.parseTransform), Vt = l.smoothOrigin !== !1 && vt.smooth, At = this._pt = new Ai(this._pt, D, jn, 0, 1, vt.renderTransform, vt, 0, -1), At.dep = 1), pe === "scale") this._pt = new Ai(this._pt, vt, "scaleY", vt.scaleY, (xt ? an(vt.scaleY, xt + De) : De) - vt.scaleY || 0, ps), this._pt.u = 0, v.push("scaleY", pe), pe += "X";
                                    else if (pe === "transformOrigin") {
                                        Ut.push(Ir, 0, D[Ir]), W = As(W), vt.svg ? gn(o, W, 0, Vt, 0, this) : (Dt = parseFloat(W.split(" ")[2]) || 0, Dt !== vt.zOrigin && yn(this, vt, "zOrigin", vt.zOrigin, Dt), yn(this, D, pe, Sn(U), Sn(W)));
                                        continue
                                    } else if (pe === "svgOrigin") {
                                        gn(o, W, 1, Vt, 0, this);
                                        continue
                                    } else if (pe in Hn) {
                                        Wi(this, vt, pe, Me, xt ? an(Me, xt + W) : W);
                                        continue
                                    } else if (pe === "smoothOrigin") {
                                        yn(this, vt, "smooth", vt.smooth, W);
                                        continue
                                    } else if (pe === "force3D") {
                                        vt[pe] = W;
                                        continue
                                    } else if (pe === "transform") {
                                        fi(this, W, o);
                                        continue
                                    }
                                } else pe in D || (pe = ur(pe) || pe);
                                if (kt || (De || De === 0) && (Me || Me === 0) && !Ei.test(W) && pe in D) it = (U + "").substr((Me + "").length), De || (De = 0), Dt = se(W) || (pe in s.units ? s.units[pe] : it), it !== Dt && (Me = ni(o, pe, U, Dt)), this._pt = new Ai(this._pt, kt ? vt : D, pe, Me, (xt ? an(Me, xt + De) : De) - Me, !kt && (Dt === "px" || pe === "zIndex") && l.autoRound !== !1 ? In : ps), this._pt.u = Dt || 0, it !== Dt && Dt !== "%" && (this._pt.b = U, this._pt.r = Oi);
                                else if (pe in D) ro.call(this, o, pe, U, xt ? xt + W : W);
                                else if (pe in o) this.add(o, pe, U || o[pe], xt ? xt + W : W, h, _);
                                else if (pe !== "parseTransform") {
                                    de(pe, W);
                                    continue
                                }
                                kt || (pe in D ? Ut.push(pe, 0, D[pe]) : typeof o[pe] == "function" ? Ut.push(pe, 2, o[pe]()) : Ut.push(pe, 1, U || o[pe])), v.push(pe)
                            }
                        } zt && ol(this)
                },
                render: function(o, l) {
                    if (l.tween._time || !Tr())
                        for (var f = l._pt; f;) f.r(o, f.d), f = f._next;
                    else l.styles.revert()
                },
                get: Yr,
                aliases: lr,
                getSetter: function(o, l, f) {
                    var h = lr[l];
                    return h && h.indexOf(",") < 0 && (l = h), l in Zn && l !== Ir && (o._gsap.x || Yr(o, "x")) ? f && Fr === f ? l === "scale" ? Ps : ji : (Fr = f || {}) && (l === "scale" ? js : kr) : o.style && !S(o.style[l]) ? zi : ~l.indexOf("-") ? Ye : Da(o, l)
                },
                core: {
                    _removeProperty: Ui,
                    _getMatrix: en
                }
            };
            mn.utils.checkPrefix = ur, mn.core.getStyleSaver = Ar,
                function(V, o, l, f) {
                    var h = Et(V + "," + o + "," + l, function(_) {
                        Zn[_] = 1
                    });
                    Et(o, function(_) {
                        s.units[_] = "deg", Hn[_] = 1
                    }), lr[h[13]] = V + "," + o, Et(f, function(_) {
                        var v = _.split(":");
                        lr[v[1]] = h[v[0]]
                    })
                }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"), Et("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(V) {
                    s.units[V] = "px"
                }), mn.registerPlugin(Xr);
            var ri = mn.registerPlugin(Xr) || mn,
                so = ri.core.Tween;
            n.Back = dn, n.Bounce = Ri, n.CSSPlugin = Xr, n.Circ = hn, n.Cubic = wr, n.Elastic = dr, n.Expo = ei, n.Linear = ir, n.Power0 = Tn, n.Power1 = tn, n.Power2 = gt, n.Power3 = sn, n.Power4 = Sr, n.Quad = qr, n.Quart = li, n.Quint = Dn, n.Sine = Zt, n.SteppedEase = xi, n.Strong = Zi, n.TimelineLite = Zr, n.TimelineMax = Zr, n.TweenLite = Lr, n.TweenMax = so, n.default = ri, n.gsap = ri, typeof window > "u" || window !== n ? Object.defineProperty(n, "__esModule", {
                value: !0
            }) : delete window.default
        })
    }(yl, yl.exports)), yl.exports
}
var On = GC(),
    vl = {
        exports: {}
    },
    YC = vl.exports,
    Np;

function XC() {
    return Np || (Np = 1, function(e, t) {
        (function(n, r) {
            r(t)
        })(YC, function(n) {
            function r(Pe, C) {
                for (var Z = 0; Z < C.length; Z++) {
                    var F = C[Z];
                    F.enumerable = F.enumerable || !1, F.configurable = !0, "value" in F && (F.writable = !0), Object.defineProperty(Pe, F.key, F)
                }
            }

            function i(Pe, C, Z) {
                return C && r(Pe.prototype, C), Pe
            }
            /*!
             * Observer 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var s, a, c, u, p, d, g, m, E, L, b, j, A, $ = function() {
                    return s || typeof window < "u" && (s = window.gsap) && s.registerPlugin && s
                },
                w = 1,
                k = [],
                S = [],
                X = [],
                J = Date.now,
                xe = function(C, Z) {
                    return Z
                },
                he = function() {
                    var C = E.core,
                        Z = C.bridge || {},
                        F = C._scrollers,
                        H = C._proxies;
                    F.push.apply(F, S), H.push.apply(H, X), S = F, X = H, xe = function(Ge, Be) {
                        return Z[Ge](Be)
                    }
                },
                me = function(C, Z) {
                    return ~X.indexOf(C) && X[X.indexOf(C) + 1][Z]
                },
                Q = function(C) {
                    return !!~L.indexOf(C)
                },
                ne = function(C, Z, F, H, we) {
                    return C.addEventListener(Z, F, {
                        passive: H !== !1,
                        capture: !!we
                    })
                },
                re = function(C, Z, F, H) {
                    return C.removeEventListener(Z, F, !!H)
                },
                K = "scrollLeft",
                te = "scrollTop",
                G = function() {
                    return b && b.isPressed || S.cache++
                },
                ce = function(C, Z) {
                    var F = function H(we) {
                        if (we || we === 0) {
                            w && (c.history.scrollRestoration = "manual");
                            var Ge = b && b.isPressed;
                            we = H.v = Math.round(we) || (b && b.iOS ? 1 : 0), C(we), H.cacheID = S.cache, Ge && xe("ss", we)
                        } else(Z || S.cache !== H.cacheID || xe("ref")) && (H.cacheID = S.cache, H.v = C());
                        return H.v + H.offset
                    };
                    return F.offset = 0, C && F
                },
                le = {
                    s: K,
                    p: "left",
                    p2: "Left",
                    os: "right",
                    os2: "Right",
                    d: "width",
                    d2: "Width",
                    a: "x",
                    sc: ce(function(Pe) {
                        return arguments.length ? c.scrollTo(Pe, ve.sc()) : c.pageXOffset || u[K] || p[K] || d[K] || 0
                    })
                },
                ve = {
                    s: te,
                    p: "top",
                    p2: "Top",
                    os: "bottom",
                    os2: "Bottom",
                    d: "height",
                    d2: "Height",
                    a: "y",
                    op: le,
                    sc: ce(function(Pe) {
                        return arguments.length ? c.scrollTo(le.sc(), Pe) : c.pageYOffset || u[te] || p[te] || d[te] || 0
                    })
                },
                tt = function(C, Z) {
                    return (Z && Z._ctx && Z._ctx.selector || s.utils.toArray)(C)[0] || (typeof C == "string" && s.config().nullTargetWarn !== !1 ? console.warn("Element not found:", C) : null)
                },
                ht = function(C, Z) {
                    for (var F = Z.length; F--;)
                        if (Z[F] === C || Z[F].contains(C)) return !0;
                    return !1
                },
                lt = function(C, Z) {
                    var F = Z.s,
                        H = Z.sc;
                    Q(C) && (C = u.scrollingElement || p);
                    var we = S.indexOf(C),
                        Ge = H === ve.sc ? 1 : 2;
                    !~we && (we = S.push(C) - 1), S[we + Ge] || ne(C, "scroll", G);
                    var Be = S[we + Ge],
                        $t = Be || (S[we + Ge] = ce(me(C, F), !0) || (Q(C) ? H : ce(function(on) {
                            return arguments.length ? C[F] = on : C[F]
                        })));
                    return $t.target = C, Be || ($t.smooth = s.getProperty(C, "scrollBehavior") === "smooth"), $t
                },
                _t = function(C, Z, F) {
                    var H = C,
                        we = C,
                        Ge = J(),
                        Be = Ge,
                        $t = Z || 50,
                        on = Math.max(500, $t * 3),
                        mn = function(sn, Sr) {
                            var ir = J();
                            Sr || ir - Ge > $t ? (we = H, H = sn, Be = Ge, Ge = ir) : F ? H += sn : H = we + (sn - we) / (ir - Be) * (Ge - Be)
                        },
                        Tn = function() {
                            we = H = F ? 0 : H, Be = Ge = 0
                        },
                        tn = function(sn) {
                            var Sr = Be,
                                ir = we,
                                qr = J();
                            return (sn || sn === 0) && sn !== H && mn(sn), Ge === Be || qr - Be > on ? 0 : (H + (F ? ir : -ir)) / ((F ? qr : Ge) - Sr) * 1e3
                        };
                    return {
                        update: mn,
                        reset: Tn,
                        getVelocity: tn
                    }
                },
                mt = function(C, Z) {
                    return Z && !C._gsapAllow && C.preventDefault(), C.changedTouches ? C.changedTouches[0] : C
                },
                Pt = function(C) {
                    var Z = Math.max.apply(Math, C),
                        F = Math.min.apply(Math, C);
                    return Math.abs(Z) >= Math.abs(F) ? Z : F
                },
                St = function() {
                    E = s.core.globals().ScrollTrigger, E && E.core && he()
                },
                de = function(C) {
                    return s = C || $(), !a && s && typeof document < "u" && document.body && (c = window, u = document, p = u.documentElement, d = u.body, L = [c, u, p, d], s.utils.clamp, A = s.core.context || function() {}, m = "onpointerenter" in d ? "pointer" : "mouse", g = ye.isTouch = c.matchMedia && c.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in c || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, j = ye.eventTypes = ("ontouchstart" in p ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in p ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
                        return w = 0
                    }, 500), St(), a = 1), a
                };
            le.op = ve, S.cache = 0;
            var ye = function() {
                function Pe(Z) {
                    this.init(Z)
                }
                var C = Pe.prototype;
                return C.init = function(F) {
                    a || de(s) || console.warn("Please gsap.registerPlugin(Observer)"), E || St();
                    var H = F.tolerance,
                        we = F.dragMinimum,
                        Ge = F.type,
                        Be = F.target,
                        $t = F.lineHeight,
                        on = F.debounce,
                        mn = F.preventDefault,
                        Tn = F.onStop,
                        tn = F.onStopDelay,
                        gt = F.ignore,
                        sn = F.wheelSpeed,
                        Sr = F.event,
                        ir = F.onDragStart,
                        qr = F.onDragEnd,
                        wr = F.onDrag,
                        li = F.onPress,
                        Dn = F.onRelease,
                        Zi = F.onRight,
                        dr = F.onLeft,
                        dn = F.onUp,
                        xi = F.onDown,
                        Ri = F.onChangeX,
                        Zt = F.onChangeY,
                        ei = F.onChange,
                        hn = F.onToggleX,
                        hs = F.onToggleY,
                        sr = F.onHover,
                        $r = F.onHoverEnd,
                        ui = F.onMove,
                        Fn = F.ignoreCheck,
                        Fr = F.isNormalizer,
                        Tr = F.onGestureStart,
                        Ae = F.onGestureEnd,
                        Zn = F.onWheel,
                        Hi = F.onEnable,
                        Vi = F.onDisable,
                        ci = F.onClick,
                        ds = F.scrollSpeed,
                        ti = F.capture,
                        Hr = F.allowClicks,
                        Ei = F.lockAxis,
                        lr = F.onLockAxis;
                    this.target = Be = tt(Be) || p, this.vars = F, gt && (gt = s.utils.toArray(gt)), H = H || 1e-9, we = we || 0, sn = sn || 1, ds = ds || 1, Ge = Ge || "wheel,touch,pointer", on = on !== !1, $t || ($t = parseFloat(c.getComputedStyle(d).lineHeight) || 22);
                    var ps, Ci, Oi, In, Pr, Si, zi, Ye = this,
                        ji = 0,
                        Ps = 0,
                        js = F.passive || !mn && F.passive !== !1,
                        kr = lt(Be, le),
                        jn = lt(Be, ve),
                        Ir = kr(),
                        eo = jn(),
                        Gr = ~Ge.indexOf("touch") && !~Ge.indexOf("pointer") && j[0] === "pointerdown",
                        Us = Q(Be),
                        Ar = Be.ownerDocument || u,
                        es = [0, 0, 0],
                        Mi = [0, 0, 0],
                        Vr = 0,
                        wo = function() {
                            return Vr = J()
                        },
                        ur = function(nn, Hn) {
                            return (Ye.event = nn) && gt && ht(nn.target, gt) || Hn && Gr && nn.pointerType !== "touch" || Fn && Fn(nn, Hn)
                        },
                        Do = function() {
                            Ye._vx.reset(), Ye._vy.reset(), Ci.pause(), Tn && Tn(Ye)
                        },
                        gs = function() {
                            var nn = Ye.deltaX = Pt(es),
                                Hn = Ye.deltaY = Pt(Mi),
                                Nt = Math.abs(nn) >= H,
                                vn = Math.abs(Hn) >= H;
                            ei && (Nt || vn) && ei(Ye, nn, Hn, es, Mi), Nt && (Zi && Ye.deltaX > 0 && Zi(Ye), dr && Ye.deltaX < 0 && dr(Ye), Ri && Ri(Ye), hn && Ye.deltaX < 0 != ji < 0 && hn(Ye), ji = Ye.deltaX, es[0] = es[1] = es[2] = 0), vn && (xi && Ye.deltaY > 0 && xi(Ye), dn && Ye.deltaY < 0 && dn(Ye), Zt && Zt(Ye), hs && Ye.deltaY < 0 != Ps < 0 && hs(Ye), Ps = Ye.deltaY, Mi[0] = Mi[1] = Mi[2] = 0), (In || Oi) && (ui && ui(Ye), Oi && (ir && Oi === 1 && ir(Ye), wr && wr(Ye), Oi = 0), In = !1), Si && !(Si = !1) && lr && lr(Ye), Pr && (Zn(Ye), Pr = !1), ps = 0
                        },
                        to = function(nn, Hn, Nt) {
                            es[Nt] += nn, Mi[Nt] += Hn, Ye._vx.update(nn), Ye._vy.update(Hn), on ? ps || (ps = requestAnimationFrame(gs)) : gs()
                        },
                        no = function(nn, Hn) {
                            Ei && !zi && (Ye.axis = zi = Math.abs(nn) > Math.abs(Hn) ? "x" : "y", Si = !0), zi !== "y" && (es[2] += nn, Ye._vx.update(nn, !0)), zi !== "x" && (Mi[2] += Hn, Ye._vy.update(Hn, !0)), on ? ps || (ps = requestAnimationFrame(gs)) : gs()
                        },
                        ks = function(nn) {
                            if (!ur(nn, 1)) {
                                nn = mt(nn, mn);
                                var Hn = nn.clientX,
                                    Nt = nn.clientY,
                                    vn = Hn - Ye.x,
                                    en = Nt - Ye.y,
                                    gn = Ye.isDragging;
                                Ye.x = Hn, Ye.y = Nt, (gn || (vn || en) && (Math.abs(Ye.startX - Hn) >= we || Math.abs(Ye.startY - Nt) >= we)) && (Oi = gn ? 2 : 1, gn || (Ye.isDragging = !0), no(vn, en))
                            }
                        },
                        Ui = Ye.onPress = function(pn) {
                            ur(pn, 1) || pn && pn.button || (Ye.axis = zi = null, Ci.pause(), Ye.isPressed = !0, pn = mt(pn), ji = Ps = 0, Ye.startX = Ye.x = pn.clientX, Ye.startY = Ye.y = pn.clientY, Ye._vx.reset(), Ye._vy.reset(), ne(Fr ? Be : Ar, j[1], ks, js, !0), Ye.deltaX = Ye.deltaY = 0, li && li(Ye))
                        },
                        yn = Ye.onRelease = function(pn) {
                            if (!ur(pn, 1)) {
                                re(Fr ? Be : Ar, j[1], ks, !0);
                                var nn = !isNaN(Ye.y - Ye.startY),
                                    Hn = Ye.isDragging,
                                    Nt = Hn && (Math.abs(Ye.x - Ye.startX) > 3 || Math.abs(Ye.y - Ye.startY) > 3),
                                    vn = mt(pn);
                                !Nt && nn && (Ye._vx.reset(), Ye._vy.reset(), mn && Hr && s.delayedCall(.08, function() {
                                    if (J() - Vr > 300 && !pn.defaultPrevented) {
                                        if (pn.target.click) pn.target.click();
                                        else if (Ar.createEvent) {
                                            var en = Ar.createEvent("MouseEvents");
                                            en.initMouseEvent("click", !0, !0, c, 1, vn.screenX, vn.screenY, vn.clientX, vn.clientY, !1, !1, !1, !1, 0, null), pn.target.dispatchEvent(en)
                                        }
                                    }
                                })), Ye.isDragging = Ye.isGesturing = Ye.isPressed = !1, Tn && Hn && !Fr && Ci.restart(!0), Oi && gs(), qr && Hn && qr(Ye), Dn && Dn(Ye, Nt)
                            }
                        },
                        Ws = function(nn) {
                            return nn.touches && nn.touches.length > 1 && (Ye.isGesturing = !0) && Tr(nn, Ye.isDragging)
                        },
                        as = function() {
                            return (Ye.isGesturing = !1) || Ae(Ye)
                        },
                        ni = function(nn) {
                            if (!ur(nn)) {
                                var Hn = kr(),
                                    Nt = jn();
                                to((Hn - Ir) * ds, (Nt - eo) * ds, 1), Ir = Hn, eo = Nt, Tn && Ci.restart(!0)
                            }
                        },
                        Yr = function(nn) {
                            if (!ur(nn)) {
                                nn = mt(nn, mn), Zn && (Pr = !0);
                                var Hn = (nn.deltaMode === 1 ? $t : nn.deltaMode === 2 ? c.innerHeight : 1) * sn;
                                to(nn.deltaX * Hn, nn.deltaY * Hn, 0), Tn && !Fr && Ci.restart(!0)
                            }
                        },
                        ro = function(nn) {
                            if (!ur(nn)) {
                                var Hn = nn.clientX,
                                    Nt = nn.clientY,
                                    vn = Hn - Ye.x,
                                    en = Nt - Ye.y;
                                Ye.x = Hn, Ye.y = Nt, In = !0, Tn && Ci.restart(!0), (vn || en) && no(vn, en)
                            }
                        },
                        io = function(nn) {
                            Ye.event = nn, sr(Ye)
                        },
                        As = function(nn) {
                            Ye.event = nn, $r(Ye)
                        },
                        ta = function(nn) {
                            return ur(nn) || mt(nn, mn) && ci(Ye)
                        };
                    Ci = Ye._dc = s.delayedCall(tn || .25, Do).pause(), Ye.deltaX = Ye.deltaY = 0, Ye._vx = _t(0, 50, !0), Ye._vy = _t(0, 50, !0), Ye.scrollX = kr, Ye.scrollY = jn, Ye.isDragging = Ye.isGesturing = Ye.isPressed = !1, A(this), Ye.enable = function(pn) {
                        return Ye.isEnabled || (ne(Us ? Ar : Be, "scroll", G), Ge.indexOf("scroll") >= 0 && ne(Us ? Ar : Be, "scroll", ni, js, ti), Ge.indexOf("wheel") >= 0 && ne(Be, "wheel", Yr, js, ti), (Ge.indexOf("touch") >= 0 && g || Ge.indexOf("pointer") >= 0) && (ne(Be, j[0], Ui, js, ti), ne(Ar, j[2], yn), ne(Ar, j[3], yn), Hr && ne(Be, "click", wo, !0, !0), ci && ne(Be, "click", ta), Tr && ne(Ar, "gesturestart", Ws), Ae && ne(Ar, "gestureend", as), sr && ne(Be, m + "enter", io), $r && ne(Be, m + "leave", As), ui && ne(Be, m + "move", ro)), Ye.isEnabled = !0, Ye.isDragging = Ye.isGesturing = Ye.isPressed = In = Oi = !1, Ye._vx.reset(), Ye._vy.reset(), Ir = kr(), eo = jn(), pn && pn.type && Ui(pn), Hi && Hi(Ye)), Ye
                    }, Ye.disable = function() {
                        Ye.isEnabled && (k.filter(function(pn) {
                            return pn !== Ye && Q(pn.target)
                        }).length || re(Us ? Ar : Be, "scroll", G), Ye.isPressed && (Ye._vx.reset(), Ye._vy.reset(), re(Fr ? Be : Ar, j[1], ks, !0)), re(Us ? Ar : Be, "scroll", ni, ti), re(Be, "wheel", Yr, ti), re(Be, j[0], Ui, ti), re(Ar, j[2], yn), re(Ar, j[3], yn), re(Be, "click", wo, !0), re(Be, "click", ta), re(Ar, "gesturestart", Ws), re(Ar, "gestureend", as), re(Be, m + "enter", io), re(Be, m + "leave", As), re(Be, m + "move", ro), Ye.isEnabled = Ye.isPressed = Ye.isDragging = !1, Vi && Vi(Ye))
                    }, Ye.kill = Ye.revert = function() {
                        Ye.disable();
                        var pn = k.indexOf(Ye);
                        pn >= 0 && k.splice(pn, 1), b === Ye && (b = 0)
                    }, k.push(Ye), Fr && Q(Be) && (b = Ye), Ye.enable(Sr)
                }, i(Pe, [{
                    key: "velocityX",
                    get: function() {
                        return this._vx.getVelocity()
                    }
                }, {
                    key: "velocityY",
                    get: function() {
                        return this._vy.getVelocity()
                    }
                }]), Pe
            }();
            ye.version = "3.13.0", ye.create = function(Pe) {
                return new ye(Pe)
            }, ye.register = de, ye.getAll = function() {
                return k.slice()
            }, ye.getById = function(Pe) {
                return k.filter(function(C) {
                    return C.vars.id === Pe
                })[0]
            }, $() && s.registerPlugin(ye);
            /*!
             * ScrollTrigger 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var oe, ze, Se, Ke, M, I, fe, Oe, Te, Ie, st, nt, je, We, bt, Ze, wt, Et, Ot, qt, an, Rn, un, An, Un, er, ft, Y, ie, ge, ke, Le, Ee, Ne, qe = 1,
                Ve = Date.now,
                yt = Ve(),
                rt = 0,
                He = 0,
                ot = function(C, Z, F) {
                    var H = P(C) && (C.substr(0, 6) === "clamp(" || C.indexOf("max") > -1);
                    return F["_" + Z + "Clamp"] = H, H ? C.substr(6, C.length - 7) : C
                },
                Mt = function(C, Z) {
                    return Z && (!P(C) || C.substr(0, 6) !== "clamp(") ? "clamp(" + C + ")" : C
                },
                ut = function Pe() {
                    return He && requestAnimationFrame(Pe)
                },
                pt = function() {
                    return We = 1
                },
                Qe = function() {
                    return We = 0
                },
                Re = function(C) {
                    return C
                },
                T = function(C) {
                    return Math.round(C * 1e5) / 1e5 || 0
                },
                z = function() {
                    return typeof window < "u"
                },
                R = function() {
                    return oe || z() && (oe = window.gsap) && oe.registerPlugin && oe
                },
                ee = function(C) {
                    return !!~fe.indexOf(C)
                },
                ae = function(C) {
                    return (C === "Height" ? ke : Se["inner" + C]) || M["client" + C] || I["client" + C]
                },
                Fe = function(C) {
                    return me(C, "getBoundingClientRect") || (ee(C) ? function() {
                        return bo.width = Se.innerWidth, bo.height = ke, bo
                    } : function() {
                        return fr(C)
                    })
                },
                at = function(C, Z, F) {
                    var H = F.d,
                        we = F.d2,
                        Ge = F.a;
                    return (Ge = me(C, "getBoundingClientRect")) ? function() {
                        return Ge()[H]
                    } : function() {
                        return (Z ? ae(we) : C["client" + we]) || 0
                    }
                },
                O = function(C, Z) {
                    return !Z || ~X.indexOf(C) ? Fe(C) : function() {
                        return bo
                    }
                },
                y = function(C, Z) {
                    var F = Z.s,
                        H = Z.d2,
                        we = Z.d,
                        Ge = Z.a;
                    return Math.max(0, (F = "scroll" + H) && (Ge = me(C, F)) ? Ge() - Fe(C)()[we] : ee(C) ? (M[F] || I[F]) - ae(H) : C[F] - C["offset" + H])
                },
                x = function(C, Z) {
                    for (var F = 0; F < Ot.length; F += 3)(!Z || ~Z.indexOf(Ot[F + 1])) && C(Ot[F], Ot[F + 1], Ot[F + 2])
                },
                P = function(C) {
                    return typeof C == "string"
                },
                B = function(C) {
                    return typeof C == "function"
                },
                q = function(C) {
                    return typeof C == "number"
                },
                ue = function(C) {
                    return typeof C == "object"
                },
                be = function(C, Z, F) {
                    return C && C.progress(Z ? 0 : 1) && F && C.pause()
                },
                Ce = function(C, Z) {
                    if (C.enabled) {
                        var F = C._ctx ? C._ctx.add(function() {
                            return Z(C)
                        }) : Z(C);
                        F && F.totalTime && (C.callbackAnimation = F)
                    }
                },
                se = Math.abs,
                Ue = "left",
                _e = "top",
                Xe = "right",
                Je = "bottom",
                ct = "width",
                dt = "height",
                Bt = "Right",
                Lt = "Left",
                Tt = "Top",
                It = "Bottom",
                Ft = "padding",
                Jt = "margin",
                Gt = "Width",
                jt = "Height",
                rn = "px",
                cn = function(C) {
                    return Se.getComputedStyle(C)
                },
                Mr = function(C) {
                    var Z = cn(C).position;
                    C.style.position = Z === "absolute" || Z === "fixed" ? Z : "relative"
                },
                tr = function(C, Z) {
                    for (var F in Z) F in C || (C[F] = Z[F]);
                    return C
                },
                fr = function(C, Z) {
                    var F = Z && cn(C)[bt] !== "matrix(1, 0, 0, 1, 0, 0)" && oe.to(C, {
                            x: 0,
                            y: 0,
                            xPercent: 0,
                            yPercent: 0,
                            rotation: 0,
                            rotationX: 0,
                            rotationY: 0,
                            scale: 1,
                            skewX: 0,
                            skewY: 0
                        }).progress(1),
                        H = C.getBoundingClientRect();
                    return F && F.progress(0).kill(), H
                },
                hr = function(C, Z) {
                    var F = Z.d2;
                    return C["offset" + F] || C["client" + F] || 0
                },
                br = function(C) {
                    var Z = [],
                        F = C.labels,
                        H = C.duration(),
                        we;
                    for (we in F) Z.push(F[we] / H);
                    return Z
                },
                nr = function(C) {
                    return function(Z) {
                        return oe.utils.snap(br(C), Z)
                    }
                },
                rr = function(C) {
                    var Z = oe.utils.snap(C),
                        F = Array.isArray(C) && C.slice(0).sort(function(H, we) {
                            return H - we
                        });
                    return F ? function(H, we, Ge) {
                        Ge === void 0 && (Ge = .001);
                        var Be;
                        if (!we) return Z(H);
                        if (we > 0) {
                            for (H -= Ge, Be = 0; Be < F.length; Be++)
                                if (F[Be] >= H) return F[Be];
                            return F[Be - 1]
                        } else
                            for (Be = F.length, H += Ge; Be--;)
                                if (F[Be] <= H) return F[Be];
                        return F[0]
                    } : function(H, we, Ge) {
                        Ge === void 0 && (Ge = .001);
                        var Be = Z(H);
                        return !we || Math.abs(Be - H) < Ge || Be - H < 0 == we < 0 ? Be : Z(we < 0 ? H - C : H + C)
                    }
                },
                Vn = function(C) {
                    return function(Z, F) {
                        return rr(br(C))(Z, F.direction)
                    }
                },
                Ln = function(C, Z, F, H) {
                    return F.split(",").forEach(function(we) {
                        return C(Z, we, H)
                    })
                },
                qn = function(C, Z, F, H, we) {
                    return C.addEventListener(Z, F, {
                        passive: !H,
                        capture: !!we
                    })
                },
                Yt = function(C, Z, F, H) {
                    return C.removeEventListener(Z, F, !!H)
                },
                Cr = function(C, Z, F) {
                    F = F && F.wheelHandler, F && (C(Z, "wheel", F), C(Z, "touchmove", F))
                },
                oi = {
                    startColor: "green",
                    endColor: "red",
                    indent: 0,
                    fontSize: "16px",
                    fontWeight: "normal"
                },
                ar = {
                    toggleActions: "play",
                    anticipatePin: 0
                },
                Pi = {
                    top: 0,
                    left: 0,
                    center: .5,
                    bottom: 1,
                    right: 1
                },
                zn = function(C, Z) {
                    if (P(C)) {
                        var F = C.indexOf("="),
                            H = ~F ? +(C.charAt(F - 1) + 1) * parseFloat(C.substr(F + 1)) : 0;
                        ~F && (C.indexOf("%") > F && (H *= Z / 100), C = C.substr(0, F - 1)), C = H + (C in Pi ? Pi[C] * Z : ~C.indexOf("%") ? parseFloat(C) * Z / 100 : parseFloat(C) || 0)
                    }
                    return C
                },
                Gn = function(C, Z, F, H, we, Ge, Be, $t) {
                    var on = we.startColor,
                        mn = we.endColor,
                        Tn = we.fontSize,
                        tn = we.indent,
                        gt = we.fontWeight,
                        sn = Ke.createElement("div"),
                        Sr = ee(F) || me(F, "pinType") === "fixed",
                        ir = C.indexOf("scroller") !== -1,
                        qr = Sr ? I : F,
                        wr = C.indexOf("start") !== -1,
                        li = wr ? on : mn,
                        Dn = "border-color:" + li + ";font-size:" + Tn + ";color:" + li + ";font-weight:" + gt + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                    return Dn += "position:" + ((ir || $t) && Sr ? "fixed;" : "absolute;"), (ir || $t || !Sr) && (Dn += (H === ve ? Xe : Je) + ":" + (Ge + parseFloat(tn)) + "px;"), Be && (Dn += "box-sizing:border-box;text-align:left;width:" + Be.offsetWidth + "px;"), sn._isStart = wr, sn.setAttribute("class", "gsap-marker-" + C + (Z ? " marker-" + Z : "")), sn.style.cssText = Dn, sn.innerText = Z || Z === 0 ? C + "-" + Z : C, qr.children[0] ? qr.insertBefore(sn, qr.children[0]) : qr.appendChild(sn), sn._offset = sn["offset" + H.op.d2], xs(sn, 0, H, wr), sn
                },
                xs = function(C, Z, F, H) {
                    var we = {
                            display: "block"
                        },
                        Ge = F[H ? "os2" : "p2"],
                        Be = F[H ? "p2" : "os2"];
                    C._isFlipped = H, we[F.a + "Percent"] = H ? -100 : 0, we[F.a] = H ? "1px" : 0, we["border" + Ge + Gt] = 1, we["border" + Be + Gt] = 0, we[F.p] = Z + "px", oe.set(C, we)
                },
                fn = [],
                Wr = {},
                En, Es = function() {
                    return Ve() - rt > 34 && (En || (En = requestAnimationFrame(os)))
                },
                _n = function() {
                    (!un || !un.isPressed || un.startX > I.clientWidth) && (S.cache++, un ? En || (En = requestAnimationFrame(os)) : os(), rt || Hs("scrollStart"), rt = Ve())
                },
                bn = function() {
                    er = Se.innerWidth, Un = Se.innerHeight
                },
                $s = function(C) {
                    S.cache++, (C === !0 || !je && !Rn && !Ke.fullscreenElement && !Ke.webkitFullscreenElement && (!An || er !== Se.innerWidth || Math.abs(Se.innerHeight - Un) > Se.innerHeight * .25)) && Oe.restart(!0)
                },
                Js = {},
                Vc = [],
                fu = function Pe() {
                    return Yt(Cn, "scrollEnd", Pe) || Ts(!0)
                },
                Hs = function(C) {
                    return Js[C] && Js[C].map(function(Z) {
                        return Z()
                    }) || Vc
                },
                ki = [],
                Vs = function(C) {
                    for (var Z = 0; Z < ki.length; Z += 5)(!C || ki[Z + 4] && ki[Z + 4].query === C) && (ki[Z].style.cssText = ki[Z + 1], ki[Z].getBBox && ki[Z].setAttribute("transform", ki[Z + 2] || ""), ki[Z + 3].uncache = 1)
                },
                Cs = function(C, Z) {
                    var F;
                    for (Ze = 0; Ze < fn.length; Ze++) F = fn[Ze], F && (!Z || F._ctx === Z) && (C ? F.kill(1) : F.revert(!0, !0));
                    Le = !0, Z && Vs(Z), Z || Hs("revert")
                },
                el = function(C, Z) {
                    S.cache++, (Z || !ai) && S.forEach(function(F) {
                        return B(F) && F.cacheID++ && (F.rec = 0)
                    }), P(C) && (Se.history.scrollRestoration = ie = C)
                },
                ai, Ss = 0,
                tl, Yo = function() {
                    if (tl !== Ss) {
                        var C = tl = Ss;
                        requestAnimationFrame(function() {
                            return C === Ss && Ts(!0)
                        })
                    }
                },
                Zr = function() {
                    I.appendChild(ge), ke = !un && ge.offsetHeight || Se.innerHeight, I.removeChild(ge)
                },
                hu = function(C) {
                    return Te(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(Z) {
                        return Z.style.display = C ? "none" : "block"
                    })
                },
                Ts = function(C, Z) {
                    if (M = Ke.documentElement, I = Ke.body, fe = [Se, Ke, M, I], rt && !C && !Le) {
                        qn(Cn, "scrollEnd", fu);
                        return
                    }
                    Zr(), ai = Cn.isRefreshing = !0, S.forEach(function(H) {
                        return B(H) && ++H.cacheID && (H.rec = H())
                    });
                    var F = Hs("refreshInit");
                    qt && Cn.sort(), Z || Cs(), S.forEach(function(H) {
                        B(H) && (H.smooth && (H.target.style.scrollBehavior = "auto"), H(0))
                    }), fn.slice(0).forEach(function(H) {
                        return H.refresh()
                    }), Le = !1, fn.forEach(function(H) {
                        if (H._subPinOffset && H.pin) {
                            var we = H.vars.horizontal ? "offsetWidth" : "offsetHeight",
                                Ge = H.pin[we];
                            H.revert(!0, 1), H.adjustPinSpacing(H.pin[we] - Ge), H.refresh()
                        }
                    }), Ee = 1, hu(!0), fn.forEach(function(H) {
                        var we = y(H.scroller, H._dir),
                            Ge = H.vars.end === "max" || H._endClamp && H.end > we,
                            Be = H._startClamp && H.start >= we;
                        (Ge || Be) && H.setPositions(Be ? we - 1 : H.start, Ge ? Math.max(Be ? we : H.start + 1, we) : H.end, !0)
                    }), hu(!1), Ee = 0, F.forEach(function(H) {
                        return H && H.render && H.render(-1)
                    }), S.forEach(function(H) {
                        B(H) && (H.smooth && requestAnimationFrame(function() {
                            return H.target.style.scrollBehavior = "smooth"
                        }), H.rec && H(H.rec))
                    }), el(ie, 1), Oe.pause(), Ss++, ai = 2, os(2), fn.forEach(function(H) {
                        return B(H.vars.onRefresh) && H.vars.onRefresh(H)
                    }), ai = Cn.isRefreshing = !1, Hs("refresh")
                },
                nl = 0,
                Xo = 1,
                Ji, os = function(C) {
                    if (C === 2 || !ai && !Le) {
                        Cn.isUpdating = !0, Ji && Ji.update(0);
                        var Z = fn.length,
                            F = Ve(),
                            H = F - yt >= 50,
                            we = Z && fn[0].scroll();
                        if (Xo = nl > we ? -1 : 1, ai || (nl = we), H && (rt && !We && F - rt > 200 && (rt = 0, Hs("scrollEnd")), st = yt, yt = F), Xo < 0) {
                            for (Ze = Z; Ze-- > 0;) fn[Ze] && fn[Ze].update(0, H);
                            Xo = 1
                        } else
                            for (Ze = 0; Ze < Z; Ze++) fn[Ze] && fn[Ze].update(0, H);
                        Cn.isUpdating = !1
                    }
                    En = 0
                },
                Ko = [Ue, _e, Je, Xe, Jt + It, Jt + Bt, Jt + Tt, Jt + Lt, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
                wa = Ko.concat([ct, dt, "boxSizing", "max" + Gt, "max" + jt, "position", Jt, Ft, Ft + Tt, Ft + Bt, Ft + It, Ft + Lt]),
                zc = function(C, Z, F) {
                    Zs(F);
                    var H = C._gsap;
                    if (H.spacerIsNative) Zs(H.spacerState);
                    else if (C._gsap.swappedIn) {
                        var we = Z.parentNode;
                        we && (we.insertBefore(C, Z), we.removeChild(Z))
                    }
                    C._gsap.swappedIn = !1
                },
                rl = function(C, Z, F, H) {
                    if (!C._gsap.swappedIn) {
                        for (var we = Ko.length, Ge = Z.style, Be = C.style, $t; we--;) $t = Ko[we], Ge[$t] = F[$t];
                        Ge.position = F.position === "absolute" ? "absolute" : "relative", F.display === "inline" && (Ge.display = "inline-block"), Be[Je] = Be[Xe] = "auto", Ge.flexBasis = F.flexBasis || "auto", Ge.overflow = "visible", Ge.boxSizing = "border-box", Ge[ct] = hr(C, le) + rn, Ge[dt] = hr(C, ve) + rn, Ge[Ft] = Be[Jt] = Be[_e] = Be[Ue] = "0", Zs(H), Be[ct] = Be["max" + Gt] = F[ct], Be[dt] = Be["max" + jt] = F[dt], Be[Ft] = F[Ft], C.parentNode !== Z && (C.parentNode.insertBefore(Z, C), Z.appendChild(C)), C._gsap.swappedIn = !0
                    }
                },
                Qo = /([A-Z])/g,
                Zs = function(C) {
                    if (C) {
                        var Z = C.t.style,
                            F = C.length,
                            H = 0,
                            we, Ge;
                        for ((C.t._gsap || oe.core.getCache(C.t)).uncache = 1; H < F; H += 2) Ge = C[H + 1], we = C[H], Ge ? Z[we] = Ge : Z[we] && Z.removeProperty(we.replace(Qo, "-$1").toLowerCase())
                    }
                },
                Jo = function(C) {
                    for (var Z = wa.length, F = C.style, H = [], we = 0; we < Z; we++) H.push(wa[we], F[wa[we]]);
                    return H.t = C, H
                },
                Lr = function(C, Z, F) {
                    for (var H = [], we = C.length, Ge = F ? 8 : 0, Be; Ge < we; Ge += 2) Be = C[Ge], H.push(Be, Be in Z ? Z[Be] : C[Ge + 1]);
                    return H.t = C.t, H
                },
                bo = {
                    left: 0,
                    top: 0
                },
                il = function(C, Z, F, H, we, Ge, Be, $t, on, mn, Tn, tn, gt, sn) {
                    B(C) && (C = C($t)), P(C) && C.substr(0, 3) === "max" && (C = tn + (C.charAt(4) === "=" ? zn("0" + C.substr(3), F) : 0));
                    var Sr = gt ? gt.time() : 0,
                        ir, qr, wr;
                    if (gt && gt.seek(0), isNaN(C) || (C = +C), q(C)) gt && (C = oe.utils.mapRange(gt.scrollTrigger.start, gt.scrollTrigger.end, 0, tn, C)), Be && xs(Be, F, H, !0);
                    else {
                        B(Z) && (Z = Z($t));
                        var li = (C || "0").split(" "),
                            Dn, Zi, dr, dn;
                        wr = tt(Z, $t) || I, Dn = fr(wr) || {}, (!Dn || !Dn.left && !Dn.top) && cn(wr).display === "none" && (dn = wr.style.display, wr.style.display = "block", Dn = fr(wr), dn ? wr.style.display = dn : wr.style.removeProperty("display")), Zi = zn(li[0], Dn[H.d]), dr = zn(li[1] || "0", F), C = Dn[H.p] - on[H.p] - mn + Zi + we - dr, Be && xs(Be, dr, H, F - dr < 20 || Be._isStart && dr > 20), F -= F - dr
                    }
                    if (sn && ($t[sn] = C || -.001, C < 0 && (C = 0)), Ge) {
                        var xi = C + F,
                            Ri = Ge._isStart;
                        ir = "scroll" + H.d2, xs(Ge, xi, H, Ri && xi > 20 || !Ri && (Tn ? Math.max(I[ir], M[ir]) : Ge.parentNode[ir]) <= xi + 1), Tn && (on = fr(Be), Tn && (Ge.style[H.op.p] = on[H.op.p] - H.op.m - Ge._offset + rn))
                    }
                    return gt && wr && (ir = fr(wr), gt.seek(tn), qr = fr(wr), gt._caScrollDist = ir[H.p] - qr[H.p], C = C / gt._caScrollDist * tn), gt && gt.seek(Sr), gt ? C : Math.round(C)
                },
                jc = /(webkit|moz|length|cssText|inset)/i,
                du = function(C, Z, F, H) {
                    if (C.parentNode !== Z) {
                        var we = C.style,
                            Ge, Be;
                        if (Z === I) {
                            C._stOrig = we.cssText, Be = cn(C);
                            for (Ge in Be) !+Ge && !jc.test(Ge) && Be[Ge] && typeof we[Ge] == "string" && Ge !== "0" && (we[Ge] = Be[Ge]);
                            we.top = F, we.left = H
                        } else we.cssText = C._stOrig;
                        oe.core.getCache(C).uncache = 1, Z.appendChild(C)
                    }
                },
                Da = function(C, Z, F) {
                    var H = Z,
                        we = H;
                    return function(Ge) {
                        var Be = Math.round(C());
                        return Be !== H && Be !== we && Math.abs(Be - H) > 3 && Math.abs(Be - we) > 3 && (Ge = Be, F && F()), we = H, H = Math.round(Ge), H
                    }
                },
                Zo = function(C, Z, F) {
                    var H = {};
                    H[Z.p] = "+=" + F, oe.set(C, H)
                },
                pu = function(C, Z) {
                    var F = lt(C, Z),
                        H = "_scroll" + Z.p2,
                        we = function Ge(Be, $t, on, mn, Tn) {
                            var tn = Ge.tween,
                                gt = $t.onComplete,
                                sn = {};
                            on = on || F();
                            var Sr = Da(F, on, function() {
                                tn.kill(), Ge.tween = 0
                            });
                            return Tn = mn && Tn || 0, mn = mn || Be - on, tn && tn.kill(), $t[H] = Be, $t.inherit = !1, $t.modifiers = sn, sn[H] = function() {
                                return Sr(on + mn * tn.ratio + Tn * tn.ratio * tn.ratio)
                            }, $t.onUpdate = function() {
                                S.cache++, Ge.tween && os()
                            }, $t.onComplete = function() {
                                Ge.tween = 0, gt && gt.call(tn)
                            }, tn = Ge.tween = oe.to(C, $t), tn
                        };
                    return C[H] = F, F.wheelHandler = function() {
                        return we.tween && we.tween.kill() && (we.tween = 0)
                    }, qn(C, "wheel", F.wheelHandler), Cn.isTouch && qn(C, "touchmove", F.wheelHandler), we
                },
                Cn = function() {
                    function Pe(Z, F) {
                        ze || Pe.register(oe) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), Y(this), this.init(Z, F)
                    }
                    var C = Pe.prototype;
                    return C.init = function(F, H) {
                        if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !He) {
                            this.update = this.refresh = this.kill = Re;
                            return
                        }
                        F = tr(P(F) || q(F) || F.nodeType ? {
                            trigger: F
                        } : F, ar);
                        var we = F,
                            Ge = we.onUpdate,
                            Be = we.toggleClass,
                            $t = we.id,
                            on = we.onToggle,
                            mn = we.onRefresh,
                            Tn = we.scrub,
                            tn = we.trigger,
                            gt = we.pin,
                            sn = we.pinSpacing,
                            Sr = we.invalidateOnRefresh,
                            ir = we.anticipatePin,
                            qr = we.onScrubComplete,
                            wr = we.onSnapComplete,
                            li = we.once,
                            Dn = we.snap,
                            Zi = we.pinReparent,
                            dr = we.pinSpacer,
                            dn = we.containerAnimation,
                            xi = we.fastScrollEnd,
                            Ri = we.preventOverlaps,
                            Zt = F.horizontal || F.containerAnimation && F.horizontal !== !1 ? le : ve,
                            ei = !Tn && Tn !== 0,
                            hn = tt(F.scroller || Se),
                            hs = oe.core.getCache(hn),
                            sr = ee(hn),
                            $r = ("pinType" in F ? F.pinType : me(hn, "pinType") || sr && "fixed") === "fixed",
                            ui = [F.onEnter, F.onLeave, F.onEnterBack, F.onLeaveBack],
                            Fn = ei && F.toggleActions.split(" "),
                            Fr = "markers" in F ? F.markers : ar.markers,
                            Tr = sr ? 0 : parseFloat(cn(hn)["border" + Zt.p2 + Gt]) || 0,
                            Ae = this,
                            Zn = F.onRefreshInit && function() {
                                return F.onRefreshInit(Ae)
                            },
                            Hi = at(hn, sr, Zt),
                            Vi = O(hn, sr),
                            ci = 0,
                            ds = 0,
                            ti = 0,
                            Hr = lt(hn, Zt),
                            Ei, lr, ps, Ci, Oi, In, Pr, Si, zi, Ye, ji, Ps, js, kr, jn, Ir, eo, Gr, Us, Ar, es, Mi, Vr, wo, ur, Do, gs, to, no, ks, Ui, yn, Ws, as, ni, Yr, ro, io, As;
                        if (Ae._startClamp = Ae._endClamp = !1, Ae._dir = Zt, ir *= 45, Ae.scroller = hn, Ae.scroll = dn ? dn.time.bind(dn) : Hr, Ci = Hr(), Ae.vars = F, H = H || F.animation, "refreshPriority" in F && (qt = 1, F.refreshPriority === -9999 && (Ji = Ae)), hs.tweenScroll = hs.tweenScroll || {
                                top: pu(hn, ve),
                                left: pu(hn, le)
                            }, Ae.tweenTo = Ei = hs.tweenScroll[Zt.p], Ae.scrubDuration = function(Nt) {
                                Ws = q(Nt) && Nt, Ws ? yn ? yn.duration(Nt) : yn = oe.to(H, {
                                    ease: "expo",
                                    totalProgress: "+=0",
                                    inherit: !1,
                                    duration: Ws,
                                    paused: !0,
                                    onComplete: function() {
                                        return qr && qr(Ae)
                                    }
                                }) : (yn && yn.progress(1).kill(), yn = 0)
                            }, H && (H.vars.lazy = !1, H._initted && !Ae.isReverted || H.vars.immediateRender !== !1 && F.immediateRender !== !1 && H.duration() && H.render(0, !0, !0), Ae.animation = H.pause(), H.scrollTrigger = Ae, Ae.scrubDuration(Tn), ks = 0, $t || ($t = H.vars.id)), Dn && ((!ue(Dn) || Dn.push) && (Dn = {
                                snapTo: Dn
                            }), "scrollBehavior" in I.style && oe.set(sr ? [I, M] : hn, {
                                scrollBehavior: "auto"
                            }), S.forEach(function(Nt) {
                                return B(Nt) && Nt.target === (sr ? Ke.scrollingElement || M : hn) && (Nt.smooth = !1)
                            }), ps = B(Dn.snapTo) ? Dn.snapTo : Dn.snapTo === "labels" ? nr(H) : Dn.snapTo === "labelsDirectional" ? Vn(H) : Dn.directional !== !1 ? function(Nt, vn) {
                                return rr(Dn.snapTo)(Nt, Ve() - ds < 500 ? 0 : vn.direction)
                            } : oe.utils.snap(Dn.snapTo), as = Dn.duration || {
                                min: .1,
                                max: 2
                            }, as = ue(as) ? Ie(as.min, as.max) : Ie(as, as), ni = oe.delayedCall(Dn.delay || Ws / 2 || .1, function() {
                                var Nt = Hr(),
                                    vn = Ve() - ds < 500,
                                    en = Ei.tween;
                                if ((vn || Math.abs(Ae.getVelocity()) < 10) && !en && !We && ci !== Nt) {
                                    var gn = (Nt - In) / kr,
                                        Rr = H && !ei ? H.totalProgress() : gn,
                                        Sn = vn ? 0 : (Rr - Ui) / (Ve() - st) * 1e3 || 0,
                                        Dr = oe.utils.clamp(-gn, 1 - gn, se(Sn / 2) * Sn / .185),
                                        yi = gn + (Dn.inertia === !1 ? 0 : Dr),
                                        Kn, Qn, Nn = Dn,
                                        ts = Nn.onStart,
                                        xr = Nn.onInterrupt,
                                        Wi = Nn.onComplete;
                                    if (Kn = ps(yi, Ae), q(Kn) || (Kn = yi), Qn = Math.max(0, Math.round(In + Kn * kr)), Nt <= Pr && Nt >= In && Qn !== Nt) {
                                        if (en && !en._initted && en.data <= se(Qn - Nt)) return;
                                        Dn.inertia === !1 && (Dr = Kn - gn), Ei(Qn, {
                                            duration: as(se(Math.max(se(yi - Rr), se(Kn - Rr)) * .185 / Sn / .05 || 0)),
                                            ease: Dn.ease || "power3",
                                            data: se(Qn - Nt),
                                            onInterrupt: function() {
                                                return ni.restart(!0) && xr && xr(Ae)
                                            },
                                            onComplete: function() {
                                                Ae.update(), ci = Hr(), H && !ei && (yn ? yn.resetTo("totalProgress", Kn, H._tTime / H._tDur) : H.progress(Kn)), ks = Ui = H && !ei ? H.totalProgress() : Ae.progress, wr && wr(Ae), Wi && Wi(Ae)
                                            }
                                        }, Nt, Dr * kr, Qn - Nt - Dr * kr), ts && ts(Ae, Ei.tween)
                                    }
                                } else Ae.isActive && ci !== Nt && ni.restart(!0)
                            }).pause()), $t && (Wr[$t] = Ae), tn = Ae.trigger = tt(tn || gt !== !0 && gt), As = tn && tn._gsap && tn._gsap.stRevert, As && (As = As(Ae)), gt = gt === !0 ? tn : tt(gt), P(Be) && (Be = {
                                targets: tn,
                                className: Be
                            }), gt && (sn === !1 || sn === Jt || (sn = !sn && gt.parentNode && gt.parentNode.style && cn(gt.parentNode).display === "flex" ? !1 : Ft), Ae.pin = gt, lr = oe.core.getCache(gt), lr.spacer ? jn = lr.pinState : (dr && (dr = tt(dr), dr && !dr.nodeType && (dr = dr.current || dr.nativeElement), lr.spacerIsNative = !!dr, dr && (lr.spacerState = Jo(dr))), lr.spacer = Gr = dr || Ke.createElement("div"), Gr.classList.add("pin-spacer"), $t && Gr.classList.add("pin-spacer-" + $t), lr.pinState = jn = Jo(gt)), F.force3D !== !1 && oe.set(gt, {
                                force3D: !0
                            }), Ae.spacer = Gr = lr.spacer, no = cn(gt), wo = no[sn + Zt.os2], Ar = oe.getProperty(gt), es = oe.quickSetter(gt, Zt.a, rn), rl(gt, Gr, no), eo = Jo(gt)), Fr) {
                            Ps = ue(Fr) ? tr(Fr, oi) : oi, Ye = Gn("scroller-start", $t, hn, Zt, Ps, 0), ji = Gn("scroller-end", $t, hn, Zt, Ps, 0, Ye), Us = Ye["offset" + Zt.op.d2];
                            var ta = tt(me(hn, "content") || hn);
                            Si = this.markerStart = Gn("start", $t, ta, Zt, Ps, Us, 0, dn), zi = this.markerEnd = Gn("end", $t, ta, Zt, Ps, Us, 0, dn), dn && (io = oe.quickSetter([Si, zi], Zt.a, rn)), !$r && !(X.length && me(hn, "fixedMarkers") === !0) && (Mr(sr ? I : hn), oe.set([Ye, ji], {
                                force3D: !0
                            }), Do = oe.quickSetter(Ye, Zt.a, rn), to = oe.quickSetter(ji, Zt.a, rn))
                        }
                        if (dn) {
                            var pn = dn.vars.onUpdate,
                                nn = dn.vars.onUpdateParams;
                            dn.eventCallback("onUpdate", function() {
                                Ae.update(0, 0, 1), pn && pn.apply(dn, nn || [])
                            })
                        }
                        if (Ae.previous = function() {
                                return fn[fn.indexOf(Ae) - 1]
                            }, Ae.next = function() {
                                return fn[fn.indexOf(Ae) + 1]
                            }, Ae.revert = function(Nt, vn) {
                                if (!vn) return Ae.kill(!0);
                                var en = Nt !== !1 || !Ae.enabled,
                                    gn = je;
                                en !== Ae.isReverted && (en && (Yr = Math.max(Hr(), Ae.scroll.rec || 0), ti = Ae.progress, ro = H && H.progress()), Si && [Si, zi, Ye, ji].forEach(function(Rr) {
                                    return Rr.style.display = en ? "none" : "block"
                                }), en && (je = Ae, Ae.update(en)), gt && (!Zi || !Ae.isActive) && (en ? zc(gt, Gr, jn) : rl(gt, Gr, cn(gt), ur)), en || Ae.update(en), je = gn, Ae.isReverted = en)
                            }, Ae.refresh = function(Nt, vn, en, gn) {
                                if (!((je || !Ae.enabled) && !vn)) {
                                    if (gt && Nt && rt) {
                                        qn(Pe, "scrollEnd", fu);
                                        return
                                    }!ai && Zn && Zn(Ae), je = Ae, Ei.tween && !en && (Ei.tween.kill(), Ei.tween = 0), yn && yn.pause(), Sr && H && (H.revert({
                                        kill: !1
                                    }).invalidate(), H.getChildren && H.getChildren(!0, !0, !1).forEach(function(W) {
                                        return W.vars.immediateRender && W.render(0, !0, !0)
                                    })), Ae.isReverted || Ae.revert(!0, !0), Ae._subPinOffset = !1;
                                    var Rr = Hi(),
                                        Sn = Vi(),
                                        Dr = dn ? dn.duration() : y(hn, Zt),
                                        yi = kr <= .01 || !kr,
                                        Kn = 0,
                                        Qn = gn || 0,
                                        Nn = ue(en) ? en.end : F.end,
                                        ts = F.endTrigger || tn,
                                        xr = ue(en) ? en.start : F.start || (F.start === 0 || !tn ? 0 : gt ? "0 0" : "0 100%"),
                                        Wi = Ae.pinnedContainer = F.pinnedContainer && tt(F.pinnedContainer, Ae),
                                        ls = tn && Math.max(0, fn.indexOf(Ae)) || 0,
                                        fi = ls,
                                        Xr, ri, so, V, o, l, f, h, _, v, D, N, U;
                                    for (Fr && ue(en) && (N = oe.getProperty(Ye, Zt.p), U = oe.getProperty(ji, Zt.p)); fi-- > 0;) l = fn[fi], l.end || l.refresh(0, 1) || (je = Ae), f = l.pin, f && (f === tn || f === gt || f === Wi) && !l.isReverted && (v || (v = []), v.unshift(l), l.revert(!0, !0)), l !== fn[fi] && (ls--, fi--);
                                    for (B(xr) && (xr = xr(Ae)), xr = ot(xr, "start", Ae), In = il(xr, tn, Rr, Zt, Hr(), Si, Ye, Ae, Sn, Tr, $r, Dr, dn, Ae._startClamp && "_startClamp") || (gt ? -.001 : 0), B(Nn) && (Nn = Nn(Ae)), P(Nn) && !Nn.indexOf("+=") && (~Nn.indexOf(" ") ? Nn = (P(xr) ? xr.split(" ")[0] : "") + Nn : (Kn = zn(Nn.substr(2), Rr), Nn = P(xr) ? xr : (dn ? oe.utils.mapRange(0, dn.duration(), dn.scrollTrigger.start, dn.scrollTrigger.end, In) : In) + Kn, ts = tn)), Nn = ot(Nn, "end", Ae), Pr = Math.max(In, il(Nn || (ts ? "100% 0" : Dr), ts, Rr, Zt, Hr() + Kn, zi, ji, Ae, Sn, Tr, $r, Dr, dn, Ae._endClamp && "_endClamp")) || -.001, Kn = 0, fi = ls; fi--;) l = fn[fi], f = l.pin, f && l.start - l._pinPush <= In && !dn && l.end > 0 && (Xr = l.end - (Ae._startClamp ? Math.max(0, l.start) : l.start), (f === tn && l.start - l._pinPush < In || f === Wi) && isNaN(xr) && (Kn += Xr * (1 - l.progress)), f === gt && (Qn += Xr));
                                    if (In += Kn, Pr += Kn, Ae._startClamp && (Ae._startClamp += Kn), Ae._endClamp && !ai && (Ae._endClamp = Pr || -.001, Pr = Math.min(Pr, y(hn, Zt))), kr = Pr - In || (In -= .01) && .001, yi && (ti = oe.utils.clamp(0, 1, oe.utils.normalize(In, Pr, Yr))), Ae._pinPush = Qn, Si && Kn && (Xr = {}, Xr[Zt.a] = "+=" + Kn, Wi && (Xr[Zt.p] = "-=" + Hr()), oe.set([Si, zi], Xr)), gt && !(Ee && Ae.end >= y(hn, Zt))) Xr = cn(gt), V = Zt === ve, so = Hr(), Mi = parseFloat(Ar(Zt.a)) + Qn, !Dr && Pr > 1 && (D = (sr ? Ke.scrollingElement || M : hn).style, D = {
                                        style: D,
                                        value: D["overflow" + Zt.a.toUpperCase()]
                                    }, sr && cn(I)["overflow" + Zt.a.toUpperCase()] !== "scroll" && (D.style["overflow" + Zt.a.toUpperCase()] = "scroll")), rl(gt, Gr, Xr), eo = Jo(gt), ri = fr(gt, !0), h = $r && lt(hn, V ? le : ve)(), sn ? (ur = [sn + Zt.os2, kr + Qn + rn], ur.t = Gr, fi = sn === Ft ? hr(gt, Zt) + kr + Qn : 0, fi && (ur.push(Zt.d, fi + rn), Gr.style.flexBasis !== "auto" && (Gr.style.flexBasis = fi + rn)), Zs(ur), Wi && fn.forEach(function(W) {
                                        W.pin === Wi && W.vars.pinSpacing !== !1 && (W._subPinOffset = !0)
                                    }), $r && Hr(Yr)) : (fi = hr(gt, Zt), fi && Gr.style.flexBasis !== "auto" && (Gr.style.flexBasis = fi + rn)), $r && (o = {
                                        top: ri.top + (V ? so - In : h) + rn,
                                        left: ri.left + (V ? h : so - In) + rn,
                                        boxSizing: "border-box",
                                        position: "fixed"
                                    }, o[ct] = o["max" + Gt] = Math.ceil(ri.width) + rn, o[dt] = o["max" + jt] = Math.ceil(ri.height) + rn, o[Jt] = o[Jt + Tt] = o[Jt + Bt] = o[Jt + It] = o[Jt + Lt] = "0", o[Ft] = Xr[Ft], o[Ft + Tt] = Xr[Ft + Tt], o[Ft + Bt] = Xr[Ft + Bt], o[Ft + It] = Xr[Ft + It], o[Ft + Lt] = Xr[Ft + Lt], Ir = Lr(jn, o, Zi), ai && Hr(0)), H ? (_ = H._initted, an(1), H.render(H.duration(), !0, !0), Vr = Ar(Zt.a) - Mi + kr + Qn, gs = Math.abs(kr - Vr) > 1, $r && gs && Ir.splice(Ir.length - 2, 2), H.render(0, !0, !0), _ || H.invalidate(!0), H.parent || H.totalTime(H.totalTime()), an(0)) : Vr = kr, D && (D.value ? D.style["overflow" + Zt.a.toUpperCase()] = D.value : D.style.removeProperty("overflow-" + Zt.a));
                                    else if (tn && Hr() && !dn)
                                        for (ri = tn.parentNode; ri && ri !== I;) ri._pinOffset && (In -= ri._pinOffset, Pr -= ri._pinOffset), ri = ri.parentNode;
                                    v && v.forEach(function(W) {
                                        return W.revert(!1, !0)
                                    }), Ae.start = In, Ae.end = Pr, Ci = Oi = ai ? Yr : Hr(), !dn && !ai && (Ci < Yr && Hr(Yr), Ae.scroll.rec = 0), Ae.revert(!1, !0), ds = Ve(), ni && (ci = -1, ni.restart(!0)), je = 0, H && ei && (H._initted || ro) && H.progress() !== ro && H.progress(ro || 0, !0).render(H.time(), !0, !0), (yi || ti !== Ae.progress || dn || Sr || H && !H._initted) && (H && !ei && (H._initted || ti || H.vars.immediateRender !== !1) && H.totalProgress(dn && In < -.001 && !ti ? oe.utils.normalize(In, Pr, 0) : ti, !0), Ae.progress = yi || (Ci - In) / kr === ti ? 0 : ti), gt && sn && (Gr._pinOffset = Math.round(Ae.progress * Vr)), yn && yn.invalidate(), isNaN(N) || (N -= oe.getProperty(Ye, Zt.p), U -= oe.getProperty(ji, Zt.p), Zo(Ye, Zt, N), Zo(Si, Zt, N - (gn || 0)), Zo(ji, Zt, U), Zo(zi, Zt, U - (gn || 0))), yi && !ai && Ae.update(), mn && !ai && !js && (js = !0, mn(Ae), js = !1)
                                }
                            }, Ae.getVelocity = function() {
                                return (Hr() - Oi) / (Ve() - st) * 1e3 || 0
                            }, Ae.endAnimation = function() {
                                be(Ae.callbackAnimation), H && (yn ? yn.progress(1) : H.paused() ? ei || be(H, Ae.direction < 0, 1) : be(H, H.reversed()))
                            }, Ae.labelToScroll = function(Nt) {
                                return H && H.labels && (In || Ae.refresh() || In) + H.labels[Nt] / H.duration() * kr || 0
                            }, Ae.getTrailing = function(Nt) {
                                var vn = fn.indexOf(Ae),
                                    en = Ae.direction > 0 ? fn.slice(0, vn).reverse() : fn.slice(vn + 1);
                                return (P(Nt) ? en.filter(function(gn) {
                                    return gn.vars.preventOverlaps === Nt
                                }) : en).filter(function(gn) {
                                    return Ae.direction > 0 ? gn.end <= In : gn.start >= Pr
                                })
                            }, Ae.update = function(Nt, vn, en) {
                                if (!(dn && !en && !Nt)) {
                                    var gn = ai === !0 ? Yr : Ae.scroll(),
                                        Rr = Nt ? 0 : (gn - In) / kr,
                                        Sn = Rr < 0 ? 0 : Rr > 1 ? 1 : Rr || 0,
                                        Dr = Ae.progress,
                                        yi, Kn, Qn, Nn, ts, xr, Wi, ls;
                                    if (vn && (Oi = Ci, Ci = dn ? Hr() : gn, Dn && (Ui = ks, ks = H && !ei ? H.totalProgress() : Sn)), ir && gt && !je && !qe && rt && (!Sn && In < gn + (gn - Oi) / (Ve() - st) * ir ? Sn = 1e-4 : Sn === 1 && Pr > gn + (gn - Oi) / (Ve() - st) * ir && (Sn = .9999)), Sn !== Dr && Ae.enabled) {
                                        if (yi = Ae.isActive = !!Sn && Sn < 1, Kn = !!Dr && Dr < 1, xr = yi !== Kn, ts = xr || !!Sn != !!Dr, Ae.direction = Sn > Dr ? 1 : -1, Ae.progress = Sn, ts && !je && (Qn = Sn && !Dr ? 0 : Sn === 1 ? 1 : Dr === 1 ? 2 : 3, ei && (Nn = !xr && Fn[Qn + 1] !== "none" && Fn[Qn + 1] || Fn[Qn], ls = H && (Nn === "complete" || Nn === "reset" || Nn in H))), Ri && (xr || ls) && (ls || Tn || !H) && (B(Ri) ? Ri(Ae) : Ae.getTrailing(Ri).forEach(function(so) {
                                                return so.endAnimation()
                                            })), ei || (yn && !je && !qe ? (yn._dp._time - yn._start !== yn._time && yn.render(yn._dp._time - yn._start), yn.resetTo ? yn.resetTo("totalProgress", Sn, H._tTime / H._tDur) : (yn.vars.totalProgress = Sn, yn.invalidate().restart())) : H && H.totalProgress(Sn, !!(je && (ds || Nt)))), gt) {
                                            if (Nt && sn && (Gr.style[sn + Zt.os2] = wo), !$r) es(T(Mi + Vr * Sn));
                                            else if (ts) {
                                                if (Wi = !Nt && Sn > Dr && Pr + 1 > gn && gn + 1 >= y(hn, Zt), Zi)
                                                    if (!Nt && (yi || Wi)) {
                                                        var fi = fr(gt, !0),
                                                            Xr = gn - In;
                                                        du(gt, I, fi.top + (Zt === ve ? Xr : 0) + rn, fi.left + (Zt === ve ? 0 : Xr) + rn)
                                                    } else du(gt, Gr);
                                                Zs(yi || Wi ? Ir : eo), gs && Sn < 1 && yi || es(Mi + (Sn === 1 && !Wi ? Vr : 0))
                                            }
                                        }
                                        Dn && !Ei.tween && !je && !qe && ni.restart(!0), Be && (xr || li && Sn && (Sn < 1 || !Ne)) && Te(Be.targets).forEach(function(so) {
                                            return so.classList[yi || li ? "add" : "remove"](Be.className)
                                        }), Ge && !ei && !Nt && Ge(Ae), ts && !je ? (ei && (ls && (Nn === "complete" ? H.pause().totalProgress(1) : Nn === "reset" ? H.restart(!0).pause() : Nn === "restart" ? H.restart(!0) : H[Nn]()), Ge && Ge(Ae)), (xr || !Ne) && (on && xr && Ce(Ae, on), ui[Qn] && Ce(Ae, ui[Qn]), li && (Sn === 1 ? Ae.kill(!1, 1) : ui[Qn] = 0), xr || (Qn = Sn === 1 ? 1 : 3, ui[Qn] && Ce(Ae, ui[Qn]))), xi && !yi && Math.abs(Ae.getVelocity()) > (q(xi) ? xi : 2500) && (be(Ae.callbackAnimation), yn ? yn.progress(1) : be(H, Nn === "reverse" ? 1 : !Sn, 1))) : ei && Ge && !je && Ge(Ae)
                                    }
                                    if (to) {
                                        var ri = dn ? gn / dn.duration() * (dn._caScrollDist || 0) : gn;
                                        Do(ri + (Ye._isFlipped ? 1 : 0)), to(ri)
                                    }
                                    io && io(-gn / dn.duration() * (dn._caScrollDist || 0))
                                }
                            }, Ae.enable = function(Nt, vn) {
                                Ae.enabled || (Ae.enabled = !0, qn(hn, "resize", $s), sr || qn(hn, "scroll", _n), Zn && qn(Pe, "refreshInit", Zn), Nt !== !1 && (Ae.progress = ti = 0, Ci = Oi = ci = Hr()), vn !== !1 && Ae.refresh())
                            }, Ae.getTween = function(Nt) {
                                return Nt && Ei ? Ei.tween : yn
                            }, Ae.setPositions = function(Nt, vn, en, gn) {
                                if (dn) {
                                    var Rr = dn.scrollTrigger,
                                        Sn = dn.duration(),
                                        Dr = Rr.end - Rr.start;
                                    Nt = Rr.start + Dr * Nt / Sn, vn = Rr.start + Dr * vn / Sn
                                }
                                Ae.refresh(!1, !1, {
                                    start: Mt(Nt, en && !!Ae._startClamp),
                                    end: Mt(vn, en && !!Ae._endClamp)
                                }, gn), Ae.update()
                            }, Ae.adjustPinSpacing = function(Nt) {
                                if (ur && Nt) {
                                    var vn = ur.indexOf(Zt.d) + 1;
                                    ur[vn] = parseFloat(ur[vn]) + Nt + rn, ur[1] = parseFloat(ur[1]) + Nt + rn, Zs(ur)
                                }
                            }, Ae.disable = function(Nt, vn) {
                                if (Ae.enabled && (Nt !== !1 && Ae.revert(!0, !0), Ae.enabled = Ae.isActive = !1, vn || yn && yn.pause(), Yr = 0, lr && (lr.uncache = 1), Zn && Yt(Pe, "refreshInit", Zn), ni && (ni.pause(), Ei.tween && Ei.tween.kill() && (Ei.tween = 0)), !sr)) {
                                    for (var en = fn.length; en--;)
                                        if (fn[en].scroller === hn && fn[en] !== Ae) return;
                                    Yt(hn, "resize", $s), sr || Yt(hn, "scroll", _n)
                                }
                            }, Ae.kill = function(Nt, vn) {
                                Ae.disable(Nt, vn), yn && !vn && yn.kill(), $t && delete Wr[$t];
                                var en = fn.indexOf(Ae);
                                en >= 0 && fn.splice(en, 1), en === Ze && Xo > 0 && Ze--, en = 0, fn.forEach(function(gn) {
                                    return gn.scroller === Ae.scroller && (en = 1)
                                }), en || ai || (Ae.scroll.rec = 0), H && (H.scrollTrigger = null, Nt && H.revert({
                                    kill: !1
                                }), vn || H.kill()), Si && [Si, zi, Ye, ji].forEach(function(gn) {
                                    return gn.parentNode && gn.parentNode.removeChild(gn)
                                }), Ji === Ae && (Ji = 0), gt && (lr && (lr.uncache = 1), en = 0, fn.forEach(function(gn) {
                                    return gn.pin === gt && en++
                                }), en || (lr.spacer = 0)), F.onKill && F.onKill(Ae)
                            }, fn.push(Ae), Ae.enable(!1, !1), As && As(Ae), H && H.add && !kr) {
                            var Hn = Ae.update;
                            Ae.update = function() {
                                Ae.update = Hn, S.cache++, In || Pr || Ae.refresh()
                            }, oe.delayedCall(.01, Ae.update), kr = .01, In = Pr = 0
                        } else Ae.refresh();
                        gt && Yo()
                    }, Pe.register = function(F) {
                        return ze || (oe = F || R(), z() && window.document && Pe.enable(), ze = He), ze
                    }, Pe.defaults = function(F) {
                        if (F)
                            for (var H in F) ar[H] = F[H];
                        return ar
                    }, Pe.disable = function(F, H) {
                        He = 0, fn.forEach(function(Ge) {
                            return Ge[H ? "kill" : "disable"](F)
                        }), Yt(Se, "wheel", _n), Yt(Ke, "scroll", _n), clearInterval(nt), Yt(Ke, "touchcancel", Re), Yt(I, "touchstart", Re), Ln(Yt, Ke, "pointerdown,touchstart,mousedown", pt), Ln(Yt, Ke, "pointerup,touchend,mouseup", Qe), Oe.kill(), x(Yt);
                        for (var we = 0; we < S.length; we += 3) Cr(Yt, S[we], S[we + 1]), Cr(Yt, S[we], S[we + 2])
                    }, Pe.enable = function() {
                        if (Se = window, Ke = document, M = Ke.documentElement, I = Ke.body, oe && (Te = oe.utils.toArray, Ie = oe.utils.clamp, Y = oe.core.context || Re, an = oe.core.suppressOverwrites || Re, ie = Se.history.scrollRestoration || "auto", nl = Se.pageYOffset || 0, oe.core.globals("ScrollTrigger", Pe), I)) {
                            He = 1, ge = document.createElement("div"), ge.style.height = "100vh", ge.style.position = "absolute", Zr(), ut(), ye.register(oe), Pe.isTouch = ye.isTouch, ft = ye.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), An = ye.isTouch === 1, qn(Se, "wheel", _n), fe = [Se, Ke, M, I], oe.matchMedia ? (Pe.matchMedia = function(on) {
                                var mn = oe.matchMedia(),
                                    Tn;
                                for (Tn in on) mn.add(Tn, on[Tn]);
                                return mn
                            }, oe.addEventListener("matchMediaInit", function() {
                                return Cs()
                            }), oe.addEventListener("matchMediaRevert", function() {
                                return Vs()
                            }), oe.addEventListener("matchMedia", function() {
                                Ts(0, 1), Hs("matchMedia")
                            }), oe.matchMedia().add("(orientation: portrait)", function() {
                                return bn(), bn
                            })) : console.warn("Requires GSAP 3.11.0 or later"), bn(), qn(Ke, "scroll", _n);
                            var F = I.hasAttribute("style"),
                                H = I.style,
                                we = H.borderTopStyle,
                                Ge = oe.core.Animation.prototype,
                                Be, $t;
                            for (Ge.revert || Object.defineProperty(Ge, "revert", {
                                    value: function() {
                                        return this.time(-.01, !0)
                                    }
                                }), H.borderTopStyle = "solid", Be = fr(I), ve.m = Math.round(Be.top + ve.sc()) || 0, le.m = Math.round(Be.left + le.sc()) || 0, we ? H.borderTopStyle = we : H.removeProperty("border-top-style"), F || (I.setAttribute("style", ""), I.removeAttribute("style")), nt = setInterval(Es, 250), oe.delayedCall(.5, function() {
                                    return qe = 0
                                }), qn(Ke, "touchcancel", Re), qn(I, "touchstart", Re), Ln(qn, Ke, "pointerdown,touchstart,mousedown", pt), Ln(qn, Ke, "pointerup,touchend,mouseup", Qe), bt = oe.utils.checkPrefix("transform"), wa.push(bt), ze = Ve(), Oe = oe.delayedCall(.2, Ts).pause(), Ot = [Ke, "visibilitychange", function() {
                                    var on = Se.innerWidth,
                                        mn = Se.innerHeight;
                                    Ke.hidden ? (wt = on, Et = mn) : (wt !== on || Et !== mn) && $s()
                                }, Ke, "DOMContentLoaded", Ts, Se, "load", Ts, Se, "resize", $s], x(qn), fn.forEach(function(on) {
                                    return on.enable(0, 1)
                                }), $t = 0; $t < S.length; $t += 3) Cr(Yt, S[$t], S[$t + 1]), Cr(Yt, S[$t], S[$t + 2])
                        }
                    }, Pe.config = function(F) {
                        "limitCallbacks" in F && (Ne = !!F.limitCallbacks);
                        var H = F.syncInterval;
                        H && clearInterval(nt) || (nt = H) && setInterval(Es, H), "ignoreMobileResize" in F && (An = Pe.isTouch === 1 && F.ignoreMobileResize), "autoRefreshEvents" in F && (x(Yt) || x(qn, F.autoRefreshEvents || "none"), Rn = (F.autoRefreshEvents + "").indexOf("resize") === -1)
                    }, Pe.scrollerProxy = function(F, H) {
                        var we = tt(F),
                            Ge = S.indexOf(we),
                            Be = ee(we);
                        ~Ge && S.splice(Ge, Be ? 6 : 2), H && (Be ? X.unshift(Se, H, I, H, M, H) : X.unshift(we, H))
                    }, Pe.clearMatchMedia = function(F) {
                        fn.forEach(function(H) {
                            return H._ctx && H._ctx.query === F && H._ctx.kill(!0, !0)
                        })
                    }, Pe.isInViewport = function(F, H, we) {
                        var Ge = (P(F) ? tt(F) : F).getBoundingClientRect(),
                            Be = Ge[we ? ct : dt] * H || 0;
                        return we ? Ge.right - Be > 0 && Ge.left + Be < Se.innerWidth : Ge.bottom - Be > 0 && Ge.top + Be < Se.innerHeight
                    }, Pe.positionInViewport = function(F, H, we) {
                        P(F) && (F = tt(F));
                        var Ge = F.getBoundingClientRect(),
                            Be = Ge[we ? ct : dt],
                            $t = H == null ? Be / 2 : H in Pi ? Pi[H] * Be : ~H.indexOf("%") ? parseFloat(H) * Be / 100 : parseFloat(H) || 0;
                        return we ? (Ge.left + $t) / Se.innerWidth : (Ge.top + $t) / Se.innerHeight
                    }, Pe.killAll = function(F) {
                        if (fn.slice(0).forEach(function(we) {
                                return we.vars.id !== "ScrollSmoother" && we.kill()
                            }), F !== !0) {
                            var H = Js.killAll || [];
                            Js = {}, H.forEach(function(we) {
                                return we()
                            })
                        }
                    }, Pe
                }();
            Cn.version = "3.13.0", Cn.saveStyles = function(Pe) {
                return Pe ? Te(Pe).forEach(function(C) {
                    if (C && C.style) {
                        var Z = ki.indexOf(C);
                        Z >= 0 && ki.splice(Z, 5), ki.push(C, C.style.cssText, C.getBBox && C.getAttribute("transform"), oe.core.getCache(C), Y())
                    }
                }) : ki
            }, Cn.revert = function(Pe, C) {
                return Cs(!Pe, C)
            }, Cn.create = function(Pe, C) {
                return new Cn(Pe, C)
            }, Cn.refresh = function(Pe) {
                return Pe ? $s(!0) : (ze || Cn.register()) && Ts(!0)
            }, Cn.update = function(Pe) {
                return ++S.cache && os(Pe === !0 ? 2 : 0)
            }, Cn.clearScrollMemory = el, Cn.maxScroll = function(Pe, C) {
                return y(Pe, C ? le : ve)
            }, Cn.getScrollFunc = function(Pe, C) {
                return lt(tt(Pe), C ? le : ve)
            }, Cn.getById = function(Pe) {
                return Wr[Pe]
            }, Cn.getAll = function() {
                return fn.filter(function(Pe) {
                    return Pe.vars.id !== "ScrollSmoother"
                })
            }, Cn.isScrolling = function() {
                return !!rt
            }, Cn.snapDirectional = rr, Cn.addEventListener = function(Pe, C) {
                var Z = Js[Pe] || (Js[Pe] = []);
                ~Z.indexOf(C) || Z.push(C)
            }, Cn.removeEventListener = function(Pe, C) {
                var Z = Js[Pe],
                    F = Z && Z.indexOf(C);
                F >= 0 && Z.splice(F, 1)
            }, Cn.batch = function(Pe, C) {
                var Z = [],
                    F = {},
                    H = C.interval || .016,
                    we = C.batchMax || 1e9,
                    Ge = function(on, mn) {
                        var Tn = [],
                            tn = [],
                            gt = oe.delayedCall(H, function() {
                                mn(Tn, tn), Tn = [], tn = []
                            }).pause();
                        return function(sn) {
                            Tn.length || gt.restart(!0), Tn.push(sn.trigger), tn.push(sn), we <= Tn.length && gt.progress(1)
                        }
                    },
                    Be;
                for (Be in C) F[Be] = Be.substr(0, 2) === "on" && B(C[Be]) && Be !== "onRefreshInit" ? Ge(Be, C[Be]) : C[Be];
                return B(we) && (we = we(), qn(Cn, "refresh", function() {
                    return we = C.batchMax()
                })), Te(Pe).forEach(function($t) {
                    var on = {};
                    for (Be in F) on[Be] = F[Be];
                    on.trigger = $t, Z.push(Cn.create(on))
                }), Z
            };
            var xa = function(C, Z, F, H) {
                    return Z > H ? C(H) : Z < 0 && C(0), F > H ? (H - Z) / (F - Z) : F < 0 ? Z / (Z - F) : 1
                },
                sl = function Pe(C, Z) {
                    Z === !0 ? C.style.removeProperty("touch-action") : C.style.touchAction = Z === !0 ? "auto" : Z ? "pan-" + Z + (ye.isTouch ? " pinch-zoom" : "") : "none", C === M && Pe(I, Z)
                },
                Ea = {
                    auto: 1,
                    scroll: 1
                },
                Uc = function(C) {
                    var Z = C.event,
                        F = C.target,
                        H = C.axis,
                        we = (Z.changedTouches ? Z.changedTouches[0] : Z).target,
                        Ge = we._gsap || oe.core.getCache(we),
                        Be = Ve(),
                        $t;
                    if (!Ge._isScrollT || Be - Ge._isScrollT > 2e3) {
                        for (; we && we !== I && (we.scrollHeight <= we.clientHeight && we.scrollWidth <= we.clientWidth || !(Ea[($t = cn(we)).overflowY] || Ea[$t.overflowX]));) we = we.parentNode;
                        Ge._isScroll = we && we !== F && !ee(we) && (Ea[($t = cn(we)).overflowY] || Ea[$t.overflowX]), Ge._isScrollT = Be
                    }(Ge._isScroll || H === "x") && (Z.stopPropagation(), Z._gsapAllow = !0)
                },
                ol = function(C, Z, F, H) {
                    return ye.create({
                        target: C,
                        capture: !0,
                        debounce: !1,
                        lockAxis: !0,
                        type: Z,
                        onWheel: H = H && Uc,
                        onPress: H,
                        onDrag: H,
                        onScroll: H,
                        onEnable: function() {
                            return F && qn(Ke, ye.eventTypes[0], ea, !1, !0)
                        },
                        onDisable: function() {
                            return Yt(Ke, ye.eventTypes[0], ea, !0)
                        }
                    })
                },
                Ai = /(input|label|select|textarea)/i,
                zs, ea = function(C) {
                    var Z = Ai.test(C.target.tagName);
                    (Z || zs) && (C._gsapAllow = !0, zs = Z)
                },
                Wc = function(C) {
                    ue(C) || (C = {}), C.preventDefault = C.isNormalizer = C.allowClicks = !0, C.type || (C.type = "wheel,touch"), C.debounce = !!C.debounce, C.id = C.id || "normalizer";
                    var Z = C,
                        F = Z.normalizeScrollX,
                        H = Z.momentum,
                        we = Z.allowNestedScroll,
                        Ge = Z.onRelease,
                        Be, $t, on = tt(C.target) || M,
                        mn = oe.core.globals().ScrollSmoother,
                        Tn = mn && mn.get(),
                        tn = ft && (C.content && tt(C.content) || Tn && C.content !== !1 && !Tn.smooth() && Tn.content()),
                        gt = lt(on, ve),
                        sn = lt(on, le),
                        Sr = 1,
                        ir = (ye.isTouch && Se.visualViewport ? Se.visualViewport.scale * Se.visualViewport.width : Se.outerWidth) / Se.innerWidth,
                        qr = 0,
                        wr = B(H) ? function() {
                            return H(Be)
                        } : function() {
                            return H || 2.8
                        },
                        li, Dn, Zi = ol(on, C.type, !0, we),
                        dr = function() {
                            return Dn = !1
                        },
                        dn = Re,
                        xi = Re,
                        Ri = function() {
                            $t = y(on, ve), xi = Ie(ft ? 1 : 0, $t), F && (dn = Ie(0, y(on, le))), li = Ss
                        },
                        Zt = function() {
                            tn._gsap.y = T(parseFloat(tn._gsap.y) + gt.offset) + "px", tn.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(tn._gsap.y) + ", 0, 1)", gt.offset = gt.cacheID = 0
                        },
                        ei = function() {
                            if (Dn) {
                                requestAnimationFrame(dr);
                                var Fr = T(Be.deltaY / 2),
                                    Tr = xi(gt.v - Fr);
                                if (tn && Tr !== gt.v + gt.offset) {
                                    gt.offset = Tr - gt.v;
                                    var Ae = T((parseFloat(tn && tn._gsap.y) || 0) - gt.offset);
                                    tn.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + Ae + ", 0, 1)", tn._gsap.y = Ae + "px", gt.cacheID = S.cache, os()
                                }
                                return !0
                            }
                            gt.offset && Zt(), Dn = !0
                        },
                        hn, hs, sr, $r, ui = function() {
                            Ri(), hn.isActive() && hn.vars.scrollY > $t && (gt() > $t ? hn.progress(1) && gt($t) : hn.resetTo("scrollY", $t))
                        };
                    return tn && oe.set(tn, {
                        y: "+=0"
                    }), C.ignoreCheck = function(Fn) {
                        return ft && Fn.type === "touchmove" && ei() || Sr > 1.05 && Fn.type !== "touchstart" || Be.isGesturing || Fn.touches && Fn.touches.length > 1
                    }, C.onPress = function() {
                        Dn = !1;
                        var Fn = Sr;
                        Sr = T((Se.visualViewport && Se.visualViewport.scale || 1) / ir), hn.pause(), Fn !== Sr && sl(on, Sr > 1.01 ? !0 : F ? !1 : "x"), hs = sn(), sr = gt(), Ri(), li = Ss
                    }, C.onRelease = C.onGestureStart = function(Fn, Fr) {
                        if (gt.offset && Zt(), !Fr) $r.restart(!0);
                        else {
                            S.cache++;
                            var Tr = wr(),
                                Ae, Zn;
                            F && (Ae = sn(), Zn = Ae + Tr * .05 * -Fn.velocityX / .227, Tr *= xa(sn, Ae, Zn, y(on, le)), hn.vars.scrollX = dn(Zn)), Ae = gt(), Zn = Ae + Tr * .05 * -Fn.velocityY / .227, Tr *= xa(gt, Ae, Zn, y(on, ve)), hn.vars.scrollY = xi(Zn), hn.invalidate().duration(Tr).play(.01), (ft && hn.vars.scrollY >= $t || Ae >= $t - 1) && oe.to({}, {
                                onUpdate: ui,
                                duration: Tr
                            })
                        }
                        Ge && Ge(Fn)
                    }, C.onWheel = function() {
                        hn._ts && hn.pause(), Ve() - qr > 1e3 && (li = 0, qr = Ve())
                    }, C.onChange = function(Fn, Fr, Tr, Ae, Zn) {
                        if (Ss !== li && Ri(), Fr && F && sn(dn(Ae[2] === Fr ? hs + (Fn.startX - Fn.x) : sn() + Fr - Ae[1])), Tr) {
                            gt.offset && Zt();
                            var Hi = Zn[2] === Tr,
                                Vi = Hi ? sr + Fn.startY - Fn.y : gt() + Tr - Zn[1],
                                ci = xi(Vi);
                            Hi && Vi !== ci && (sr += ci - Vi), gt(ci)
                        }(Tr || Fr) && os()
                    }, C.onEnable = function() {
                        sl(on, F ? !1 : "x"), Cn.addEventListener("refresh", ui), qn(Se, "resize", ui), gt.smooth && (gt.target.style.scrollBehavior = "auto", gt.smooth = sn.smooth = !1), Zi.enable()
                    }, C.onDisable = function() {
                        sl(on, !0), Yt(Se, "resize", ui), Cn.removeEventListener("refresh", ui), Zi.kill()
                    }, C.lockAxis = C.lockAxis !== !1, Be = new ye(C), Be.iOS = ft, ft && !gt() && gt(1), ft && oe.ticker.add(Re), $r = Be._dc, hn = oe.to(Be, {
                        ease: "power4",
                        paused: !0,
                        inherit: !1,
                        scrollX: F ? "+=0.1" : "+=0",
                        scrollY: "+=0.1",
                        modifiers: {
                            scrollY: Da(gt, gt(), function() {
                                return hn.pause()
                            })
                        },
                        onUpdate: os,
                        onComplete: $r.vars.onComplete
                    }), Be
                };
            Cn.sort = function(Pe) {
                if (B(Pe)) return fn.sort(Pe);
                var C = Se.pageYOffset || 0;
                return Cn.getAll().forEach(function(Z) {
                    return Z._sortY = Z.trigger ? C + Z.trigger.getBoundingClientRect().top : Z.start + Se.innerHeight
                }), fn.sort(Pe || function(Z, F) {
                    return (Z.vars.refreshPriority || 0) * -1e6 + (Z.vars.containerAnimation ? 1e6 : Z._sortY) - ((F.vars.containerAnimation ? 1e6 : F._sortY) + (F.vars.refreshPriority || 0) * -1e6)
                })
            }, Cn.observe = function(Pe) {
                return new ye(Pe)
            }, Cn.normalizeScroll = function(Pe) {
                if (typeof Pe > "u") return un;
                if (Pe === !0 && un) return un.enable();
                if (Pe === !1) {
                    un && un.kill(), un = Pe;
                    return
                }
                var C = Pe instanceof ye ? Pe : Wc(Pe);
                return un && un.target === C.target && un.kill(), ee(C.target) && (un = C), C
            }, Cn.core = {
                _getVelocityProp: _t,
                _inputObserver: ol,
                _scrollers: S,
                _proxies: X,
                bridge: {
                    ss: function() {
                        rt || Hs("scrollStart"), rt = Ve()
                    },
                    ref: function() {
                        return je
                    }
                }
            }, R() && oe.registerPlugin(Cn), n.ScrollTrigger = Cn, n.default = Cn, typeof window > "u" || window !== n ? Object.defineProperty(n, "__esModule", {
                value: !0
            }) : delete window.default
        })
    }(vl, vl.exports)), vl.exports
}
var KC = XC();
const da = Go(KC);
var bl = {
        exports: {}
    },
    QC = bl.exports,
    Bp;

function JC() {
    return Bp || (Bp = 1, function(e, t) {
        (function(n, r) {
            r(t)
        })(QC, function(n) {
            var r = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
                i = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
                s = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
                a = /(^[#\.][a-z]|[a-y][a-z])/i,
                c = Math.PI / 180,
                u = 180 / Math.PI,
                p = Math.sin,
                d = Math.cos,
                g = Math.abs,
                m = Math.sqrt,
                E = Math.atan2,
                L = 1e8,
                b = function(y) {
                    return typeof y == "string"
                },
                j = function(y) {
                    return typeof y == "number"
                },
                A = function(y) {
                    return typeof y > "u"
                },
                $ = {},
                w = {},
                k = 1e5,
                S = function(y) {
                    return Math.round((y + L) % 1 * k) / k || (y < 0 ? 0 : 1)
                },
                X = function(y) {
                    return Math.round(y * k) / k || 0
                },
                J = function(y) {
                    return Math.round(y * 1e10) / 1e10 || 0
                },
                xe = function(y, x, P, B) {
                    var q = y[x],
                        ue = B === 1 ? 6 : mt(q, P, B);
                    if ((ue || !B) && ue + P + 2 < q.length) return y.splice(x, 0, q.slice(0, P + ue + 2)), q.splice(0, P + ue), 1
                },
                he = function(y, x, P) {
                    var B = y.length,
                        q = ~~(P * B);
                    if (y[q] > x) {
                        for (; --q && y[q] > x;);
                        q < 0 && (q = 0)
                    } else
                        for (; y[++q] < x && q < B;);
                    return q < B ? q : B - 1
                },
                me = function(y, x) {
                    var P = y.length;
                    for (y.reverse(); P--;) y[P].reversed || te(y[P])
                },
                Q = function(y, x) {
                    return x.totalLength = y.totalLength, y.samples ? (x.samples = y.samples.slice(0), x.lookup = y.lookup.slice(0), x.minLength = y.minLength, x.resolution = y.resolution) : y.totalPoints && (x.totalPoints = y.totalPoints), x
                },
                ne = function(y, x) {
                    var P = y.length,
                        B = y[P - 1] || [],
                        q = B.length;
                    P && x[0] === B[q - 2] && x[1] === B[q - 1] && (x = B.concat(x.slice(2)), P--), y[P] = x
                };

            function re(O) {
                O = b(O) && a.test(O) && document.querySelector(O) || O;
                var y = O.getAttribute ? O : 0,
                    x;
                return y && (O = O.getAttribute("d")) ? (y._gsPath || (y._gsPath = {}), x = y._gsPath[O], x && !x._dirty ? x : y._gsPath[O] = oe(O)) : O ? b(O) ? oe(O) : j(O[0]) ? [O] : O : console.warn("Expecting a <path> element or an SVG path data string")
            }

            function K(O) {
                for (var y = [], x = 0; x < O.length; x++) y[x] = Q(O[x], O[x].slice(0));
                return Q(O, y)
            }

            function te(O) {
                var y = 0,
                    x;
                for (O.reverse(); y < O.length; y += 2) x = O[y], O[y] = O[y + 1], O[y + 1] = x;
                O.reversed = !O.reversed
            }
            var G = function(y, x) {
                    var P = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                        B = [].slice.call(y.attributes),
                        q = B.length,
                        ue;
                    for (x = "," + x + ","; --q > -1;) ue = B[q].nodeName.toLowerCase(), x.indexOf("," + ue + ",") < 0 && P.setAttributeNS(null, ue, B[q].nodeValue);
                    return P
                },
                ce = {
                    rect: "rx,ry,x,y,width,height",
                    circle: "r,cx,cy",
                    ellipse: "rx,ry,cx,cy",
                    line: "x1,x2,y1,y2"
                },
                le = function(y, x) {
                    for (var P = x ? x.split(",") : [], B = {}, q = P.length; --q > -1;) B[P[q]] = +y.getAttribute(P[q]) || 0;
                    return B
                };

            function ve(O, y) {
                var x = O.tagName.toLowerCase(),
                    P = .552284749831,
                    B, q, ue, be, Ce, se, Ue, _e, Xe, Je, ct, dt, Bt, Lt, Tt, It, Ft, Jt, Gt, jt, rn, cn;
                return x === "path" || !O.getBBox ? O : (se = G(O, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), cn = le(O, ce[x]), x === "rect" ? (be = cn.rx, Ce = cn.ry || be, q = cn.x, ue = cn.y, Je = cn.width - be * 2, ct = cn.height - Ce * 2, be || Ce ? (dt = q + be * (1 - P), Bt = q + be, Lt = Bt + Je, Tt = Lt + be * P, It = Lt + be, Ft = ue + Ce * (1 - P), Jt = ue + Ce, Gt = Jt + ct, jt = Gt + Ce * P, rn = Gt + Ce, B = "M" + It + "," + Jt + " V" + Gt + " C" + [It, jt, Tt, rn, Lt, rn, Lt - (Lt - Bt) / 3, rn, Bt + (Lt - Bt) / 3, rn, Bt, rn, dt, rn, q, jt, q, Gt, q, Gt - (Gt - Jt) / 3, q, Jt + (Gt - Jt) / 3, q, Jt, q, Ft, dt, ue, Bt, ue, Bt + (Lt - Bt) / 3, ue, Lt - (Lt - Bt) / 3, ue, Lt, ue, Tt, ue, It, Ft, It, Jt].join(",") + "z") : B = "M" + (q + Je) + "," + ue + " v" + ct + " h" + -Je + " v" + -ct + " h" + Je + "z") : x === "circle" || x === "ellipse" ? (x === "circle" ? (be = Ce = cn.r, _e = be * P) : (be = cn.rx, Ce = cn.ry, _e = Ce * P), q = cn.cx, ue = cn.cy, Ue = be * P, B = "M" + (q + be) + "," + ue + " C" + [q + be, ue + _e, q + Ue, ue + Ce, q, ue + Ce, q - Ue, ue + Ce, q - be, ue + _e, q - be, ue, q - be, ue - _e, q - Ue, ue - Ce, q, ue - Ce, q + Ue, ue - Ce, q + be, ue - _e, q + be, ue].join(",") + "z") : x === "line" ? B = "M" + cn.x1 + "," + cn.y1 + " L" + cn.x2 + "," + cn.y2 : (x === "polyline" || x === "polygon") && (Xe = (O.getAttribute("points") + "").match(i) || [], q = Xe.shift(), ue = Xe.shift(), B = "M" + q + "," + ue + " L" + Xe.join(","), x === "polygon" && (B += "," + q + "," + ue + "z")), se.setAttribute("d", Ke(se._gsRawPath = oe(B))), y && O.parentNode && (O.parentNode.insertBefore(se, O), O.parentNode.removeChild(O)), se)
            }

            function tt(O, y, x) {
                var P = O[y],
                    B = O[y + 2],
                    q = O[y + 4],
                    ue;
                return P += (B - P) * x, B += (q - B) * x, P += (B - P) * x, ue = B + (q + (O[y + 6] - q) * x - B) * x - P, P = O[y + 1], B = O[y + 3], q = O[y + 5], P += (B - P) * x, B += (q - B) * x, P += (B - P) * x, X(E(B + (q + (O[y + 7] - q) * x - B) * x - P, ue) * u)
            }

            function ht(O, y, x) {
                x = A(x) ? 1 : J(x) || 0, y = J(y) || 0;
                var P = Math.max(0, ~~(g(x - y) - 1e-8)),
                    B = K(O);
                if (y > x && (y = 1 - y, x = 1 - x, me(B), B.totalLength = 0), y < 0 || x < 0) {
                    var q = Math.abs(~~Math.min(y, x)) + 1;
                    y += q, x += q
                }
                B.totalLength || _t(B);
                var ue = x > 1,
                    be = Pt(B, y, $, !0),
                    Ce = Pt(B, x, w),
                    se = Ce.segment,
                    Ue = be.segment,
                    _e = Ce.segIndex,
                    Xe = be.segIndex,
                    Je = Ce.i,
                    ct = be.i,
                    dt = Xe === _e,
                    Bt = Je === ct && dt,
                    Lt, Tt, It, Ft, Jt, Gt, jt, rn;
                if (ue || P) {
                    for (Lt = _e < Xe || dt && Je < ct || Bt && Ce.t < be.t, xe(B, Xe, ct, be.t) && (Xe++, Lt || (_e++, Bt ? (Ce.t = (Ce.t - be.t) / (1 - be.t), Je = 0) : dt && (Je -= ct))), Math.abs(1 - (x - y)) < 1e-5 ? _e = Xe - 1 : !Ce.t && _e ? _e-- : xe(B, _e, Je, Ce.t) && Lt && Xe++, be.t === 1 && (Xe = (Xe + 1) % B.length), Jt = [], Gt = B.length, jt = 1 + Gt * P, rn = Xe, jt += (Gt - Xe + _e) % Gt, Ft = 0; Ft < jt; Ft++) ne(Jt, B[rn++ % Gt]);
                    B = Jt
                } else if (It = Ce.t === 1 ? 6 : mt(se, Je, Ce.t), y !== x)
                    for (Tt = mt(Ue, ct, Bt ? be.t / Ce.t : be.t), dt && (It += Tt), se.splice(Je + It + 2), (Tt || ct) && Ue.splice(0, ct + Tt), Ft = B.length; Ft--;)(Ft < Xe || Ft > _e) && B.splice(Ft, 1);
                else se.angle = tt(se, Je + It, 0), Je += It, be = se[Je], Ce = se[Je + 1], se.length = se.totalLength = 0, se.totalPoints = B.totalPoints = 8, se.push(be, Ce, be, Ce, be, Ce, be, Ce);
                return B.totalLength = 0, B
            }

            function lt(O, y, x) {
                y = y || 0, O.samples || (O.samples = [], O.lookup = []);
                var P = ~~O.resolution || 12,
                    B = 1 / P,
                    q = O.length,
                    ue = O[y],
                    be = O[y + 1],
                    Ce = y ? y / 6 * P : 0,
                    se = O.samples,
                    Ue = O.lookup,
                    _e = (y ? O.minLength : L) || L,
                    Xe = se[Ce + x * P - 1],
                    Je = y ? se[Ce - 1] : 0,
                    ct, dt, Bt, Lt, Tt, It, Ft, Jt, Gt, jt, rn, cn, Mr, tr, fr, hr, br;
                for (se.length = Ue.length = 0, dt = y + 2; dt < q; dt += 6) {
                    if (Bt = O[dt + 4] - ue, Lt = O[dt + 2] - ue, Tt = O[dt] - ue, Jt = O[dt + 5] - be, Gt = O[dt + 3] - be, jt = O[dt + 1] - be, It = Ft = rn = cn = 0, g(Bt) < .01 && g(Jt) < .01 && g(Tt) + g(jt) < .01) O.length > 8 && (O.splice(dt, 6), dt -= 6, q -= 6);
                    else
                        for (ct = 1; ct <= P; ct++) tr = B * ct, Mr = 1 - tr, It = Ft - (Ft = (tr * tr * Bt + 3 * Mr * (tr * Lt + Mr * Tt)) * tr), rn = cn - (cn = (tr * tr * Jt + 3 * Mr * (tr * Gt + Mr * jt)) * tr), hr = m(rn * rn + It * It), hr < _e && (_e = hr), Je += hr, se[Ce++] = Je;
                    ue += Bt, be += Jt
                }
                if (Xe)
                    for (Xe -= Je; Ce < se.length; Ce++) se[Ce] += Xe;
                if (se.length && _e) {
                    if (O.totalLength = br = se[se.length - 1] || 0, O.minLength = _e, br / _e < 9999)
                        for (hr = fr = 0, ct = 0; ct < br; ct += _e) Ue[hr++] = se[fr] < ct ? ++fr : fr
                } else O.totalLength = se[0] = 0;
                return y ? Je - se[y / 2 - 1] : Je
            }

            function _t(O, y) {
                var x, P, B;
                for (B = x = P = 0; B < O.length; B++) O[B].resolution = ~~y || 12, P += O[B].length, x += lt(O[B]);
                return O.totalPoints = P, O.totalLength = x, O
            }

            function mt(O, y, x) {
                if (x <= 0 || x >= 1) return 0;
                var P = O[y],
                    B = O[y + 1],
                    q = O[y + 2],
                    ue = O[y + 3],
                    be = O[y + 4],
                    Ce = O[y + 5],
                    se = O[y + 6],
                    Ue = O[y + 7],
                    _e = P + (q - P) * x,
                    Xe = q + (be - q) * x,
                    Je = B + (ue - B) * x,
                    ct = ue + (Ce - ue) * x,
                    dt = _e + (Xe - _e) * x,
                    Bt = Je + (ct - Je) * x,
                    Lt = be + (se - be) * x,
                    Tt = Ce + (Ue - Ce) * x;
                return Xe += (Lt - Xe) * x, ct += (Tt - ct) * x, O.splice(y + 2, 4, X(_e), X(Je), X(dt), X(Bt), X(dt + (Xe - dt) * x), X(Bt + (ct - Bt) * x), X(Xe), X(ct), X(Lt), X(Tt)), O.samples && O.samples.splice(y / 6 * O.resolution | 0, 0, 0, 0, 0, 0, 0, 0), 6
            }

            function Pt(O, y, x, P) {
                x = x || {}, O.totalLength || _t(O), (y < 0 || y > 1) && (y = S(y));
                var B = 0,
                    q = O[0],
                    ue, be, Ce, se, Ue, _e, Xe;
                if (!y) Xe = _e = B = 0, q = O[0];
                else if (y === 1) Xe = 1, B = O.length - 1, q = O[B], _e = q.length - 8;
                else {
                    if (O.length > 1) {
                        for (Ce = O.totalLength * y, Ue = _e = 0;
                            (Ue += O[_e++].totalLength) < Ce;) B = _e;
                        q = O[B], se = Ue - q.totalLength, y = (Ce - se) / (Ue - se) || 0
                    }
                    ue = q.samples, be = q.resolution, Ce = q.totalLength * y, _e = q.lookup.length ? q.lookup[~~(Ce / q.minLength)] || 0 : he(ue, Ce, y), se = _e ? ue[_e - 1] : 0, Ue = ue[_e], Ue < Ce && (se = Ue, Ue = ue[++_e]), Xe = 1 / be * ((Ce - se) / (Ue - se) + _e % be), _e = ~~(_e / be) * 6, P && Xe === 1 && (_e + 6 < q.length ? (_e += 6, Xe = 0) : B + 1 < O.length && (_e = Xe = 0, q = O[++B]))
                }
                return x.t = Xe, x.i = _e, x.path = O, x.segment = q, x.segIndex = B, x
            }

            function St(O, y, x, P) {
                var B = O[0],
                    q = P || {},
                    ue, be, Ce, se, Ue, _e, Xe, Je, ct;
                if ((y < 0 || y > 1) && (y = S(y)), B.lookup || _t(O), O.length > 1) {
                    for (Ce = O.totalLength * y, Ue = _e = 0;
                        (Ue += O[_e++].totalLength) < Ce;) B = O[_e];
                    se = Ue - B.totalLength, y = (Ce - se) / (Ue - se) || 0
                }
                return ue = B.samples, be = B.resolution, Ce = B.totalLength * y, _e = B.lookup.length ? B.lookup[y < 1 ? ~~(Ce / B.minLength) : B.lookup.length - 1] || 0 : he(ue, Ce, y), se = _e ? ue[_e - 1] : 0, Ue = ue[_e], Ue < Ce && (se = Ue, Ue = ue[++_e]), Xe = 1 / be * ((Ce - se) / (Ue - se) + _e % be) || 0, ct = 1 - Xe, _e = ~~(_e / be) * 6, Je = B[_e], q.x = X((Xe * Xe * (B[_e + 6] - Je) + 3 * ct * (Xe * (B[_e + 4] - Je) + ct * (B[_e + 2] - Je))) * Xe + Je), q.y = X((Xe * Xe * (B[_e + 7] - (Je = B[_e + 1])) + 3 * ct * (Xe * (B[_e + 5] - Je) + ct * (B[_e + 3] - Je))) * Xe + Je), x && (q.angle = B.totalLength ? tt(B, _e, Xe >= 1 ? 1 - 1e-9 : Xe || 1e-9) : B.angle || 0), q
            }

            function de(O, y, x, P, B, q, ue) {
                for (var be = O.length, Ce, se, Ue, _e, Xe; --be > -1;)
                    for (Ce = O[be], se = Ce.length, Ue = 0; Ue < se; Ue += 2) _e = Ce[Ue], Xe = Ce[Ue + 1], Ce[Ue] = _e * y + Xe * P + q, Ce[Ue + 1] = _e * x + Xe * B + ue;
                return O._dirty = 1, O
            }

            function ye(O, y, x, P, B, q, ue, be, Ce) {
                if (!(O === be && y === Ce)) {
                    x = g(x), P = g(P);
                    var se = B % 360 * c,
                        Ue = d(se),
                        _e = p(se),
                        Xe = Math.PI,
                        Je = Xe * 2,
                        ct = (O - be) / 2,
                        dt = (y - Ce) / 2,
                        Bt = Ue * ct + _e * dt,
                        Lt = -_e * ct + Ue * dt,
                        Tt = Bt * Bt,
                        It = Lt * Lt,
                        Ft = Tt / (x * x) + It / (P * P);
                    Ft > 1 && (x = m(Ft) * x, P = m(Ft) * P);
                    var Jt = x * x,
                        Gt = P * P,
                        jt = (Jt * Gt - Jt * It - Gt * Tt) / (Jt * It + Gt * Tt);
                    jt < 0 && (jt = 0);
                    var rn = (q === ue ? -1 : 1) * m(jt),
                        cn = rn * (x * Lt / P),
                        Mr = rn * -(P * Bt / x),
                        tr = (O + be) / 2,
                        fr = (y + Ce) / 2,
                        hr = tr + (Ue * cn - _e * Mr),
                        br = fr + (_e * cn + Ue * Mr),
                        nr = (Bt - cn) / x,
                        rr = (Lt - Mr) / P,
                        Vn = (-Bt - cn) / x,
                        Ln = (-Lt - Mr) / P,
                        qn = nr * nr + rr * rr,
                        Yt = (rr < 0 ? -1 : 1) * Math.acos(nr / m(qn)),
                        Cr = (nr * Ln - rr * Vn < 0 ? -1 : 1) * Math.acos((nr * Vn + rr * Ln) / m(qn * (Vn * Vn + Ln * Ln)));
                    isNaN(Cr) && (Cr = Xe), !ue && Cr > 0 ? Cr -= Je : ue && Cr < 0 && (Cr += Je), Yt %= Je, Cr %= Je;
                    var oi = Math.ceil(g(Cr) / (Je / 4)),
                        ar = [],
                        Pi = Cr / oi,
                        zn = 4 / 3 * p(Pi / 2) / (1 + d(Pi / 2)),
                        Gn = Ue * x,
                        xs = _e * x,
                        fn = _e * -P,
                        Wr = Ue * P,
                        En;
                    for (En = 0; En < oi; En++) B = Yt + En * Pi, Bt = d(B), Lt = p(B), nr = d(B += Pi), rr = p(B), ar.push(Bt - zn * Lt, Lt + zn * Bt, nr + zn * rr, rr - zn * nr, nr, rr);
                    for (En = 0; En < ar.length; En += 2) Bt = ar[En], Lt = ar[En + 1], ar[En] = Bt * Gn + Lt * fn + hr, ar[En + 1] = Bt * xs + Lt * Wr + br;
                    return ar[En - 2] = be, ar[En - 1] = Ce, ar
                }
            }

            function oe(O) {
                var y = (O + "").replace(s, function(cn) {
                        var Mr = +cn;
                        return Mr < 1e-4 && Mr > -1e-4 ? 0 : Mr
                    }).match(r) || [],
                    x = [],
                    P = 0,
                    B = 0,
                    q = 2 / 3,
                    ue = y.length,
                    be = 0,
                    Ce = "ERROR: malformed path: " + O,
                    se, Ue, _e, Xe, Je, ct, dt, Bt, Lt, Tt, It, Ft, Jt, Gt, jt, rn = function(Mr, tr, fr, hr) {
                        Tt = (fr - Mr) / 3, It = (hr - tr) / 3, dt.push(Mr + Tt, tr + It, fr - Tt, hr - It, fr, hr)
                    };
                if (!O || !isNaN(y[0]) || isNaN(y[1])) return console.log(Ce), x;
                for (se = 0; se < ue; se++)
                    if (Jt = Je, isNaN(y[se]) ? (Je = y[se].toUpperCase(), ct = Je !== y[se]) : se--, _e = +y[se + 1], Xe = +y[se + 2], ct && (_e += P, Xe += B), se || (Bt = _e, Lt = Xe), Je === "M") dt && (dt.length < 8 ? x.length -= 1 : be += dt.length), P = Bt = _e, B = Lt = Xe, dt = [_e, Xe], x.push(dt), se += 2, Je = "L";
                    else if (Je === "C") dt || (dt = [0, 0]), ct || (P = B = 0), dt.push(_e, Xe, P + y[se + 3] * 1, B + y[se + 4] * 1, P += y[se + 5] * 1, B += y[se + 6] * 1), se += 6;
                else if (Je === "S") Tt = P, It = B, (Jt === "C" || Jt === "S") && (Tt += P - dt[dt.length - 4], It += B - dt[dt.length - 3]), ct || (P = B = 0), dt.push(Tt, It, _e, Xe, P += y[se + 3] * 1, B += y[se + 4] * 1), se += 4;
                else if (Je === "Q") Tt = P + (_e - P) * q, It = B + (Xe - B) * q, ct || (P = B = 0), P += y[se + 3] * 1, B += y[se + 4] * 1, dt.push(Tt, It, P + (_e - P) * q, B + (Xe - B) * q, P, B), se += 4;
                else if (Je === "T") Tt = P - dt[dt.length - 4], It = B - dt[dt.length - 3], dt.push(P + Tt, B + It, _e + (P + Tt * 1.5 - _e) * q, Xe + (B + It * 1.5 - Xe) * q, P = _e, B = Xe), se += 2;
                else if (Je === "H") rn(P, B, P = _e, B), se += 1;
                else if (Je === "V") rn(P, B, P, B = _e + (ct ? B - P : 0)), se += 1;
                else if (Je === "L" || Je === "Z") Je === "Z" && (_e = Bt, Xe = Lt, dt.closed = !0), (Je === "L" || g(P - _e) > .5 || g(B - Xe) > .5) && (rn(P, B, _e, Xe), Je === "L" && (se += 2)), P = _e, B = Xe;
                else if (Je === "A") {
                    if (Gt = y[se + 4], jt = y[se + 5], Tt = y[se + 6], It = y[se + 7], Ue = 7, Gt.length > 1 && (Gt.length < 3 ? (It = Tt, Tt = jt, Ue--) : (It = jt, Tt = Gt.substr(2), Ue -= 2), jt = Gt.charAt(1), Gt = Gt.charAt(0)), Ft = ye(P, B, +y[se + 1], +y[se + 2], +y[se + 3], +Gt, +jt, (ct ? P : 0) + Tt * 1, (ct ? B : 0) + It * 1), se += Ue, Ft)
                        for (Ue = 0; Ue < Ft.length; Ue++) dt.push(Ft[Ue]);
                    P = dt[dt.length - 2], B = dt[dt.length - 1]
                } else console.log(Ce);
                return se = dt.length, se < 6 ? (x.pop(), se = 0) : dt[0] === dt[se - 2] && dt[1] === dt[se - 1] && (dt.closed = !0), x.totalPoints = be + se, x
            }

            function ze(O, y) {
                y === void 0 && (y = 1);
                for (var x = O[0], P = 0, B = [x, P], q = 2; q < O.length; q += 2) B.push(x, P, O[q], P = (O[q] - x) * y / 2, x = O[q], -P);
                return B
            }

            function Se(O, y) {
                g(O[0] - O[2]) < 1e-4 && g(O[1] - O[3]) < 1e-4 && (O = O.slice(2));
                var x = O.length - 2,
                    P = +O[0],
                    B = +O[1],
                    q = +O[2],
                    ue = +O[3],
                    be = [P, B, P, B],
                    Ce = q - P,
                    se = ue - B,
                    Ue = Math.abs(O[x] - P) < .001 && Math.abs(O[x + 1] - B) < .001,
                    _e, Xe, Je, ct, dt, Bt, Lt, Tt, It, Ft, Jt, Gt, jt, rn, cn;
                for (Ue && (O.push(q, ue), q = P, ue = B, P = O[x - 2], B = O[x - 1], O.unshift(P, B), x += 4), y = y || y === 0 ? +y : 1, Je = 2; Je < x; Je += 2) _e = P, Xe = B, P = q, B = ue, q = +O[Je + 2], ue = +O[Je + 3], !(P === q && B === ue) && (ct = Ce, dt = se, Ce = q - P, se = ue - B, Bt = m(ct * ct + dt * dt), Lt = m(Ce * Ce + se * se), Tt = m(Math.pow(Ce / Lt + ct / Bt, 2) + Math.pow(se / Lt + dt / Bt, 2)), It = (Bt + Lt) * y * .25 / Tt, Ft = P - (P - _e) * (Bt ? It / Bt : 0), Jt = P + (q - P) * (Lt ? It / Lt : 0), Gt = P - (Ft + ((Jt - Ft) * (Bt * 3 / (Bt + Lt) + .5) / 4 || 0)), jt = B - (B - Xe) * (Bt ? It / Bt : 0), rn = B + (ue - B) * (Lt ? It / Lt : 0), cn = B - (jt + ((rn - jt) * (Bt * 3 / (Bt + Lt) + .5) / 4 || 0)), (P !== _e || B !== Xe) && be.push(X(Ft + Gt), X(jt + cn), X(P), X(B), X(Jt + Gt), X(rn + cn)));
                return P !== q || B !== ue || be.length < 4 ? be.push(X(q), X(ue), X(q), X(ue)) : be.length -= 2, be.length === 2 ? be.push(P, B, P, B, P, B) : Ue && (be.splice(0, 6), be.length = be.length - 6), be
            }

            function Ke(O) {
                j(O[0]) && (O = [O]);
                var y = "",
                    x = O.length,
                    P, B, q, ue;
                for (B = 0; B < x; B++) {
                    for (ue = O[B], y += "M" + X(ue[0]) + "," + X(ue[1]) + " C", P = ue.length, q = 2; q < P; q++) y += X(ue[q++]) + "," + X(ue[q++]) + " " + X(ue[q++]) + "," + X(ue[q++]) + " " + X(ue[q++]) + "," + X(ue[q]) + " ";
                    ue.closed && (y += "z")
                }
                return y
            }
            var M, I, fe, Oe, Te, Ie, st, nt, je = "transform",
                We = je + "Origin",
                bt, Ze = function(y) {
                    var x = y.ownerDocument || y;
                    for (!(je in y.style) && ("msTransform" in y.style) && (je = "msTransform", We = je + "Origin"); x.parentNode && (x = x.parentNode););
                    if (I = window, st = new ie, x) {
                        M = x, fe = x.documentElement, Oe = x.body, nt = M.createElementNS("http://www.w3.org/2000/svg", "g"), nt.style.transform = "none";
                        var P = x.createElement("div"),
                            B = x.createElement("div"),
                            q = x && (x.body || x.firstElementChild);
                        q && q.appendChild && (q.appendChild(P), P.appendChild(B), P.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"), bt = B.offsetParent !== P, q.removeChild(P))
                    }
                    return x
                },
                wt = function(y) {
                    for (var x, P; y && y !== Oe;) P = y._gsap, P && P.uncache && P.get(y, "x"), P && !P.scaleX && !P.scaleY && P.renderTransform && (P.scaleX = P.scaleY = 1e-4, P.renderTransform(1, P), x ? x.push(P) : x = [P]), y = y.parentNode;
                    return x
                },
                Et = [],
                Ot = [],
                qt = function() {
                    return I.pageYOffset || M.scrollTop || fe.scrollTop || Oe.scrollTop || 0
                },
                an = function() {
                    return I.pageXOffset || M.scrollLeft || fe.scrollLeft || Oe.scrollLeft || 0
                },
                Rn = function(y) {
                    return y.ownerSVGElement || ((y.tagName + "").toLowerCase() === "svg" ? y : null)
                },
                un = function O(y) {
                    if (I.getComputedStyle(y).position === "fixed") return !0;
                    if (y = y.parentNode, y && y.nodeType === 1) return O(y)
                },
                An = function O(y, x) {
                    if (y.parentNode && (M || Ze(y))) {
                        var P = Rn(y),
                            B = P ? P.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
                            q = P ? x ? "rect" : "g" : "div",
                            ue = x !== 2 ? 0 : 100,
                            be = x === 3 ? 100 : 0,
                            Ce = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
                            se = M.createElementNS ? M.createElementNS(B.replace(/^https/, "http"), q) : M.createElement(q);
                        return x && (P ? (Ie || (Ie = O(y)), se.setAttribute("width", .01), se.setAttribute("height", .01), se.setAttribute("transform", "translate(" + ue + "," + be + ")"), Ie.appendChild(se)) : (Te || (Te = O(y), Te.style.cssText = Ce), se.style.cssText = Ce + "width:0.1px;height:0.1px;top:" + be + "px;left:" + ue + "px", Te.appendChild(se))), se
                    }
                    throw "Need document and parent."
                },
                Un = function(y) {
                    for (var x = new ie, P = 0; P < y.numberOfItems; P++) x.multiply(y.getItem(P).matrix);
                    return x
                },
                er = function(y) {
                    var x = y.getCTM(),
                        P;
                    return x || (P = y.style[je], y.style[je] = "none", y.appendChild(nt), x = nt.getCTM(), y.removeChild(nt), P ? y.style[je] = P : y.style.removeProperty(je.replace(/([A-Z])/g, "-$1").toLowerCase())), x || st.clone()
                },
                ft = function(y, x) {
                    var P = Rn(y),
                        B = y === P,
                        q = P ? Et : Ot,
                        ue = y.parentNode,
                        be = ue && !P && ue.shadowRoot && ue.shadowRoot.appendChild ? ue.shadowRoot : ue,
                        Ce, se, Ue, _e, Xe, Je;
                    if (y === I) return y;
                    if (q.length || q.push(An(y, 1), An(y, 2), An(y, 3)), Ce = P ? Ie : Te, P) B ? (Ue = er(y), _e = -Ue.e / Ue.a, Xe = -Ue.f / Ue.d, se = st) : y.getBBox ? (Ue = y.getBBox(), se = y.transform ? y.transform.baseVal : {}, se = se.numberOfItems ? se.numberOfItems > 1 ? Un(se) : se.getItem(0).matrix : st, _e = se.a * Ue.x + se.c * Ue.y, Xe = se.b * Ue.x + se.d * Ue.y) : (se = new ie, _e = Xe = 0), x && y.tagName.toLowerCase() === "g" && (_e = Xe = 0), (B ? P : ue).appendChild(Ce), Ce.setAttribute("transform", "matrix(" + se.a + "," + se.b + "," + se.c + "," + se.d + "," + (se.e + _e) + "," + (se.f + Xe) + ")");
                    else {
                        if (_e = Xe = 0, bt)
                            for (se = y.offsetParent, Ue = y; Ue && (Ue = Ue.parentNode) && Ue !== se && Ue.parentNode;)(I.getComputedStyle(Ue)[je] + "").length > 4 && (_e = Ue.offsetLeft, Xe = Ue.offsetTop, Ue = 0);
                        if (Je = I.getComputedStyle(y), Je.position !== "absolute" && Je.position !== "fixed")
                            for (se = y.offsetParent; ue && ue !== se;) _e += ue.scrollLeft || 0, Xe += ue.scrollTop || 0, ue = ue.parentNode;
                        Ue = Ce.style, Ue.top = y.offsetTop - Xe + "px", Ue.left = y.offsetLeft - _e + "px", Ue[je] = Je[je], Ue[We] = Je[We], Ue.position = Je.position === "fixed" ? "fixed" : "absolute", be.appendChild(Ce)
                    }
                    return Ce
                },
                Y = function(y, x, P, B, q, ue, be) {
                    return y.a = x, y.b = P, y.c = B, y.d = q, y.e = ue, y.f = be, y
                },
                ie = function() {
                    function O(x, P, B, q, ue, be) {
                        x === void 0 && (x = 1), P === void 0 && (P = 0), B === void 0 && (B = 0), q === void 0 && (q = 1), ue === void 0 && (ue = 0), be === void 0 && (be = 0), Y(this, x, P, B, q, ue, be)
                    }
                    var y = O.prototype;
                    return y.inverse = function() {
                        var P = this.a,
                            B = this.b,
                            q = this.c,
                            ue = this.d,
                            be = this.e,
                            Ce = this.f,
                            se = P * ue - B * q || 1e-10;
                        return Y(this, ue / se, -B / se, -q / se, P / se, (q * Ce - ue * be) / se, -(P * Ce - B * be) / se)
                    }, y.multiply = function(P) {
                        var B = this.a,
                            q = this.b,
                            ue = this.c,
                            be = this.d,
                            Ce = this.e,
                            se = this.f,
                            Ue = P.a,
                            _e = P.c,
                            Xe = P.b,
                            Je = P.d,
                            ct = P.e,
                            dt = P.f;
                        return Y(this, Ue * B + Xe * ue, Ue * q + Xe * be, _e * B + Je * ue, _e * q + Je * be, Ce + ct * B + dt * ue, se + ct * q + dt * be)
                    }, y.clone = function() {
                        return new O(this.a, this.b, this.c, this.d, this.e, this.f)
                    }, y.equals = function(P) {
                        var B = this.a,
                            q = this.b,
                            ue = this.c,
                            be = this.d,
                            Ce = this.e,
                            se = this.f;
                        return B === P.a && q === P.b && ue === P.c && be === P.d && Ce === P.e && se === P.f
                    }, y.apply = function(P, B) {
                        B === void 0 && (B = {});
                        var q = P.x,
                            ue = P.y,
                            be = this.a,
                            Ce = this.b,
                            se = this.c,
                            Ue = this.d,
                            _e = this.e,
                            Xe = this.f;
                        return B.x = q * be + ue * se + _e || 0, B.y = q * Ce + ue * Ue + Xe || 0, B
                    }, O
                }();

            function ge(O, y, x, P) {
                if (!O || !O.parentNode || (M || Ze(O)).documentElement === O) return new ie;
                var B = wt(O),
                    q = Rn(O),
                    ue = q ? Et : Ot,
                    be = ft(O, x),
                    Ce = ue[0].getBoundingClientRect(),
                    se = ue[1].getBoundingClientRect(),
                    Ue = ue[2].getBoundingClientRect(),
                    _e = be.parentNode,
                    Xe = !P && un(O),
                    Je = new ie((se.left - Ce.left) / 100, (se.top - Ce.top) / 100, (Ue.left - Ce.left) / 100, (Ue.top - Ce.top) / 100, Ce.left + (Xe ? 0 : an()), Ce.top + (Xe ? 0 : qt()));
                if (_e.removeChild(be), B)
                    for (Ce = B.length; Ce--;) se = B[Ce], se.scaleX = se.scaleY = 0, se.renderTransform(1, se);
                return y ? Je.inverse() : Je
            }
            /*!
             * MotionPathPlugin 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var ke = "x,translateX,left,marginLeft,xPercent".split(","),
                Le = "y,translateY,top,marginTop,yPercent".split(","),
                Ee = Math.PI / 180,
                Ne, qe, Ve, yt, rt, He, ot = function() {
                    return Ne || typeof window < "u" && (Ne = window.gsap) && Ne.registerPlugin && Ne
                },
                Mt = function(y, x, P, B) {
                    for (var q = x.length, ue = B === 2 ? 0 : B, be = 0; be < q; be++) y[ue] = parseFloat(x[be][P]), B === 2 && (y[ue + 1] = 0), ue += 2;
                    return y
                },
                ut = function(y, x, P) {
                    return parseFloat(y._gsap.get(y, x, P || "px")) || 0
                },
                pt = function(y) {
                    var x = y[0],
                        P = y[1],
                        B;
                    for (B = 2; B < y.length; B += 2) x = y[B] += x, P = y[B + 1] += P
                },
                Qe = function(y, x, P, B, q, ue, be, Ce, se) {
                    if (be.type === "cubic") x = [x];
                    else {
                        be.fromCurrent !== !1 && x.unshift(ut(P, B, Ce), q ? ut(P, q, se) : 0), be.relative && pt(x);
                        var Ue = q ? Se : ze;
                        x = [Ue(x, be.curviness)]
                    }
                    return x = ue(ee(x, P, be)), ae(y, P, B, x, "x", Ce), q && ae(y, P, q, x, "y", se), _t(x, be.resolution || (be.curviness === 0 ? 20 : 12))
                },
                Re = function(y) {
                    return y
                },
                T = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g,
                z = function(y, x, P) {
                    var B = ge(y),
                        q = 0,
                        ue = 0,
                        be;
                    return (y.tagName + "").toLowerCase() === "svg" ? (be = y.viewBox.baseVal, be.width || (be = {
                        width: +y.getAttribute("width"),
                        height: +y.getAttribute("height")
                    })) : be = x && y.getBBox && y.getBBox(), x && x !== "auto" && (q = x.push ? x[0] * (be ? be.width : y.offsetWidth || 0) : x.x, ue = x.push ? x[1] * (be ? be.height : y.offsetHeight || 0) : x.y), P.apply(q || ue ? B.apply({
                        x: q,
                        y: ue
                    }) : {
                        x: B.e,
                        y: B.f
                    })
                },
                R = function(y, x, P, B) {
                    var q = ge(y.parentNode, !0, !0),
                        ue = q.clone().multiply(ge(x)),
                        be = z(y, P, q),
                        Ce = z(x, B, q),
                        se = Ce.x,
                        Ue = Ce.y,
                        _e;
                    return ue.e = ue.f = 0, B === "auto" && x.getTotalLength && x.tagName.toLowerCase() === "path" && (_e = x.getAttribute("d").match(T) || [], _e = ue.apply({
                        x: +_e[0],
                        y: +_e[1]
                    }), se += _e.x, Ue += _e.y), _e && (_e = ue.apply(x.getBBox()), se -= _e.x, Ue -= _e.y), ue.e = se - be.x, ue.f = Ue - be.y, ue
                },
                ee = function(y, x, P) {
                    var B = P.align,
                        q = P.matrix,
                        ue = P.offsetX,
                        be = P.offsetY,
                        Ce = P.alignOrigin,
                        se = y[0][0],
                        Ue = y[0][1],
                        _e = ut(x, "x"),
                        Xe = ut(x, "y"),
                        Je, ct, dt;
                    return !y || !y.length ? re("M0,0L0,0") : (B && (B === "self" || (Je = yt(B)[0] || x) === x ? de(y, 1, 0, 0, 1, _e - se, Xe - Ue) : (Ce && Ce[2] !== !1 ? Ne.set(x, {
                        transformOrigin: Ce[0] * 100 + "% " + Ce[1] * 100 + "%"
                    }) : Ce = [ut(x, "xPercent") / -100, ut(x, "yPercent") / -100], ct = R(x, Je, Ce, "auto"), dt = ct.apply({
                        x: se,
                        y: Ue
                    }), de(y, ct.a, ct.b, ct.c, ct.d, _e + ct.e - (dt.x - ct.e), Xe + ct.f - (dt.y - ct.f)))), q ? de(y, q.a, q.b, q.c, q.d, q.e, q.f) : (ue || be) && de(y, 1, 0, 0, 1, ue || 0, be || 0), y)
                },
                ae = function(y, x, P, B, q, ue) {
                    var be = x._gsap,
                        Ce = be.harness,
                        se = Ce && Ce.aliases && Ce.aliases[P],
                        Ue = se && se.indexOf(",") < 0 ? se : P,
                        _e = y._pt = new qe(y._pt, x, Ue, 0, 0, Re, 0, be.set(x, Ue, y));
                    _e.u = Ve(be.get(x, Ue, ue)) || 0, _e.path = B, _e.pp = q, y._props.push(Ue)
                },
                Fe = function(y, x) {
                    return function(P) {
                        return y || x !== 1 ? ht(P, y, x) : P
                    }
                },
                at = {
                    version: "3.13.0",
                    name: "motionPath",
                    register: function(y, x, P) {
                        Ne = y, Ve = Ne.utils.getUnit, yt = Ne.utils.toArray, rt = Ne.core.getStyleSaver, He = Ne.core.reverting || function() {}, qe = P
                    },
                    init: function(y, x, P) {
                        if (!Ne) return console.warn("Please gsap.registerPlugin(MotionPathPlugin)"), !1;
                        (!(typeof x == "object" && !x.style) || !x.path) && (x = {
                            path: x
                        });
                        var B = [],
                            q = x,
                            ue = q.path,
                            be = q.autoRotate,
                            Ce = q.unitX,
                            se = q.unitY,
                            Ue = q.x,
                            _e = q.y,
                            Xe = ue[0],
                            Je = Fe(x.start, "end" in x ? x.end : 1),
                            ct, dt;
                        if (this.rawPaths = B, this.target = y, this.tween = P, this.styles = rt && rt(y, "transform"), (this.rotate = be || be === 0) && (this.rOffset = parseFloat(be) || 0, this.radians = !!x.useRadians, this.rProp = x.rotation || "rotation", this.rSet = y._gsap.set(y, this.rProp, this), this.ru = Ve(y._gsap.get(y, this.rProp)) || 0), Array.isArray(ue) && !("closed" in ue) && typeof Xe != "number") {
                            for (dt in Xe) !Ue && ~ke.indexOf(dt) ? Ue = dt : !_e && ~Le.indexOf(dt) && (_e = dt);
                            Ue && _e ? B.push(Qe(this, Mt(Mt([], ue, Ue, 0), ue, _e, 1), y, Ue, _e, Je, x, Ce || Ve(ue[0][Ue]), se || Ve(ue[0][_e]))) : Ue = _e = 0;
                            for (dt in Xe) dt !== Ue && dt !== _e && B.push(Qe(this, Mt([], ue, dt, 2), y, dt, 0, Je, x, Ve(ue[0][dt])))
                        } else ct = Je(ee(re(x.path), y, x)), _t(ct, x.resolution), B.push(ct), ae(this, y, x.x || "x", ct, "x", x.unitX || "px"), ae(this, y, x.y || "y", ct, "y", x.unitY || "px");
                        P.vars.immediateRender && this.render(P.progress(), this)
                    },
                    render: function(y, x) {
                        var P = x.rawPaths,
                            B = P.length,
                            q = x._pt;
                        if (x.tween._time || !He()) {
                            for (y > 1 ? y = 1 : y < 0 && (y = 0); B--;) St(P[B], y, !B && x.rotate, P[B]);
                            for (; q;) q.set(q.t, q.p, q.path[q.pp] + q.u, q.d, y), q = q._next;
                            x.rotate && x.rSet(x.target, x.rProp, P[0].angle * (x.radians ? Ee : 1) + x.rOffset + x.ru, x, y)
                        } else x.styles.revert()
                    },
                    getLength: function(y) {
                        return _t(re(y)).totalLength
                    },
                    sliceRawPath: ht,
                    getRawPath: re,
                    pointsToSegment: Se,
                    stringToRawPath: oe,
                    rawPathToString: Ke,
                    transformRawPath: de,
                    getGlobalMatrix: ge,
                    getPositionOnPath: St,
                    cacheRawPathMeasurements: _t,
                    convertToPath: function(y, x) {
                        return yt(y).map(function(P) {
                            return ve(P, x !== !1)
                        })
                    },
                    convertCoordinates: function(y, x, P) {
                        var B = ge(x, !0, !0).multiply(ge(y));
                        return P ? B.apply(P) : B
                    },
                    getAlignMatrix: R,
                    getRelativePosition: function(y, x, P, B) {
                        var q = R(y, x, P, B);
                        return {
                            x: q.e,
                            y: q.f
                        }
                    },
                    arrayToRawPath: function(y, x) {
                        x = x || {};
                        var P = Mt(Mt([], y, x.x || "x", 0), y, x.y || "y", 1);
                        return x.relative && pt(P), [x.type === "cubic" ? P : Se(P, x.curviness)]
                    }
                };
            ot() && Ne.registerPlugin(at), n.MotionPathPlugin = at, n.default = at, Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(bl, bl.exports)), bl.exports
}
var ZC = JC();
const eS = Go(ZC);
var wl = {
        exports: {}
    },
    tS = wl.exports,
    $p;

function nS() {
    return $p || ($p = 1, function(e, t) {
        (function(n, r) {
            r(t)
        })(tS, function(n) {
            var r, i, s, a, c, u, p, d, g = "transform",
                m = g + "Origin",
                E, L = function(T) {
                    var z = T.ownerDocument || T;
                    for (!(g in T.style) && ("msTransform" in T.style) && (g = "msTransform", m = g + "Origin"); z.parentNode && (z = z.parentNode););
                    if (i = window, p = new Q, z) {
                        r = z, s = z.documentElement, a = z.body, d = r.createElementNS("http://www.w3.org/2000/svg", "g"), d.style.transform = "none";
                        var R = z.createElement("div"),
                            ee = z.createElement("div"),
                            ae = z && (z.body || z.firstElementChild);
                        ae && ae.appendChild && (ae.appendChild(R), R.appendChild(ee), R.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"), E = ee.offsetParent !== R, ae.removeChild(R))
                    }
                    return z
                },
                b = function(T) {
                    for (var z, R; T && T !== a;) R = T._gsap, R && R.uncache && R.get(T, "x"), R && !R.scaleX && !R.scaleY && R.renderTransform && (R.scaleX = R.scaleY = 1e-4, R.renderTransform(1, R), z ? z.push(R) : z = [R]), T = T.parentNode;
                    return z
                },
                j = [],
                A = [],
                $ = function() {
                    return i.pageYOffset || r.scrollTop || s.scrollTop || a.scrollTop || 0
                },
                w = function() {
                    return i.pageXOffset || r.scrollLeft || s.scrollLeft || a.scrollLeft || 0
                },
                k = function(T) {
                    return T.ownerSVGElement || ((T.tagName + "").toLowerCase() === "svg" ? T : null)
                },
                S = function Re(T) {
                    if (i.getComputedStyle(T).position === "fixed") return !0;
                    if (T = T.parentNode, T && T.nodeType === 1) return Re(T)
                },
                X = function Re(T, z) {
                    if (T.parentNode && (r || L(T))) {
                        var R = k(T),
                            ee = R ? R.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
                            ae = R ? z ? "rect" : "g" : "div",
                            Fe = z !== 2 ? 0 : 100,
                            at = z === 3 ? 100 : 0,
                            O = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
                            y = r.createElementNS ? r.createElementNS(ee.replace(/^https/, "http"), ae) : r.createElement(ae);
                        return z && (R ? (u || (u = Re(T)), y.setAttribute("width", .01), y.setAttribute("height", .01), y.setAttribute("transform", "translate(" + Fe + "," + at + ")"), u.appendChild(y)) : (c || (c = Re(T), c.style.cssText = O), y.style.cssText = O + "width:0.1px;height:0.1px;top:" + at + "px;left:" + Fe + "px", c.appendChild(y))), y
                    }
                    throw "Need document and parent."
                },
                J = function(T) {
                    for (var z = new Q, R = 0; R < T.numberOfItems; R++) z.multiply(T.getItem(R).matrix);
                    return z
                },
                xe = function(T) {
                    var z = T.getCTM(),
                        R;
                    return z || (R = T.style[g], T.style[g] = "none", T.appendChild(d), z = d.getCTM(), T.removeChild(d), R ? T.style[g] = R : T.style.removeProperty(g.replace(/([A-Z])/g, "-$1").toLowerCase())), z || p.clone()
                },
                he = function(T, z) {
                    var R = k(T),
                        ee = T === R,
                        ae = R ? j : A,
                        Fe = T.parentNode,
                        at = Fe && !R && Fe.shadowRoot && Fe.shadowRoot.appendChild ? Fe.shadowRoot : Fe,
                        O, y, x, P, B, q;
                    if (T === i) return T;
                    if (ae.length || ae.push(X(T, 1), X(T, 2), X(T, 3)), O = R ? u : c, R) ee ? (x = xe(T), P = -x.e / x.a, B = -x.f / x.d, y = p) : T.getBBox ? (x = T.getBBox(), y = T.transform ? T.transform.baseVal : {}, y = y.numberOfItems ? y.numberOfItems > 1 ? J(y) : y.getItem(0).matrix : p, P = y.a * x.x + y.c * x.y, B = y.b * x.x + y.d * x.y) : (y = new Q, P = B = 0), z && T.tagName.toLowerCase() === "g" && (P = B = 0), (ee ? R : Fe).appendChild(O), O.setAttribute("transform", "matrix(" + y.a + "," + y.b + "," + y.c + "," + y.d + "," + (y.e + P) + "," + (y.f + B) + ")");
                    else {
                        if (P = B = 0, E)
                            for (y = T.offsetParent, x = T; x && (x = x.parentNode) && x !== y && x.parentNode;)(i.getComputedStyle(x)[g] + "").length > 4 && (P = x.offsetLeft, B = x.offsetTop, x = 0);
                        if (q = i.getComputedStyle(T), q.position !== "absolute" && q.position !== "fixed")
                            for (y = T.offsetParent; Fe && Fe !== y;) P += Fe.scrollLeft || 0, B += Fe.scrollTop || 0, Fe = Fe.parentNode;
                        x = O.style, x.top = T.offsetTop - B + "px", x.left = T.offsetLeft - P + "px", x[g] = q[g], x[m] = q[m], x.position = q.position === "fixed" ? "fixed" : "absolute", at.appendChild(O)
                    }
                    return O
                },
                me = function(T, z, R, ee, ae, Fe, at) {
                    return T.a = z, T.b = R, T.c = ee, T.d = ae, T.e = Fe, T.f = at, T
                },
                Q = function() {
                    function Re(z, R, ee, ae, Fe, at) {
                        z === void 0 && (z = 1), R === void 0 && (R = 0), ee === void 0 && (ee = 0), ae === void 0 && (ae = 1), Fe === void 0 && (Fe = 0), at === void 0 && (at = 0), me(this, z, R, ee, ae, Fe, at)
                    }
                    var T = Re.prototype;
                    return T.inverse = function() {
                        var R = this.a,
                            ee = this.b,
                            ae = this.c,
                            Fe = this.d,
                            at = this.e,
                            O = this.f,
                            y = R * Fe - ee * ae || 1e-10;
                        return me(this, Fe / y, -ee / y, -ae / y, R / y, (ae * O - Fe * at) / y, -(R * O - ee * at) / y)
                    }, T.multiply = function(R) {
                        var ee = this.a,
                            ae = this.b,
                            Fe = this.c,
                            at = this.d,
                            O = this.e,
                            y = this.f,
                            x = R.a,
                            P = R.c,
                            B = R.b,
                            q = R.d,
                            ue = R.e,
                            be = R.f;
                        return me(this, x * ee + B * Fe, x * ae + B * at, P * ee + q * Fe, P * ae + q * at, O + ue * ee + be * Fe, y + ue * ae + be * at)
                    }, T.clone = function() {
                        return new Re(this.a, this.b, this.c, this.d, this.e, this.f)
                    }, T.equals = function(R) {
                        var ee = this.a,
                            ae = this.b,
                            Fe = this.c,
                            at = this.d,
                            O = this.e,
                            y = this.f;
                        return ee === R.a && ae === R.b && Fe === R.c && at === R.d && O === R.e && y === R.f
                    }, T.apply = function(R, ee) {
                        ee === void 0 && (ee = {});
                        var ae = R.x,
                            Fe = R.y,
                            at = this.a,
                            O = this.b,
                            y = this.c,
                            x = this.d,
                            P = this.e,
                            B = this.f;
                        return ee.x = ae * at + Fe * y + P || 0, ee.y = ae * O + Fe * x + B || 0, ee
                    }, Re
                }();

            function ne(Re, T, z, R) {
                if (!Re || !Re.parentNode || (r || L(Re)).documentElement === Re) return new Q;
                var ee = b(Re),
                    ae = k(Re),
                    Fe = ae ? j : A,
                    at = he(Re, z),
                    O = Fe[0].getBoundingClientRect(),
                    y = Fe[1].getBoundingClientRect(),
                    x = Fe[2].getBoundingClientRect(),
                    P = at.parentNode,
                    B = !R && S(Re),
                    q = new Q((y.left - O.left) / 100, (y.top - O.top) / 100, (x.left - O.left) / 100, (x.top - O.top) / 100, O.left + (B ? 0 : w()), O.top + (B ? 0 : $()));
                if (P.removeChild(at), ee)
                    for (O = ee.length; O--;) y = ee[O], y.scaleX = y.scaleY = 0, y.renderTransform(1, y);
                return T ? q.inverse() : q
            }
            /*!
             * Flip 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var re = 1,
                K, te, G, ce, le, ve, tt, ht = function(T, z) {
                    return T.actions.forEach(function(R) {
                        return R.vars[z] && R.vars[z](R)
                    })
                },
                lt = {},
                _t = 180 / Math.PI,
                mt = Math.PI / 180,
                Pt = {},
                St = {},
                de = {},
                ye = function(T) {
                    return typeof T == "string" ? T.split(" ").join("").split(",") : T
                },
                oe = ye("onStart,onUpdate,onComplete,onReverseComplete,onInterrupt"),
                ze = ye("transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight"),
                Se = function(T) {
                    return K(T)[0] || console.warn("Element not found:", T)
                },
                Ke = function(T) {
                    return Math.round(T * 1e4) / 1e4 || 0
                },
                M = function(T, z, R) {
                    return T.forEach(function(ee) {
                        return ee.classList[R](z)
                    })
                },
                I = {
                    zIndex: 1,
                    kill: 1,
                    simple: 1,
                    spin: 1,
                    clearProps: 1,
                    targets: 1,
                    toggleClass: 1,
                    onComplete: 1,
                    onUpdate: 1,
                    onInterrupt: 1,
                    onStart: 1,
                    delay: 1,
                    repeat: 1,
                    repeatDelay: 1,
                    yoyo: 1,
                    scale: 1,
                    fade: 1,
                    absolute: 1,
                    props: 1,
                    onEnter: 1,
                    onLeave: 1,
                    custom: 1,
                    paused: 1,
                    nested: 1,
                    prune: 1,
                    absoluteOnLeave: 1
                },
                fe = {
                    zIndex: 1,
                    simple: 1,
                    clearProps: 1,
                    scale: 1,
                    absolute: 1,
                    fitChild: 1,
                    getVars: 1,
                    props: 1
                },
                Oe = function(T) {
                    return T.replace(/([A-Z])/g, "-$1").toLowerCase()
                },
                Te = function(T, z) {
                    var R = {},
                        ee;
                    for (ee in T) z[ee] || (R[ee] = T[ee]);
                    return R
                },
                Ie = {},
                st = function(T) {
                    var z = Ie[T] = ye(T);
                    return de[T] = z.concat(ze), z
                },
                nt = function(T) {
                    var z = T._gsap || te.core.getCache(T);
                    return z.gmCache === te.ticker.frame ? z.gMatrix : (z.gmCache = te.ticker.frame, z.gMatrix = ne(T, !0, !1, !0))
                },
                je = function Re(T, z, R) {
                    R === void 0 && (R = 0);
                    for (var ee = T.parentNode, ae = 1e3 * Math.pow(10, R) * (z ? -1 : 1), Fe = z ? -ae * 900 : 0; T;) Fe += ae, T = T.previousSibling;
                    return ee ? Fe + Re(ee, z, R + 1) : Fe
                },
                We = function(T, z, R) {
                    return T.forEach(function(ee) {
                        return ee.d = je(R ? ee.element : ee.t, z)
                    }), T.sort(function(ee, ae) {
                        return ee.d - ae.d
                    }), T
                },
                bt = function(T, z) {
                    for (var R = T.element.style, ee = T.css = T.css || [], ae = z.length, Fe, at; ae--;) Fe = z[ae], at = R[Fe] || R.getPropertyValue(Fe), ee.push(at ? Fe : St[Fe] || (St[Fe] = Oe(Fe)), at);
                    return R
                },
                Ze = function(T) {
                    var z = T.css,
                        R = T.element.style,
                        ee = 0;
                    for (T.cache.uncache = 1; ee < z.length; ee += 2) z[ee + 1] ? R[z[ee]] = z[ee + 1] : R.removeProperty(z[ee]);
                    !z[z.indexOf("transform") + 1] && R.translate && (R.removeProperty("translate"), R.removeProperty("scale"), R.removeProperty("rotate"))
                },
                wt = function(T, z) {
                    T.forEach(function(R) {
                        return R.a.cache.uncache = 1
                    }), z || T.finalStates.forEach(Ze)
                },
                Et = "paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition".split(","),
                Ot = function(T, z, R) {
                    var ee = T.element,
                        ae = T.width,
                        Fe = T.height,
                        at = T.uncache,
                        O = T.getProp,
                        y = ee.style,
                        x = 4,
                        P, B, q;
                    if (typeof z != "object" && (z = T), G && R !== 1) return G._abs.push({
                        t: ee,
                        b: T,
                        a: T,
                        sd: 0
                    }), G._final.push(function() {
                        return (T.cache.uncache = 1) && Ze(T)
                    }), ee;
                    for (B = O("display") === "none", (!T.isVisible || B) && (B && (bt(T, ["display"]).display = z.display), T.matrix = z.matrix, T.width = ae = T.width || z.width, T.height = Fe = T.height || z.height), bt(T, Et), q = window.getComputedStyle(ee); x--;) y[Et[x]] = q[Et[x]];
                    if (y.gridArea = "1 / 1 / 1 / 1", y.transition = "none", y.position = "absolute", y.width = ae + "px", y.height = Fe + "px", y.top || (y.top = "0px"), y.left || (y.left = "0px"), at) P = new Mt(ee);
                    else if (P = Te(T, Pt), P.position = "absolute", T.simple) {
                        var ue = ee.getBoundingClientRect();
                        P.matrix = new Q(1, 0, 0, 1, ue.left + w(), ue.top + $())
                    } else P.matrix = ne(ee, !1, !1, !0);
                    return P = ie(P, T, !0), T.x = ve(P.x, .01), T.y = ve(P.y, .01), ee
                },
                qt = function(T, z) {
                    return z !== !0 && (z = K(z), T = T.filter(function(R) {
                        if (z.indexOf((R.sd < 0 ? R.b : R.a).element) !== -1) return !0;
                        R.t._gsap.renderTransform(1), R.b.isVisible && (R.t.style.width = R.b.width + "px", R.t.style.height = R.b.height + "px")
                    })), T
                },
                an = function(T) {
                    return We(T, !0).forEach(function(z) {
                        return (z.a.isVisible || z.b.isVisible) && Ot(z.sd < 0 ? z.b : z.a, z.b, 1)
                    })
                },
                Rn = function(T, z) {
                    return z && T.idLookup[un(z).id] || T.elementStates[0]
                },
                un = function(T, z, R, ee) {
                    return T instanceof Mt ? T : T instanceof ot ? Rn(T, ee) : new Mt(typeof T == "string" ? Se(T) || console.warn(T + " not found") : T, z, R)
                },
                An = function(T, z) {
                    for (var R = te.getProperty(T.element, null, "native"), ee = T.props = {}, ae = z.length; ae--;) ee[z[ae]] = (R(z[ae]) + "").trim();
                    return ee.zIndex && (ee.zIndex = parseFloat(ee.zIndex) || 0), T
                },
                Un = function(T, z) {
                    var R = T.style || T,
                        ee;
                    for (ee in z) R[ee] = z[ee]
                },
                er = function(T) {
                    var z = T.getAttribute("data-flip-id");
                    return z || T.setAttribute("data-flip-id", z = "auto-" + re++), z
                },
                ft = function(T) {
                    return T.map(function(z) {
                        return z.element
                    })
                },
                Y = function(T, z, R) {
                    return T && z.length && R.add(T(ft(z), R, new ot(z, 0, !0)), 0)
                },
                ie = function(T, z, R, ee, ae, Fe) {
                    var at = T.element,
                        O = T.cache,
                        y = T.parent,
                        x = T.x,
                        P = T.y,
                        B = z.width,
                        q = z.height,
                        ue = z.scaleX,
                        be = z.scaleY,
                        Ce = z.rotation,
                        se = z.bounds,
                        Ue = Fe && tt && tt(at, "transform,width,height"),
                        _e = T,
                        Xe = z.matrix,
                        Je = Xe.e,
                        ct = Xe.f,
                        dt = T.bounds.width !== se.width || T.bounds.height !== se.height || T.scaleX !== ue || T.scaleY !== be || T.rotation !== Ce,
                        Bt = !dt && T.simple && z.simple && !ae,
                        Lt, Tt, It, Ft, Jt, Gt, jt;
                    return Bt || !y ? (ue = be = 1, Ce = Lt = 0) : (Jt = nt(y), Gt = Jt.clone().multiply(z.ctm ? z.matrix.clone().multiply(z.ctm) : z.matrix), Ce = Ke(Math.atan2(Gt.b, Gt.a) * _t), Lt = Ke(Math.atan2(Gt.c, Gt.d) * _t + Ce) % 360, ue = Math.sqrt(Math.pow(Gt.a, 2) + Math.pow(Gt.b, 2)), be = Math.sqrt(Math.pow(Gt.c, 2) + Math.pow(Gt.d, 2)) * Math.cos(Lt * mt), ae && (ae = K(ae)[0], Ft = te.getProperty(ae), jt = ae.getBBox && typeof ae.getBBox == "function" && ae.getBBox(), _e = {
                        scaleX: Ft("scaleX"),
                        scaleY: Ft("scaleY"),
                        width: jt ? jt.width : Math.ceil(parseFloat(Ft("width", "px"))),
                        height: jt ? jt.height : parseFloat(Ft("height", "px"))
                    }), O.rotation = Ce + "deg", O.skewX = Lt + "deg"), R ? (ue *= B === _e.width || !_e.width ? 1 : B / _e.width, be *= q === _e.height || !_e.height ? 1 : q / _e.height, O.scaleX = ue, O.scaleY = be) : (B = ve(B * ue / _e.scaleX, 0), q = ve(q * be / _e.scaleY, 0), at.style.width = B + "px", at.style.height = q + "px"), ee && Un(at, z.props), Bt || !y ? (x += Je - T.matrix.e, P += ct - T.matrix.f) : dt || y !== z.parent ? (O.renderTransform(1, O), Gt = ne(ae || at, !1, !1, !0), Tt = Jt.apply({
                        x: Gt.e,
                        y: Gt.f
                    }), It = Jt.apply({
                        x: Je,
                        y: ct
                    }), x += It.x - Tt.x, P += It.y - Tt.y) : (Jt.e = Jt.f = 0, It = Jt.apply({
                        x: Je - T.matrix.e,
                        y: ct - T.matrix.f
                    }), x += It.x, P += It.y), x = ve(x, .02), P = ve(P, .02), Fe && !(Fe instanceof Mt) ? Ue && Ue.revert() : (O.x = x + "px", O.y = P + "px", O.renderTransform(1, O)), Fe && (Fe.x = x, Fe.y = P, Fe.rotation = Ce, Fe.skewX = Lt, R ? (Fe.scaleX = ue, Fe.scaleY = be) : (Fe.width = B, Fe.height = q)), Fe || O
                },
                ge = function(T, z) {
                    return T instanceof ot ? T : new ot(T, z)
                },
                ke = function(T, z, R) {
                    var ee = T.idLookup[R],
                        ae = T.alt[R];
                    return ae.isVisible && (!(z.getElementState(ae.element) || ae).isVisible || !ee.isVisible) ? ae : ee
                },
                Le = [],
                Ee = "width,height,overflowX,overflowY".split(","),
                Ne, qe = function(T) {
                    if (T !== Ne) {
                        var z = le.style,
                            R = le.clientWidth === window.outerWidth,
                            ee = le.clientHeight === window.outerHeight,
                            ae = 4;
                        if (T && (R || ee)) {
                            for (; ae--;) Le[ae] = z[Ee[ae]];
                            R && (z.width = le.clientWidth + "px", z.overflowY = "hidden"), ee && (z.height = le.clientHeight + "px", z.overflowX = "hidden"), Ne = T
                        } else if (Ne) {
                            for (; ae--;) Le[ae] ? z[Ee[ae]] = Le[ae] : z.removeProperty(Oe(Ee[ae]));
                            Ne = T
                        }
                    }
                },
                Ve = function(T, z, R, ee) {
                    T instanceof ot && z instanceof ot || console.warn("Not a valid state object."), R = R || {};
                    var ae = R,
                        Fe = ae.clearProps,
                        at = ae.onEnter,
                        O = ae.onLeave,
                        y = ae.absolute,
                        x = ae.absoluteOnLeave,
                        P = ae.custom,
                        B = ae.delay,
                        q = ae.paused,
                        ue = ae.repeat,
                        be = ae.repeatDelay,
                        Ce = ae.yoyo,
                        se = ae.toggleClass,
                        Ue = ae.nested,
                        _e = ae.zIndex,
                        Xe = ae.scale,
                        Je = ae.fade,
                        ct = ae.stagger,
                        dt = ae.spin,
                        Bt = ae.prune,
                        Lt = ("props" in R ? R : T).props,
                        Tt = Te(R, I),
                        It = te.timeline({
                            delay: B,
                            paused: q,
                            repeat: ue,
                            repeatDelay: be,
                            yoyo: Ce,
                            data: "isFlip"
                        }),
                        Ft = Tt,
                        Jt = [],
                        Gt = [],
                        jt = [],
                        rn = [],
                        cn = dt === !0 ? 1 : dt || 0,
                        Mr = typeof dt == "function" ? dt : function() {
                            return cn
                        },
                        tr = T.interrupted || z.interrupted,
                        fr = It[ee !== 1 ? "to" : "from"],
                        hr, br, nr, rr, Vn, Ln, qn, Yt, Cr, oi, ar, Pi, zn, Gn;
                    for (br in z.idLookup) ar = z.alt[br] ? ke(z, T, br) : z.idLookup[br], Vn = ar.element, oi = T.idLookup[br], T.alt[br] && Vn === oi.element && (T.alt[br].isVisible || !ar.isVisible) && (oi = T.alt[br]), oi ? (Ln = {
                        t: Vn,
                        b: oi,
                        a: ar,
                        sd: oi.element === Vn ? 0 : ar.isVisible ? 1 : -1
                    }, jt.push(Ln), Ln.sd && (Ln.sd < 0 && (Ln.b = ar, Ln.a = oi), tr && bt(Ln.b, Lt ? de[Lt] : ze), Je && jt.push(Ln.swap = {
                        t: oi.element,
                        b: Ln.b,
                        a: Ln.a,
                        sd: -Ln.sd,
                        swap: Ln
                    })), Vn._flip = oi.element._flip = G ? G.timeline : It) : ar.isVisible && (jt.push({
                        t: Vn,
                        b: Te(ar, {
                            isVisible: 1
                        }),
                        a: ar,
                        sd: 0,
                        entering: 1
                    }), Vn._flip = G ? G.timeline : It);
                    if (Lt && (Ie[Lt] || st(Lt)).forEach(function(Wr) {
                            return Tt[Wr] = function(En) {
                                return jt[En].a.props[Wr]
                            }
                        }), jt.finalStates = Cr = [], Pi = function() {
                            for (We(jt), qe(!0), rr = 0; rr < jt.length; rr++) Ln = jt[rr], zn = Ln.a, Gn = Ln.b, Bt && !zn.isDifferent(Gn) && !Ln.entering ? jt.splice(rr--, 1) : (Vn = Ln.t, Ue && !(Ln.sd < 0) && rr && (zn.matrix = ne(Vn, !1, !1, !0)), Gn.isVisible && zn.isVisible ? (Ln.sd < 0 ? (qn = new Mt(Vn, Lt, T.simple), ie(qn, zn, Xe, 0, 0, qn), qn.matrix = ne(Vn, !1, !1, !0), qn.css = Ln.b.css, Ln.a = zn = qn, Je && (Vn.style.opacity = tr ? Gn.opacity : zn.opacity), ct && rn.push(Vn)) : Ln.sd > 0 && Je && (Vn.style.opacity = tr ? zn.opacity - Gn.opacity : "0"), ie(zn, Gn, Xe, Lt)) : Gn.isVisible !== zn.isVisible && (Gn.isVisible ? zn.isVisible || (Gn.css = zn.css, Gt.push(Gn), jt.splice(rr--, 1), y && Ue && ie(zn, Gn, Xe, Lt)) : (zn.isVisible && Jt.push(zn), jt.splice(rr--, 1))), Xe || (Vn.style.maxWidth = Math.max(zn.width, Gn.width) + "px", Vn.style.maxHeight = Math.max(zn.height, Gn.height) + "px", Vn.style.minWidth = Math.min(zn.width, Gn.width) + "px", Vn.style.minHeight = Math.min(zn.height, Gn.height) + "px"), Ue && se && Vn.classList.add(se)), Cr.push(zn);
                            var En;
                            if (se && (En = Cr.map(function(bn) {
                                    return bn.element
                                }), Ue && En.forEach(function(bn) {
                                    return bn.classList.remove(se)
                                })), qe(!1), Xe ? (Tt.scaleX = function(bn) {
                                    return jt[bn].a.scaleX
                                }, Tt.scaleY = function(bn) {
                                    return jt[bn].a.scaleY
                                }) : (Tt.width = function(bn) {
                                    return jt[bn].a.width + "px"
                                }, Tt.height = function(bn) {
                                    return jt[bn].a.height + "px"
                                }, Tt.autoRound = R.autoRound || !1), Tt.x = function(bn) {
                                    return jt[bn].a.x + "px"
                                }, Tt.y = function(bn) {
                                    return jt[bn].a.y + "px"
                                }, Tt.rotation = function(bn) {
                                    return jt[bn].a.rotation + (dt ? Mr(bn, Yt[bn], Yt) * 360 : 0)
                                }, Tt.skewX = function(bn) {
                                    return jt[bn].a.skewX
                                }, Yt = jt.map(function(bn) {
                                    return bn.t
                                }), (_e || _e === 0) && (Tt.modifiers = {
                                    zIndex: function() {
                                        return _e
                                    }
                                }, Tt.zIndex = _e, Tt.immediateRender = R.immediateRender !== !1), Je && (Tt.opacity = function(bn) {
                                    return jt[bn].sd < 0 ? 0 : jt[bn].sd > 0 ? jt[bn].a.opacity : "+=0"
                                }), rn.length) {
                                ct = te.utils.distribute(ct);
                                var Es = Yt.slice(rn.length);
                                Tt.stagger = function(bn, $s) {
                                    return ct(~rn.indexOf($s) ? Yt.indexOf(jt[bn].swap.t) : bn, $s, Es)
                                }
                            }
                            if (oe.forEach(function(bn) {
                                    return R[bn] && It.eventCallback(bn, R[bn], R[bn + "Params"])
                                }), P && Yt.length) {
                                Ft = Te(Tt, I), "scale" in P && (P.scaleX = P.scaleY = P.scale, delete P.scale);
                                for (br in P) hr = Te(P[br], fe), hr[br] = Tt[br], !("duration" in hr) && "duration" in Tt && (hr.duration = Tt.duration), hr.stagger = Tt.stagger, fr.call(It, Yt, hr, 0), delete Ft[br]
                            }(Yt.length || Gt.length || Jt.length) && (se && It.add(function() {
                                return M(En, se, It._zTime < 0 ? "remove" : "add")
                            }, 0) && !q && M(En, se, "add"), Yt.length && fr.call(It, Yt, Ft, 0)), Y(at, Jt, It), Y(O, Gt, It);
                            var _n = G && G.timeline;
                            _n && (_n.add(It, 0), G._final.push(function() {
                                return wt(jt, !Fe)
                            })), nr = It.duration(), It.call(function() {
                                var bn = It.time() >= nr;
                                bn && !_n && wt(jt, !Fe), se && M(En, se, bn ? "remove" : "add")
                            })
                        }, x && (y = jt.filter(function(Wr) {
                            return !Wr.sd && !Wr.a.isVisible && Wr.b.isVisible
                        }).map(function(Wr) {
                            return Wr.a.element
                        })), G) {
                        var xs;
                        y && (xs = G._abs).push.apply(xs, qt(jt, y)), G._run.push(Pi)
                    } else y && an(qt(jt, y)), Pi();
                    var fn = G ? G.timeline : It;
                    return fn.revert = function() {
                        return rt(fn, 1, 1)
                    }, fn
                },
                yt = function Re(T) {
                    T.vars.onInterrupt && T.vars.onInterrupt.apply(T, T.vars.onInterruptParams || []), T.getChildren(!0, !1, !0).forEach(Re)
                },
                rt = function(T, z, R) {
                    if (T && T.progress() < 1 && (!T.paused() || R)) return z && (yt(T), z < 2 && T.progress(1), T.kill()), !0
                },
                He = function(T) {
                    for (var z = T.idLookup = {}, R = T.alt = {}, ee = T.elementStates, ae = ee.length, Fe; ae--;) Fe = ee[ae], z[Fe.id] ? R[Fe.id] = Fe : z[Fe.id] = Fe
                },
                ot = function() {
                    function Re(z, R, ee) {
                        if (this.props = R && R.props, this.simple = !!(R && R.simple), ee) this.targets = ft(z), this.elementStates = z, He(this);
                        else {
                            this.targets = K(z);
                            var ae = R && (R.kill === !1 || R.batch && !R.kill);
                            G && !ae && G._kill.push(this), this.update(ae || !!G)
                        }
                    }
                    var T = Re.prototype;
                    return T.update = function(R) {
                        var ee = this;
                        return this.elementStates = this.targets.map(function(ae) {
                            return new Mt(ae, ee.props, ee.simple)
                        }), He(this), this.interrupt(R), this.recordInlineStyles(), this
                    }, T.clear = function() {
                        return this.targets.length = this.elementStates.length = 0, He(this), this
                    }, T.fit = function(R, ee, ae) {
                        for (var Fe = We(this.elementStates.slice(0), !1, !0), at = (R || this).idLookup, O = 0, y, x; O < Fe.length; O++) y = Fe[O], ae && (y.matrix = ne(y.element, !1, !1, !0)), x = at[y.id], x && ie(y, x, ee, !0, 0, y), y.matrix = ne(y.element, !1, !1, !0);
                        return this
                    }, T.getProperty = function(R, ee) {
                        var ae = this.getElementState(R) || Pt;
                        return (ee in ae ? ae : ae.props || Pt)[ee]
                    }, T.add = function(R) {
                        for (var ee = R.targets.length, ae = this.idLookup, Fe = this.alt, at, O, y; ee--;) O = R.elementStates[ee], y = ae[O.id], y && (O.element === y.element || Fe[O.id] && Fe[O.id].element === O.element) ? (at = this.elementStates.indexOf(O.element === y.element ? y : Fe[O.id]), this.targets.splice(at, 1, R.targets[ee]), this.elementStates.splice(at, 1, O)) : (this.targets.push(R.targets[ee]), this.elementStates.push(O));
                        return R.interrupted && (this.interrupted = !0), R.simple || (this.simple = !1), He(this), this
                    }, T.compare = function(R) {
                        var ee = R.idLookup,
                            ae = this.idLookup,
                            Fe = [],
                            at = [],
                            O = [],
                            y = [],
                            x = [],
                            P = R.alt,
                            B = this.alt,
                            q = function(Bt, Lt, Tt) {
                                return (Bt.isVisible !== Lt.isVisible ? Bt.isVisible ? O : y : Bt.isVisible ? at : Fe).push(Tt) && x.push(Tt)
                            },
                            ue = function(Bt, Lt, Tt) {
                                return x.indexOf(Tt) < 0 && q(Bt, Lt, Tt)
                            },
                            be, Ce, se, Ue, _e, Xe, Je, ct;
                        for (se in ee) _e = P[se], Xe = B[se], be = _e ? ke(R, this, se) : ee[se], Ue = be.element, Ce = ae[se], Xe ? (ct = Ce.isVisible || !Xe.isVisible && Ue === Ce.element ? Ce : Xe, Je = _e && !be.isVisible && !_e.isVisible && ct.element === _e.element ? _e : be, Je.isVisible && ct.isVisible && Je.element !== ct.element ? ((Je.isDifferent(ct) ? at : Fe).push(Je.element, ct.element), x.push(Je.element, ct.element)) : q(Je, ct, Je.element), _e && Je.element === _e.element && (_e = ee[se]), ue(Je.element !== Ce.element && _e ? _e : Je, Ce, Ce.element), ue(_e && _e.element === Xe.element ? _e : Je, Xe, Xe.element), _e && ue(_e, Xe.element === _e.element ? Xe : Ce, _e.element)) : (Ce ? Ce.isDifferent(be) ? q(be, Ce, Ue) : Fe.push(Ue) : O.push(Ue), _e && ue(_e, Ce, _e.element));
                        for (se in ae) ee[se] || (y.push(ae[se].element), B[se] && y.push(B[se].element));
                        return {
                            changed: at,
                            unchanged: Fe,
                            enter: O,
                            leave: y
                        }
                    }, T.recordInlineStyles = function() {
                        for (var R = de[this.props] || ze, ee = this.elementStates.length; ee--;) bt(this.elementStates[ee], R)
                    }, T.interrupt = function(R) {
                        var ee = this,
                            ae = [];
                        this.targets.forEach(function(Fe) {
                            var at = Fe._flip,
                                O = rt(at, R ? 0 : 1);
                            R && O && ae.indexOf(at) < 0 && at.add(function() {
                                return ee.updateVisibility()
                            }), O && ae.push(at)
                        }), !R && ae.length && this.updateVisibility(), this.interrupted || (this.interrupted = !!ae.length)
                    }, T.updateVisibility = function() {
                        this.elementStates.forEach(function(R) {
                            var ee = R.element.getBoundingClientRect();
                            R.isVisible = !!(ee.width || ee.height || ee.top || ee.left), R.uncache = 1
                        })
                    }, T.getElementState = function(R) {
                        return this.elementStates[this.targets.indexOf(Se(R))]
                    }, T.makeAbsolute = function() {
                        return We(this.elementStates.slice(0), !0, !0).map(Ot)
                    }, Re
                }(),
                Mt = function() {
                    function Re(z, R, ee) {
                        this.element = z, this.update(R, ee)
                    }
                    var T = Re.prototype;
                    return T.isDifferent = function(R) {
                        var ee = this.bounds,
                            ae = R.bounds;
                        return ee.top !== ae.top || ee.left !== ae.left || ee.width !== ae.width || ee.height !== ae.height || !this.matrix.equals(R.matrix) || this.opacity !== R.opacity || this.props && R.props && JSON.stringify(this.props) !== JSON.stringify(R.props)
                    }, T.update = function(R, ee) {
                        var ae = this,
                            Fe = ae.element,
                            at = te.getProperty(Fe),
                            O = te.core.getCache(Fe),
                            y = Fe.getBoundingClientRect(),
                            x = Fe.getBBox && typeof Fe.getBBox == "function" && Fe.nodeName.toLowerCase() !== "svg" && Fe.getBBox(),
                            P = ee ? new Q(1, 0, 0, 1, y.left + w(), y.top + $()) : ne(Fe, !1, !1, !0);
                        O.uncache = 1, ae.getProp = at, ae.element = Fe, ae.id = er(Fe), ae.matrix = P, ae.cache = O, ae.bounds = y, ae.isVisible = !!(y.width || y.height || y.left || y.top), ae.display = at("display"), ae.position = at("position"), ae.parent = Fe.parentNode, ae.x = at("x"), ae.y = at("y"), ae.scaleX = O.scaleX, ae.scaleY = O.scaleY, ae.rotation = at("rotation"), ae.skewX = at("skewX"), ae.opacity = at("opacity"), ae.width = x ? x.width : ve(at("width", "px"), .04), ae.height = x ? x.height : ve(at("height", "px"), .04), R && An(ae, Ie[R] || st(R)), ae.ctm = Fe.getCTM && Fe.nodeName.toLowerCase() === "svg" && xe(Fe).inverse(), ae.simple = ee || Ke(P.a) === 1 && !Ke(P.b) && !Ke(P.c) && Ke(P.d) === 1, ae.uncache = 0
                    }, Re
                }(),
                ut = function() {
                    function Re(z, R) {
                        this.vars = z, this.batch = R, this.states = [], this.timeline = R.timeline
                    }
                    var T = Re.prototype;
                    return T.getStateById = function(R) {
                        for (var ee = this.states.length; ee--;)
                            if (this.states[ee].idLookup[R]) return this.states[ee]
                    }, T.kill = function() {
                        this.batch.remove(this)
                    }, Re
                }(),
                pt = function() {
                    function Re(z) {
                        this.id = z, this.actions = [], this._kill = [], this._final = [], this._abs = [], this._run = [], this.data = {}, this.state = new ot, this.timeline = te.timeline()
                    }
                    var T = Re.prototype;
                    return T.add = function(R) {
                        var ee = this.actions.filter(function(ae) {
                            return ae.vars === R
                        });
                        return ee.length ? ee[0] : (ee = new ut(typeof R == "function" ? {
                            animate: R
                        } : R, this), this.actions.push(ee), ee)
                    }, T.remove = function(R) {
                        var ee = this.actions.indexOf(R);
                        return ee >= 0 && this.actions.splice(ee, 1), this
                    }, T.getState = function(R) {
                        var ee = this,
                            ae = G,
                            Fe = ce;
                        return G = this, this.state.clear(), this._kill.length = 0, this.actions.forEach(function(at) {
                            at.vars.getState && (at.states.length = 0, ce = at, at.state = at.vars.getState(at)), R && at.states.forEach(function(O) {
                                return ee.state.add(O)
                            })
                        }), ce = Fe, G = ae, this.killConflicts(), this
                    }, T.animate = function() {
                        var R = this,
                            ee = G,
                            ae = this.timeline,
                            Fe = this.actions.length,
                            at, O;
                        for (G = this, ae.clear(), this._abs.length = this._final.length = this._run.length = 0, this.actions.forEach(function(y) {
                                y.vars.animate && y.vars.animate(y);
                                var x = y.vars.onEnter,
                                    P = y.vars.onLeave,
                                    B = y.targets,
                                    q, ue;
                                B && B.length && (x || P) && (q = new ot, y.states.forEach(function(be) {
                                    return q.add(be)
                                }), ue = q.compare(Qe.getState(B)), ue.enter.length && x && x(ue.enter), ue.leave.length && P && P(ue.leave))
                            }), an(this._abs), this._run.forEach(function(y) {
                                return y()
                            }), O = ae.duration(), at = this._final.slice(0), ae.add(function() {
                                O <= ae.time() && (at.forEach(function(y) {
                                    return y()
                                }), ht(R, "onComplete"))
                            }), G = ee; Fe--;) this.actions[Fe].vars.once && this.actions[Fe].kill();
                        return ht(this, "onStart"), ae.restart(), this
                    }, T.loadState = function(R) {
                        R || (R = function() {
                            return 0
                        });
                        var ee = [];
                        return this.actions.forEach(function(ae) {
                            if (ae.vars.loadState) {
                                var Fe, at = function O(y) {
                                    y && (ae.targets = y), Fe = ee.indexOf(O), ~Fe && (ee.splice(Fe, 1), ee.length || R())
                                };
                                ee.push(at), ae.vars.loadState(at)
                            }
                        }), ee.length || R(), this
                    }, T.setState = function() {
                        return this.actions.forEach(function(R) {
                            return R.targets = R.vars.setState && R.vars.setState(R)
                        }), this
                    }, T.killConflicts = function(R) {
                        return this.state.interrupt(R), this._kill.forEach(function(ee) {
                            return ee.interrupt(R)
                        }), this
                    }, T.run = function(R, ee) {
                        var ae = this;
                        return this !== G && (R || this.getState(ee), this.loadState(function() {
                            ae._killed || (ae.setState(), ae.animate())
                        })), this
                    }, T.clear = function(R) {
                        this.state.clear(), R || (this.actions.length = 0)
                    }, T.getStateById = function(R) {
                        for (var ee = this.actions.length, ae; ee--;)
                            if (ae = this.actions[ee].getStateById(R), ae) return ae;
                        return this.state.idLookup[R] && this.state
                    }, T.kill = function() {
                        this._killed = 1, this.clear(), delete lt[this.id]
                    }, Re
                }(),
                Qe = function() {
                    function Re() {}
                    return Re.getState = function(z, R) {
                        var ee = ge(z, R);
                        return ce && ce.states.push(ee), R && R.batch && Re.batch(R.batch).state.add(ee), ee
                    }, Re.from = function(z, R) {
                        return R = R || {}, "clearProps" in R || (R.clearProps = !0), Ve(z, ge(R.targets || z.targets, {
                            props: R.props || z.props,
                            simple: R.simple,
                            kill: !!R.kill
                        }), R, -1)
                    }, Re.to = function(z, R) {
                        return Ve(z, ge(R.targets || z.targets, {
                            props: R.props || z.props,
                            simple: R.simple,
                            kill: !!R.kill
                        }), R, 1)
                    }, Re.fromTo = function(z, R, ee) {
                        return Ve(z, R, ee)
                    }, Re.fit = function(z, R, ee) {
                        var ae = ee ? Te(ee, fe) : {},
                            Fe = ee || ae,
                            at = Fe.absolute,
                            O = Fe.scale,
                            y = Fe.getVars,
                            x = Fe.props,
                            P = Fe.runBackwards,
                            B = Fe.onComplete,
                            q = Fe.simple,
                            ue = ee && ee.fitChild && Se(ee.fitChild),
                            be = un(R, x, q, z),
                            Ce = un(z, 0, q, be),
                            se = x ? de[x] : ze,
                            Ue = te.context();
                        return x && Un(ae, be.props), bt(Ce, se), P && ("immediateRender" in ae || (ae.immediateRender = !0), ae.onComplete = function() {
                            Ze(Ce), B && B.apply(this, arguments)
                        }), at && Ot(Ce, be), ae = ie(Ce, be, O || ue, !ae.duration && x, ue, ae.duration || y ? ae : 0), typeof ee == "object" && "zIndex" in ee && (ae.zIndex = ee.zIndex), Ue && !y && Ue.add(function() {
                            return function() {
                                return Ze(Ce)
                            }
                        }), y ? ae : ae.duration ? te.to(Ce.element, ae) : null
                    }, Re.makeAbsolute = function(z, R) {
                        return (z instanceof ot ? z : new ot(z, R)).makeAbsolute()
                    }, Re.batch = function(z) {
                        return z || (z = "default"), lt[z] || (lt[z] = new pt(z))
                    }, Re.killFlipsOf = function(z, R) {
                        (z instanceof ot ? z.targets : K(z)).forEach(function(ee) {
                            return ee && rt(ee._flip, R !== !1 ? 1 : 2)
                        })
                    }, Re.isFlipping = function(z) {
                        var R = Re.getByTarget(z);
                        return !!R && R.isActive()
                    }, Re.getByTarget = function(z) {
                        return (Se(z) || Pt)._flip
                    }, Re.getElementState = function(z, R) {
                        return new Mt(Se(z), R)
                    }, Re.convertCoordinates = function(z, R, ee) {
                        var ae = ne(R, !0, !0).multiply(ne(z));
                        return ee ? ae.apply(ee) : ae
                    }, Re.register = function(z) {
                        if (le = typeof document < "u" && document.body, le) {
                            te = z, L(le), K = te.utils.toArray, tt = te.core.getStyleSaver;
                            var R = te.utils.snap(.1);
                            ve = function(ae, Fe) {
                                return R(parseFloat(ae) + Fe)
                            }
                        }
                    }, Re
                }();
            Qe.version = "3.13.0", typeof window < "u" && window.gsap && window.gsap.registerPlugin(Qe), n.Flip = Qe, n.default = Qe, Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(wl, wl.exports)), wl.exports
}
var rS = nS();
const Hp = Go(rS);
var Dl = {
        exports: {}
    },
    iS = Dl.exports,
    Vp;

function sS() {
    return Vp || (Vp = 1, function(e, t) {
        (function(n, r) {
            r(t)
        })(iS, function(n) {
            var r = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
                i = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
                s = Math.PI / 180,
                a = Math.sin,
                c = Math.cos,
                u = Math.abs,
                p = Math.sqrt,
                d = function(K) {
                    return typeof K == "number"
                },
                g = 1e5,
                m = function(K) {
                    return Math.round(K * g) / g || 0
                };

            function E(re, K, te, G, ce, le, ve) {
                for (var tt = re.length, ht, lt, _t, mt, Pt; --tt > -1;)
                    for (ht = re[tt], lt = ht.length, _t = 0; _t < lt; _t += 2) mt = ht[_t], Pt = ht[_t + 1], ht[_t] = mt * K + Pt * G + le, ht[_t + 1] = mt * te + Pt * ce + ve;
                return re._dirty = 1, re
            }

            function L(re, K, te, G, ce, le, ve, tt, ht) {
                if (!(re === tt && K === ht)) {
                    te = u(te), G = u(G);
                    var lt = ce % 360 * s,
                        _t = c(lt),
                        mt = a(lt),
                        Pt = Math.PI,
                        St = Pt * 2,
                        de = (re - tt) / 2,
                        ye = (K - ht) / 2,
                        oe = _t * de + mt * ye,
                        ze = -mt * de + _t * ye,
                        Se = oe * oe,
                        Ke = ze * ze,
                        M = Se / (te * te) + Ke / (G * G);
                    M > 1 && (te = p(M) * te, G = p(M) * G);
                    var I = te * te,
                        fe = G * G,
                        Oe = (I * fe - I * Ke - fe * Se) / (I * Ke + fe * Se);
                    Oe < 0 && (Oe = 0);
                    var Te = (le === ve ? -1 : 1) * p(Oe),
                        Ie = Te * (te * ze / G),
                        st = Te * -(G * oe / te),
                        nt = (re + tt) / 2,
                        je = (K + ht) / 2,
                        We = nt + (_t * Ie - mt * st),
                        bt = je + (mt * Ie + _t * st),
                        Ze = (oe - Ie) / te,
                        wt = (ze - st) / G,
                        Et = (-oe - Ie) / te,
                        Ot = (-ze - st) / G,
                        qt = Ze * Ze + wt * wt,
                        an = (wt < 0 ? -1 : 1) * Math.acos(Ze / p(qt)),
                        Rn = (Ze * Ot - wt * Et < 0 ? -1 : 1) * Math.acos((Ze * Et + wt * Ot) / p(qt * (Et * Et + Ot * Ot)));
                    isNaN(Rn) && (Rn = Pt), !ve && Rn > 0 ? Rn -= St : ve && Rn < 0 && (Rn += St), an %= St, Rn %= St;
                    var un = Math.ceil(u(Rn) / (St / 4)),
                        An = [],
                        Un = Rn / un,
                        er = 4 / 3 * a(Un / 2) / (1 + c(Un / 2)),
                        ft = _t * te,
                        Y = mt * te,
                        ie = mt * -G,
                        ge = _t * G,
                        ke;
                    for (ke = 0; ke < un; ke++) ce = an + ke * Un, oe = c(ce), ze = a(ce), Ze = c(ce += Un), wt = a(ce), An.push(oe - er * ze, ze + er * oe, Ze + er * wt, wt - er * Ze, Ze, wt);
                    for (ke = 0; ke < An.length; ke += 2) oe = An[ke], ze = An[ke + 1], An[ke] = oe * ft + ze * ie + We, An[ke + 1] = oe * Y + ze * ge + bt;
                    return An[ke - 2] = tt, An[ke - 1] = ht, An
                }
            }

            function b(re) {
                var K = (re + "").replace(i, function(Ie) {
                        var st = +Ie;
                        return st < 1e-4 && st > -1e-4 ? 0 : st
                    }).match(r) || [],
                    te = [],
                    G = 0,
                    ce = 0,
                    le = 2 / 3,
                    ve = K.length,
                    tt = 0,
                    ht = "ERROR: malformed path: " + re,
                    lt, _t, mt, Pt, St, de, ye, oe, ze, Se, Ke, M, I, fe, Oe, Te = function(st, nt, je, We) {
                        Se = (je - st) / 3, Ke = (We - nt) / 3, ye.push(st + Se, nt + Ke, je - Se, We - Ke, je, We)
                    };
                if (!re || !isNaN(K[0]) || isNaN(K[1])) return console.log(ht), te;
                for (lt = 0; lt < ve; lt++)
                    if (I = St, isNaN(K[lt]) ? (St = K[lt].toUpperCase(), de = St !== K[lt]) : lt--, mt = +K[lt + 1], Pt = +K[lt + 2], de && (mt += G, Pt += ce), lt || (oe = mt, ze = Pt), St === "M") ye && (ye.length < 8 ? te.length -= 1 : tt += ye.length), G = oe = mt, ce = ze = Pt, ye = [mt, Pt], te.push(ye), lt += 2, St = "L";
                    else if (St === "C") ye || (ye = [0, 0]), de || (G = ce = 0), ye.push(mt, Pt, G + K[lt + 3] * 1, ce + K[lt + 4] * 1, G += K[lt + 5] * 1, ce += K[lt + 6] * 1), lt += 6;
                else if (St === "S") Se = G, Ke = ce, (I === "C" || I === "S") && (Se += G - ye[ye.length - 4], Ke += ce - ye[ye.length - 3]), de || (G = ce = 0), ye.push(Se, Ke, mt, Pt, G += K[lt + 3] * 1, ce += K[lt + 4] * 1), lt += 4;
                else if (St === "Q") Se = G + (mt - G) * le, Ke = ce + (Pt - ce) * le, de || (G = ce = 0), G += K[lt + 3] * 1, ce += K[lt + 4] * 1, ye.push(Se, Ke, G + (mt - G) * le, ce + (Pt - ce) * le, G, ce), lt += 4;
                else if (St === "T") Se = G - ye[ye.length - 4], Ke = ce - ye[ye.length - 3], ye.push(G + Se, ce + Ke, mt + (G + Se * 1.5 - mt) * le, Pt + (ce + Ke * 1.5 - Pt) * le, G = mt, ce = Pt), lt += 2;
                else if (St === "H") Te(G, ce, G = mt, ce), lt += 1;
                else if (St === "V") Te(G, ce, G, ce = mt + (de ? ce - G : 0)), lt += 1;
                else if (St === "L" || St === "Z") St === "Z" && (mt = oe, Pt = ze, ye.closed = !0), (St === "L" || u(G - mt) > .5 || u(ce - Pt) > .5) && (Te(G, ce, mt, Pt), St === "L" && (lt += 2)), G = mt, ce = Pt;
                else if (St === "A") {
                    if (fe = K[lt + 4], Oe = K[lt + 5], Se = K[lt + 6], Ke = K[lt + 7], _t = 7, fe.length > 1 && (fe.length < 3 ? (Ke = Se, Se = Oe, _t--) : (Ke = Oe, Se = fe.substr(2), _t -= 2), Oe = fe.charAt(1), fe = fe.charAt(0)), M = L(G, ce, +K[lt + 1], +K[lt + 2], +K[lt + 3], +fe, +Oe, (de ? G : 0) + Se * 1, (de ? ce : 0) + Ke * 1), lt += _t, M)
                        for (_t = 0; _t < M.length; _t++) ye.push(M[_t]);
                    G = ye[ye.length - 2], ce = ye[ye.length - 1]
                } else console.log(ht);
                return lt = ye.length, lt < 6 ? (te.pop(), lt = 0) : ye[0] === ye[lt - 2] && ye[1] === ye[lt - 1] && (ye.closed = !0), te.totalPoints = tt + lt, te
            }

            function j(re) {
                d(re[0]) && (re = [re]);
                var K = "",
                    te = re.length,
                    G, ce, le, ve;
                for (ce = 0; ce < te; ce++) {
                    for (ve = re[ce], K += "M" + m(ve[0]) + "," + m(ve[1]) + " C", G = ve.length, le = 2; le < G; le++) K += m(ve[le++]) + "," + m(ve[le++]) + " " + m(ve[le++]) + "," + m(ve[le++]) + " " + m(ve[le++]) + "," + m(ve[le]) + " ";
                    ve.closed && (K += "z")
                }
                return K
            }
            /*!
             * CustomEase 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var A, $, w = function() {
                    return A || typeof window < "u" && (A = window.gsap) && A.registerPlugin && A
                },
                k = function() {
                    A = w(), A ? (A.registerEase("_CE", ne.create), $ = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
                },
                S = 1e20,
                X = function(K) {
                    return ~~(K * 1e3 + (K < 0 ? -.5 : .5)) / 1e3
                },
                J = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi,
                xe = /[cLlsSaAhHvVtTqQ]/g,
                he = function(K) {
                    var te = K.length,
                        G = S,
                        ce;
                    for (ce = 1; ce < te; ce += 6) + K[ce] < G && (G = +K[ce]);
                    return G
                },
                me = function(K, te, G) {
                    !G && G !== 0 && (G = Math.max(+K[K.length - 1], +K[1]));
                    var ce = +K[0] * -1,
                        le = -G,
                        ve = K.length,
                        tt = 1 / (+K[ve - 2] + ce),
                        ht = -te || (Math.abs(+K[ve - 1] - +K[1]) < .01 * (+K[ve - 2] - +K[0]) ? he(K) + le : +K[ve - 1] + le),
                        lt;
                    for (ht ? ht = 1 / ht : ht = -tt, lt = 0; lt < ve; lt += 2) K[lt] = (+K[lt] + ce) * tt, K[lt + 1] = (+K[lt + 1] + le) * ht
                },
                Q = function re(K, te, G, ce, le, ve, tt, ht, lt, _t, mt) {
                    var Pt = (K + G) / 2,
                        St = (te + ce) / 2,
                        de = (G + le) / 2,
                        ye = (ce + ve) / 2,
                        oe = (le + tt) / 2,
                        ze = (ve + ht) / 2,
                        Se = (Pt + de) / 2,
                        Ke = (St + ye) / 2,
                        M = (de + oe) / 2,
                        I = (ye + ze) / 2,
                        fe = (Se + M) / 2,
                        Oe = (Ke + I) / 2,
                        Te = tt - K,
                        Ie = ht - te,
                        st = Math.abs((G - tt) * Ie - (ce - ht) * Te),
                        nt = Math.abs((le - tt) * Ie - (ve - ht) * Te),
                        je;
                    return _t || (_t = [{
                        x: K,
                        y: te
                    }, {
                        x: tt,
                        y: ht
                    }], mt = 1), _t.splice(mt || _t.length - 1, 0, {
                        x: fe,
                        y: Oe
                    }), (st + nt) * (st + nt) > lt * (Te * Te + Ie * Ie) && (je = _t.length, re(K, te, Pt, St, Se, Ke, fe, Oe, lt, _t, mt), re(fe, Oe, M, I, oe, ze, tt, ht, lt, _t, mt + 1 + (_t.length - je))), _t
                },
                ne = function() {
                    function re(te, G, ce) {
                        $ || k(), this.id = te, this.setData(G, ce)
                    }
                    var K = re.prototype;
                    return K.setData = function(G, ce) {
                        ce = ce || {}, G = G || "0,0,1,1";
                        var le = G.match(J),
                            ve = 1,
                            tt = [],
                            ht = [],
                            lt = ce.precision || 1,
                            _t = lt <= 1,
                            mt, Pt, St, de, ye, oe, ze, Se, Ke;
                        if (this.data = G, (xe.test(G) || ~G.indexOf("M") && G.indexOf("C") < 0) && (le = b(G)[0]), mt = le.length, mt === 4) le.unshift(0, 0), le.push(1, 1), mt = 8;
                        else if ((mt - 2) % 6) throw "Invalid CustomEase";
                        for ((+le[0] != 0 || +le[mt - 2] != 1) && me(le, ce.height, ce.originY), this.segment = le, de = 2; de < mt; de += 6) Pt = {
                            x: +le[de - 2],
                            y: +le[de - 1]
                        }, St = {
                            x: +le[de + 4],
                            y: +le[de + 5]
                        }, tt.push(Pt, St), Q(Pt.x, Pt.y, +le[de], +le[de + 1], +le[de + 2], +le[de + 3], St.x, St.y, 1 / (lt * 2e5), tt, tt.length - 1);
                        for (mt = tt.length, de = 0; de < mt; de++) ze = tt[de], Se = tt[de - 1] || ze, (ze.x > Se.x || Se.y !== ze.y && Se.x === ze.x || ze === Se) && ze.x <= 1 ? (Se.cx = ze.x - Se.x, Se.cy = ze.y - Se.y, Se.n = ze, Se.nx = ze.x, _t && de > 1 && Math.abs(Se.cy / Se.cx - tt[de - 2].cy / tt[de - 2].cx) > 2 && (_t = 0), Se.cx < ve && (Se.cx ? ve = Se.cx : (Se.cx = .001, de === mt - 1 && (Se.x -= .001, ve = Math.min(ve, .001), _t = 0)))) : (tt.splice(de--, 1), mt--);
                        if (mt = 1 / ve + 1 | 0, ye = 1 / mt, oe = 0, ze = tt[0], _t) {
                            for (de = 0; de < mt; de++) Ke = de * ye, ze.nx < Ke && (ze = tt[++oe]), Pt = ze.y + (Ke - ze.x) / ze.cx * ze.cy, ht[de] = {
                                x: Ke,
                                cx: ye,
                                y: Pt,
                                cy: 0,
                                nx: 9
                            }, de && (ht[de - 1].cy = Pt - ht[de - 1].y);
                            oe = tt[tt.length - 1], ht[mt - 1].cy = oe.y - Pt, ht[mt - 1].cx = oe.x - ht[ht.length - 1].x
                        } else {
                            for (de = 0; de < mt; de++) ze.nx < de * ye && (ze = tt[++oe]), ht[de] = ze;
                            oe < tt.length - 1 && (ht[de - 1] = tt[tt.length - 2])
                        }
                        return this.ease = function(M) {
                            var I = ht[M * mt | 0] || ht[mt - 1];
                            return I.nx < M && (I = I.n), I.y + (M - I.x) / I.cx * I.cy
                        }, this.ease.custom = this, this.id && A && A.registerEase(this.id, this.ease), this
                    }, K.getSVGData = function(G) {
                        return re.getSVGData(this, G)
                    }, re.create = function(G, ce, le) {
                        return new re(G, ce, le).ease
                    }, re.register = function(G) {
                        A = G, k()
                    }, re.get = function(G) {
                        return A.parseEase(G)
                    }, re.getSVGData = function(G, ce) {
                        ce = ce || {};
                        var le = ce.width || 100,
                            ve = ce.height || 100,
                            tt = ce.x || 0,
                            ht = (ce.y || 0) + ve,
                            lt = A.utils.toArray(ce.path)[0],
                            _t, mt, Pt, St, de, ye, oe, ze, Se, Ke;
                        if (ce.invert && (ve = -ve, ht = 0), typeof G == "string" && (G = A.parseEase(G)), G.custom && (G = G.custom), G instanceof re) _t = j(E([G.segment], le, 0, 0, -ve, tt, ht));
                        else {
                            for (_t = [tt, ht], oe = Math.max(5, (ce.precision || 1) * 200), St = 1 / oe, oe += 2, ze = 5 / oe, Se = X(tt + St * le), Ke = X(ht + G(St) * -ve), mt = (Ke - ht) / (Se - tt), Pt = 2; Pt < oe; Pt++) de = X(tt + Pt * St * le), ye = X(ht + G(Pt * St) * -ve), (Math.abs((ye - Ke) / (de - Se) - mt) > ze || Pt === oe - 1) && (_t.push(Se, Ke), mt = (ye - Ke) / (de - Se)), Se = de, Ke = ye;
                            _t = "M" + _t.join(",")
                        }
                        return lt && lt.setAttribute("d", _t), _t
                    }, re
                }();
            ne.version = "3.13.0", ne.headless = !0, w() && A.registerPlugin(ne), n.CustomEase = ne, n.default = ne, Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(Dl, Dl.exports)), Dl.exports
}
var oS = sS();
const Lu = Go(oS);
var xl = {
    exports: {}
};
/*!
 * SplitText 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.
 * @author: Jack Doyle
 */
var aS = xl.exports,
    zp;

function lS() {
    return zp || (zp = 1, function(e, t) {
        (function(n, r) {
            r(t)
        })(aS, function(n) {
            let r, i, s, a = () => s || X.register(window.gsap),
                c = typeof Intl < "u" ? new Intl.Segmenter : 0,
                u = J => typeof J == "string" ? u(document.querySelectorAll(J)) : "length" in J ? Array.from(J) : [J],
                p = J => u(J).filter(xe => xe instanceof HTMLElement),
                d = [],
                g = function() {},
                m = /\s+/g,
                E = new RegExp("\\p{RI}\\p{RI}|\\p{Emoji}(\\p{EMod}|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?(\\u{200D}\\p{Emoji}(\\p{EMod}|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?)*|.", "gu"),
                L = {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                },
                b = (J, xe) => {
                    if (xe) {
                        let he = new Set(J.join("").match(xe) || d),
                            me = J.length,
                            Q, ne, re, K;
                        if (he.size)
                            for (; --me > -1;) {
                                ne = J[me];
                                for (re of he)
                                    if (re.startsWith(ne) && re.length > ne.length) {
                                        for (Q = 0, K = ne; re.startsWith(K += J[me + ++Q]) && K.length < re.length;);
                                        if (Q && K.length === re.length) {
                                            J[me] = re, J.splice(me + 1, Q);
                                            break
                                        }
                                    }
                            }
                    }
                    return J
                },
                j = J => window.getComputedStyle(J).display === "inline" && (J.style.display = "inline-block"),
                A = (J, xe, he) => xe.insertBefore(typeof J == "string" ? document.createTextNode(J) : J, he),
                $ = (J, xe, he) => {
                    let me = xe[J + "sClass"] || "",
                        {
                            tag: Q = "div",
                            aria: ne = "auto",
                            propIndex: re = !1
                        } = xe,
                        K = J === "line" ? "block" : "inline-block",
                        te = me.indexOf("++") > -1,
                        G = ce => {
                            let le = document.createElement(Q),
                                ve = he.length + 1;
                            return me && (le.className = me + (te ? " " + me + ve : "")), re && le.style.setProperty("--" + J, ve + ""), ne !== "none" && le.setAttribute("aria-hidden", "true"), Q !== "span" && (le.style.position = "relative", le.style.display = K), le.textContent = ce, he.push(le), le
                        };
                    return te && (me = me.replace("++", "")), G.collection = he, G
                },
                w = (J, xe, he, me) => {
                    let Q = $("line", he, me),
                        ne = window.getComputedStyle(J).textAlign || "left";
                    return (re, K) => {
                        let te = Q("");
                        for (te.style.textAlign = ne, J.insertBefore(te, xe[re]); re < K; re++) te.appendChild(xe[re]);
                        te.normalize()
                    }
                },
                k = (J, xe, he, me, Q, ne, re, K, te, G) => {
                    var ce;
                    let le = Array.from(J.childNodes),
                        ve = 0,
                        {
                            wordDelimiter: tt,
                            reduceWhiteSpace: ht = !0,
                            prepareText: lt
                        } = xe,
                        _t = J.getBoundingClientRect(),
                        mt = _t,
                        Pt = !ht && window.getComputedStyle(J).whiteSpace.substring(0, 3) === "pre",
                        St = 0,
                        de = he.collection,
                        ye, oe, ze, Se, Ke, M, I, fe, Oe, Te, Ie, st, nt, je, We, bt, Ze, wt;
                    for (typeof tt == "object" ? (ze = tt.delimiter || tt, oe = tt.replaceWith || "") : oe = tt === "" ? "" : tt || " ", ye = oe !== " "; ve < le.length; ve++)
                        if (Se = le[ve], Se.nodeType === 3) {
                            for (We = Se.textContent || "", ht ? We = We.replace(m, " ") : Pt && (We = We.replace(/\n/g, oe + `
`)), lt && (We = lt(We, J)), Se.textContent = We, Ke = oe || ze ? We.split(ze || oe) : We.match(K) || d, Ze = Ke[Ke.length - 1], fe = ye ? Ze.slice(-1) === " " : !Ze, Ze || Ke.pop(), mt = _t, I = ye ? Ke[0].charAt(0) === " " : !Ke[0], I && A(" ", J, Se), Ke[0] || Ke.shift(), b(Ke, te), ne && G || (Se.textContent = ""), Oe = 1; Oe <= Ke.length; Oe++)
                                if (bt = Ke[Oe - 1], !ht && Pt && bt.charAt(0) === `
` && ((ce = Se.previousSibling) == null || ce.remove(), A(document.createElement("br"), J, Se), bt = bt.slice(1)), !ht && bt === "") A(oe, J, Se);
                                else if (bt === " ") J.insertBefore(document.createTextNode(" "), Se);
                            else {
                                if (ye && bt.charAt(0) === " " && A(" ", J, Se), St && Oe === 1 && !I && de.indexOf(St.parentNode) > -1 ? (M = de[de.length - 1], M.appendChild(document.createTextNode(me ? "" : bt))) : (M = he(me ? "" : bt), A(M, J, Se), St && Oe === 1 && !I && M.insertBefore(St, M.firstChild)), me)
                                    for (Ie = c ? b([...c.segment(bt)].map(Et => Et.segment), te) : bt.match(K) || d, wt = 0; wt < Ie.length; wt++) M.appendChild(Ie[wt] === " " ? document.createTextNode(" ") : me(Ie[wt]));
                                if (ne && G) {
                                    if (We = Se.textContent = We.substring(bt.length + 1, We.length), Te = M.getBoundingClientRect(), Te.top > mt.top && Te.left <= mt.left) {
                                        for (st = J.cloneNode(), nt = J.childNodes[0]; nt && nt !== M;) je = nt, nt = nt.nextSibling, st.appendChild(je);
                                        J.parentNode.insertBefore(st, J), Q && j(st)
                                    }
                                    mt = Te
                                }(Oe < Ke.length || fe) && A(Oe >= Ke.length ? " " : ye && bt.slice(-1) === " " ? " " + oe : oe, J, Se)
                            }
                            J.removeChild(Se), St = 0
                        } else Se.nodeType === 1 && (re && re.indexOf(Se) > -1 ? (de.indexOf(Se.previousSibling) > -1 && de[de.length - 1].appendChild(Se), St = Se) : (k(Se, xe, he, me, Q, ne, re, K, te, !0), St = 0), Q && j(Se))
                };
            const S = class X0 {
                constructor(xe, he) {
                    this.isSplit = !1, a(), this.elements = p(xe), this.chars = [], this.words = [], this.lines = [], this.masks = [], this.vars = he, this._split = () => this.isSplit && this.split(this.vars);
                    let me = [],
                        Q, ne = () => {
                            let re = me.length,
                                K;
                            for (; re--;) {
                                K = me[re];
                                let te = K.element.offsetWidth;
                                if (te !== K.width) {
                                    K.width = te, this._split();
                                    return
                                }
                            }
                        };
                    this._data = {
                        orig: me,
                        obs: typeof ResizeObserver < "u" && new ResizeObserver(() => {
                            clearTimeout(Q), Q = setTimeout(ne, 200)
                        })
                    }, g(this), this.split(he)
                }
                split(xe) {
                    this.isSplit && this.revert(), this.vars = xe = xe || this.vars || {};
                    let {
                        type: he = "chars,words,lines",
                        aria: me = "auto",
                        deepSlice: Q = !0,
                        smartWrap: ne,
                        onSplit: re,
                        autoSplit: K = !1,
                        specialChars: te,
                        mask: G
                    } = this.vars, ce = he.indexOf("lines") > -1, le = he.indexOf("chars") > -1, ve = he.indexOf("words") > -1, tt = le && !ve && !ce, ht = te && ("push" in te ? new RegExp("(?:" + te.join("|") + ")", "gu") : te), lt = ht ? new RegExp(ht.source + "|" + E.source, "gu") : E, _t = !!xe.ignore && p(xe.ignore), {
                        orig: mt,
                        animTime: Pt,
                        obs: St
                    } = this._data, de;
                    return (le || ve || ce) && (this.elements.forEach((ye, oe) => {
                        mt[oe] = {
                            element: ye,
                            html: ye.innerHTML,
                            ariaL: ye.getAttribute("aria-label"),
                            ariaH: ye.getAttribute("aria-hidden")
                        }, me === "auto" ? ye.setAttribute("aria-label", (ye.textContent || "").trim()) : me === "hidden" && ye.setAttribute("aria-hidden", "true");
                        let ze = [],
                            Se = [],
                            Ke = [],
                            M = le ? $("char", xe, ze) : null,
                            I = $("word", xe, Se),
                            fe, Oe, Te, Ie;
                        if (k(ye, xe, I, M, tt, Q && (ce || tt), _t, lt, ht, !1), ce) {
                            let st = u(ye.childNodes),
                                nt = w(ye, st, xe, Ke),
                                je, We = [],
                                bt = 0,
                                Ze = st.map(Et => Et.nodeType === 1 ? Et.getBoundingClientRect() : L),
                                wt = L;
                            for (fe = 0; fe < st.length; fe++) je = st[fe], je.nodeType === 1 && (je.nodeName === "BR" ? (We.push(je), nt(bt, fe + 1), bt = fe + 1, wt = Ze[bt]) : (fe && Ze[fe].top > wt.top && Ze[fe].left <= wt.left && (nt(bt, fe), bt = fe), wt = Ze[fe]));
                            bt < fe && nt(bt, fe), We.forEach(Et => {
                                var Ot;
                                return (Ot = Et.parentNode) == null ? void 0 : Ot.removeChild(Et)
                            })
                        }
                        if (!ve) {
                            for (fe = 0; fe < Se.length; fe++)
                                if (Oe = Se[fe], le || !Oe.nextSibling || Oe.nextSibling.nodeType !== 3)
                                    if (ne && !ce) {
                                        for (Te = document.createElement("span"), Te.style.whiteSpace = "nowrap"; Oe.firstChild;) Te.appendChild(Oe.firstChild);
                                        Oe.replaceWith(Te)
                                    } else Oe.replaceWith(...Oe.childNodes);
                            else Ie = Oe.nextSibling, Ie && Ie.nodeType === 3 && (Ie.textContent = (Oe.textContent || "") + (Ie.textContent || ""), Oe.remove());
                            Se.length = 0, ye.normalize()
                        }
                        this.lines.push(...Ke), this.words.push(...Se), this.chars.push(...ze)
                    }), G && this[G] && this.masks.push(...this[G].map(ye => {
                        let oe = ye.cloneNode();
                        return ye.replaceWith(oe), oe.appendChild(ye), ye.className && (oe.className = ye.className.replace(/(\b\w+\b)/g, "$1-mask")), oe.style.overflow = "clip", oe
                    }))), this.isSplit = !0, i && (K ? i.addEventListener("loadingdone", this._split) : i.status === "loading" && console.warn("SplitText called before fonts loaded")), (de = re && re(this)) && de.totalTime && (this._data.anim = Pt ? de.totalTime(Pt) : de), ce && K && this.elements.forEach((ye, oe) => {
                        mt[oe].width = ye.offsetWidth, St && St.observe(ye)
                    }), this
                }
                revert() {
                    var xe, he;
                    let {
                        orig: me,
                        anim: Q,
                        obs: ne
                    } = this._data;
                    return ne && ne.disconnect(), me.forEach(({
                        element: re,
                        html: K,
                        ariaL: te,
                        ariaH: G
                    }) => {
                        re.innerHTML = K, te ? re.setAttribute("aria-label", te) : re.removeAttribute("aria-label"), G ? re.setAttribute("aria-hidden", G) : re.removeAttribute("aria-hidden")
                    }), this.chars.length = this.words.length = this.lines.length = me.length = this.masks.length = 0, this.isSplit = !1, i == null || i.removeEventListener("loadingdone", this._split), Q && (this._data.animTime = Q.totalTime(), Q.revert()), (he = (xe = this.vars).onRevert) == null || he.call(xe, this), this
                }
                static create(xe, he) {
                    return new X0(xe, he)
                }
                static register(xe) {
                    r = r || xe || window.gsap, r && (u = r.utils.toArray, g = r.core.context || g), !s && window.innerWidth > 0 && (i = document.fonts, s = !0)
                }
            };
            S.version = "3.13.0";
            let X = S;
            n.SplitText = X, n.default = X, Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(xl, xl.exports)), xl.exports
}
var uS = lS();
const hh = Go(uS);
var El = {
        exports: {}
    },
    cS = El.exports,
    jp;

function fS() {
    return jp || (jp = 1, function(e, t) {
        (function(n, r) {
            r(t)
        })(cS, function(n) {
            /*!
             * DrawSVGPlugin 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var r, i, s, a, c, u, p, d, g = function() {
                    return typeof window < "u"
                },
                m = function() {
                    return r || g() && (r = window.gsap) && r.registerPlugin && r
                },
                E = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
                L = {
                    rect: ["width", "height"],
                    circle: ["r", "r"],
                    ellipse: ["rx", "ry"],
                    line: ["x2", "y2"]
                },
                b = function(K) {
                    return Math.round(K * 1e4) / 1e4
                },
                j = function(K) {
                    return parseFloat(K) || 0
                },
                A = function(K, te) {
                    var G = j(K);
                    return ~K.indexOf("%") ? G / 100 * te : G
                },
                $ = function(K, te) {
                    return j(K.getAttribute(te))
                },
                w = Math.sqrt,
                k = function(K, te, G, ce, le, ve) {
                    return w(Math.pow((j(G) - j(K)) * le, 2) + Math.pow((j(ce) - j(te)) * ve, 2))
                },
                S = function(K) {
                    return console.warn(K)
                },
                X = function(K) {
                    return K.getAttribute("vector-effect") === "non-scaling-stroke"
                },
                J = 1,
                xe = function(K, te, G) {
                    var ce = K.indexOf(" "),
                        le, ve;
                    return ce < 0 ? (le = G !== void 0 ? G + "" : K, ve = K) : (le = K.substr(0, ce), ve = K.substr(ce + 1)), le = A(le, te), ve = A(ve, te), le > ve ? [ve, le] : [le, ve]
                },
                he = function(K) {
                    if (K = i(K)[0], !K) return 0;
                    var te = K.tagName.toLowerCase(),
                        G = K.style,
                        ce = 1,
                        le = 1,
                        ve, tt, ht, lt, _t, mt, Pt;
                    X(K) && (le = K.getScreenCTM(), ce = w(le.a * le.a + le.b * le.b), le = w(le.d * le.d + le.c * le.c));
                    try {
                        tt = K.getBBox()
                    } catch {
                        S("Some browsers won't measure invisible elements (like display:none or masks inside defs).")
                    }
                    var St = tt || {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        de = St.x,
                        ye = St.y,
                        oe = St.width,
                        ze = St.height;
                    if ((!tt || !oe && !ze) && L[te] && (oe = $(K, L[te][0]), ze = $(K, L[te][1]), te !== "rect" && te !== "line" && (oe *= 2, ze *= 2), te === "line" && (de = $(K, "x1"), ye = $(K, "y1"), oe = Math.abs(oe - de), ze = Math.abs(ze - ye))), te === "path") lt = G.strokeDasharray, G.strokeDasharray = "none", ve = K.getTotalLength() || 0, b(ce) !== b(le) && !u && (u = 1) && S("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."), ve *= (ce + le) / 2, G.strokeDasharray = lt;
                    else if (te === "rect") ve = oe * 2 * ce + ze * 2 * le;
                    else if (te === "line") ve = k(de, ye, de + oe, ye + ze, ce, le);
                    else if (te === "polyline" || te === "polygon")
                        for (ht = K.getAttribute("points").match(E) || [], te === "polygon" && ht.push(ht[0], ht[1]), ve = 0, _t = 2; _t < ht.length; _t += 2) ve += k(ht[_t - 2], ht[_t - 1], ht[_t], ht[_t + 1], ce, le) || 0;
                    else(te === "circle" || te === "ellipse") && (mt = oe / 2 * ce, Pt = ze / 2 * le, ve = Math.PI * (3 * (mt + Pt) - w((3 * mt + Pt) * (mt + 3 * Pt))));
                    return ve || 0
                },
                me = function(K, te) {
                    if (K = i(K)[0], !K) return [0, 0];
                    te || (te = he(K) + 1);
                    var G = s.getComputedStyle(K),
                        ce = G.strokeDasharray || "",
                        le = j(G.strokeDashoffset),
                        ve = ce.indexOf(",");
                    return ve < 0 && (ve = ce.indexOf(" ")), ce = ve < 0 ? te : j(ce.substr(0, ve)), ce > te && (ce = te), [-le || 0, ce - le || 0]
                },
                Q = function() {
                    g() && (s = window, c = r = m(), i = r.utils.toArray, p = r.core.getStyleSaver, d = r.core.reverting || function() {}, a = ((s.navigator || {}).userAgent || "").indexOf("Edge") !== -1)
                },
                ne = {
                    version: "3.13.0",
                    name: "drawSVG",
                    register: function(K) {
                        r = K, Q()
                    },
                    init: function(K, te, G, ce, le) {
                        if (!K.getBBox) return !1;
                        c || Q();
                        var ve = he(K),
                            tt, ht, lt;
                        return this.styles = p && p(K, "strokeDashoffset,strokeDasharray,strokeMiterlimit"), this.tween = G, this._style = K.style, this._target = K, te + "" == "true" ? te = "0 100%" : te ? (te + "").indexOf(" ") === -1 && (te = "0 " + te) : te = "0 0", tt = me(K, ve), ht = xe(te, ve, tt[0]), this._length = b(ve), this._dash = b(tt[1] - tt[0]), this._offset = b(-tt[0]), this._dashPT = this.add(this, "_dash", this._dash, b(ht[1] - ht[0]), 0, 0, 0, 0, 0, 1), this._offsetPT = this.add(this, "_offset", this._offset, b(-ht[0]), 0, 0, 0, 0, 0, 1), a && (lt = s.getComputedStyle(K), lt.strokeLinecap !== lt.strokeLinejoin && (ht = j(lt.strokeMiterlimit), this.add(K.style, "strokeMiterlimit", ht, ht + .01))), this._live = X(K) || ~(te + "").indexOf("live"), this._nowrap = ~(te + "").indexOf("nowrap"), this._props.push("drawSVG"), J
                    },
                    render: function(K, te) {
                        if (te.tween._time || !d()) {
                            var G = te._pt,
                                ce = te._style,
                                le, ve, tt, ht;
                            if (G) {
                                for (te._live && (le = he(te._target), le !== te._length && (ve = le / te._length, te._length = le, te._offsetPT && (te._offsetPT.s *= ve, te._offsetPT.c *= ve), te._dashPT ? (te._dashPT.s *= ve, te._dashPT.c *= ve) : te._dash *= ve)); G;) G.r(K, G.d), G = G._next;
                                tt = te._dash || K && K !== 1 && 1e-4 || 0, le = te._length - tt + .1, ht = te._offset, tt && ht && tt + Math.abs(ht % te._length) > te._length - .05 && (ht += ht < 0 ? .005 : -.005) && (le += .005), ce.strokeDashoffset = tt ? ht : ht + .001, ce.strokeDasharray = le < .1 ? "none" : tt ? tt + "px," + (te._nowrap ? 999999 : le) + "px" : "0px, 999999px"
                            }
                        } else te.styles.revert()
                    },
                    getLength: he,
                    getPosition: me
                };
            m() && r.registerPlugin(ne), n.DrawSVGPlugin = ne, n.default = ne, Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(El, El.exports)), El.exports
}
var hS = fS();
const dS = Go(hS);
var Cl = {
        exports: {}
    },
    pS = Cl.exports,
    Up;

function gS() {
    return Up || (Up = 1, function(e, t) {
        (function(n, r) {
            r(t)
        })(pS, function(n) {
            var r = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
                i = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
                s = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
                a = /(^[#\.][a-z]|[a-y][a-z])/i,
                c = Math.PI / 180,
                u = Math.sin,
                p = Math.cos,
                d = Math.abs,
                g = Math.sqrt,
                m = function(Y) {
                    return typeof Y == "string"
                },
                E = function(Y) {
                    return typeof Y == "number"
                },
                L = 1e5,
                b = function(Y) {
                    return Math.round(Y * L) / L || 0
                };

            function j(ft) {
                ft = m(ft) && a.test(ft) && document.querySelector(ft) || ft;
                var Y = ft.getAttribute ? ft : 0,
                    ie;
                return Y && (ft = ft.getAttribute("d")) ? (Y._gsPath || (Y._gsPath = {}), ie = Y._gsPath[ft], ie && !ie._dirty ? ie : Y._gsPath[ft] = J(ft)) : ft ? m(ft) ? J(ft) : E(ft[0]) ? [ft] : ft : console.warn("Expecting a <path> element or an SVG path data string")
            }

            function A(ft) {
                var Y = 0,
                    ie;
                for (ft.reverse(); Y < ft.length; Y += 2) ie = ft[Y], ft[Y] = ft[Y + 1], ft[Y + 1] = ie;
                ft.reversed = !ft.reversed
            }
            var $ = function(Y, ie) {
                    var ge = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                        ke = [].slice.call(Y.attributes),
                        Le = ke.length,
                        Ee;
                    for (ie = "," + ie + ","; --Le > -1;) Ee = ke[Le].nodeName.toLowerCase(), ie.indexOf("," + Ee + ",") < 0 && ge.setAttributeNS(null, Ee, ke[Le].nodeValue);
                    return ge
                },
                w = {
                    rect: "rx,ry,x,y,width,height",
                    circle: "r,cx,cy",
                    ellipse: "rx,ry,cx,cy",
                    line: "x1,x2,y1,y2"
                },
                k = function(Y, ie) {
                    for (var ge = ie ? ie.split(",") : [], ke = {}, Le = ge.length; --Le > -1;) ke[ge[Le]] = +Y.getAttribute(ge[Le]) || 0;
                    return ke
                };

            function S(ft, Y) {
                var ie = ft.tagName.toLowerCase(),
                    ge = .552284749831,
                    ke, Le, Ee, Ne, qe, Ve, yt, rt, He, ot, Mt, ut, pt, Qe, Re, T, z, R, ee, ae, Fe, at;
                return ie === "path" || !ft.getBBox ? ft : (Ve = $(ft, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), at = k(ft, w[ie]), ie === "rect" ? (Ne = at.rx, qe = at.ry || Ne, Le = at.x, Ee = at.y, ot = at.width - Ne * 2, Mt = at.height - qe * 2, Ne || qe ? (ut = Le + Ne * (1 - ge), pt = Le + Ne, Qe = pt + ot, Re = Qe + Ne * ge, T = Qe + Ne, z = Ee + qe * (1 - ge), R = Ee + qe, ee = R + Mt, ae = ee + qe * ge, Fe = ee + qe, ke = "M" + T + "," + R + " V" + ee + " C" + [T, ae, Re, Fe, Qe, Fe, Qe - (Qe - pt) / 3, Fe, pt + (Qe - pt) / 3, Fe, pt, Fe, ut, Fe, Le, ae, Le, ee, Le, ee - (ee - R) / 3, Le, R + (ee - R) / 3, Le, R, Le, z, ut, Ee, pt, Ee, pt + (Qe - pt) / 3, Ee, Qe - (Qe - pt) / 3, Ee, Qe, Ee, Re, Ee, T, z, T, R].join(",") + "z") : ke = "M" + (Le + ot) + "," + Ee + " v" + Mt + " h" + -ot + " v" + -Mt + " h" + ot + "z") : ie === "circle" || ie === "ellipse" ? (ie === "circle" ? (Ne = qe = at.r, rt = Ne * ge) : (Ne = at.rx, qe = at.ry, rt = qe * ge), Le = at.cx, Ee = at.cy, yt = Ne * ge, ke = "M" + (Le + Ne) + "," + Ee + " C" + [Le + Ne, Ee + rt, Le + yt, Ee + qe, Le, Ee + qe, Le - yt, Ee + qe, Le - Ne, Ee + rt, Le - Ne, Ee, Le - Ne, Ee - rt, Le - yt, Ee - qe, Le, Ee - qe, Le + yt, Ee - qe, Le + Ne, Ee - rt, Le + Ne, Ee].join(",") + "z") : ie === "line" ? ke = "M" + at.x1 + "," + at.y1 + " L" + at.x2 + "," + at.y2 : (ie === "polyline" || ie === "polygon") && (He = (ft.getAttribute("points") + "").match(i) || [], Le = He.shift(), Ee = He.shift(), ke = "M" + Le + "," + Ee + " L" + He.join(","), ie === "polygon" && (ke += "," + Le + "," + Ee + "z")), Ve.setAttribute("d", xe(Ve._gsRawPath = J(ke))), Y && ft.parentNode && (ft.parentNode.insertBefore(Ve, ft), ft.parentNode.removeChild(ft)), Ve)
            }

            function X(ft, Y, ie, ge, ke, Le, Ee, Ne, qe) {
                if (!(ft === Ne && Y === qe)) {
                    ie = d(ie), ge = d(ge);
                    var Ve = ke % 360 * c,
                        yt = p(Ve),
                        rt = u(Ve),
                        He = Math.PI,
                        ot = He * 2,
                        Mt = (ft - Ne) / 2,
                        ut = (Y - qe) / 2,
                        pt = yt * Mt + rt * ut,
                        Qe = -rt * Mt + yt * ut,
                        Re = pt * pt,
                        T = Qe * Qe,
                        z = Re / (ie * ie) + T / (ge * ge);
                    z > 1 && (ie = g(z) * ie, ge = g(z) * ge);
                    var R = ie * ie,
                        ee = ge * ge,
                        ae = (R * ee - R * T - ee * Re) / (R * T + ee * Re);
                    ae < 0 && (ae = 0);
                    var Fe = (Le === Ee ? -1 : 1) * g(ae),
                        at = Fe * (ie * Qe / ge),
                        O = Fe * -(ge * pt / ie),
                        y = (ft + Ne) / 2,
                        x = (Y + qe) / 2,
                        P = y + (yt * at - rt * O),
                        B = x + (rt * at + yt * O),
                        q = (pt - at) / ie,
                        ue = (Qe - O) / ge,
                        be = (-pt - at) / ie,
                        Ce = (-Qe - O) / ge,
                        se = q * q + ue * ue,
                        Ue = (ue < 0 ? -1 : 1) * Math.acos(q / g(se)),
                        _e = (q * Ce - ue * be < 0 ? -1 : 1) * Math.acos((q * be + ue * Ce) / g(se * (be * be + Ce * Ce)));
                    isNaN(_e) && (_e = He), !Ee && _e > 0 ? _e -= ot : Ee && _e < 0 && (_e += ot), Ue %= ot, _e %= ot;
                    var Xe = Math.ceil(d(_e) / (ot / 4)),
                        Je = [],
                        ct = _e / Xe,
                        dt = 4 / 3 * u(ct / 2) / (1 + p(ct / 2)),
                        Bt = yt * ie,
                        Lt = rt * ie,
                        Tt = rt * -ge,
                        It = yt * ge,
                        Ft;
                    for (Ft = 0; Ft < Xe; Ft++) ke = Ue + Ft * ct, pt = p(ke), Qe = u(ke), q = p(ke += ct), ue = u(ke), Je.push(pt - dt * Qe, Qe + dt * pt, q + dt * ue, ue - dt * q, q, ue);
                    for (Ft = 0; Ft < Je.length; Ft += 2) pt = Je[Ft], Qe = Je[Ft + 1], Je[Ft] = pt * Bt + Qe * Tt + P, Je[Ft + 1] = pt * Lt + Qe * It + B;
                    return Je[Ft - 2] = Ne, Je[Ft - 1] = qe, Je
                }
            }

            function J(ft) {
                var Y = (ft + "").replace(s, function(at) {
                        var O = +at;
                        return O < 1e-4 && O > -1e-4 ? 0 : O
                    }).match(r) || [],
                    ie = [],
                    ge = 0,
                    ke = 0,
                    Le = 2 / 3,
                    Ee = Y.length,
                    Ne = 0,
                    qe = "ERROR: malformed path: " + ft,
                    Ve, yt, rt, He, ot, Mt, ut, pt, Qe, Re, T, z, R, ee, ae, Fe = function(O, y, x, P) {
                        Re = (x - O) / 3, T = (P - y) / 3, ut.push(O + Re, y + T, x - Re, P - T, x, P)
                    };
                if (!ft || !isNaN(Y[0]) || isNaN(Y[1])) return console.log(qe), ie;
                for (Ve = 0; Ve < Ee; Ve++)
                    if (R = ot, isNaN(Y[Ve]) ? (ot = Y[Ve].toUpperCase(), Mt = ot !== Y[Ve]) : Ve--, rt = +Y[Ve + 1], He = +Y[Ve + 2], Mt && (rt += ge, He += ke), Ve || (pt = rt, Qe = He), ot === "M") ut && (ut.length < 8 ? ie.length -= 1 : Ne += ut.length), ge = pt = rt, ke = Qe = He, ut = [rt, He], ie.push(ut), Ve += 2, ot = "L";
                    else if (ot === "C") ut || (ut = [0, 0]), Mt || (ge = ke = 0), ut.push(rt, He, ge + Y[Ve + 3] * 1, ke + Y[Ve + 4] * 1, ge += Y[Ve + 5] * 1, ke += Y[Ve + 6] * 1), Ve += 6;
                else if (ot === "S") Re = ge, T = ke, (R === "C" || R === "S") && (Re += ge - ut[ut.length - 4], T += ke - ut[ut.length - 3]), Mt || (ge = ke = 0), ut.push(Re, T, rt, He, ge += Y[Ve + 3] * 1, ke += Y[Ve + 4] * 1), Ve += 4;
                else if (ot === "Q") Re = ge + (rt - ge) * Le, T = ke + (He - ke) * Le, Mt || (ge = ke = 0), ge += Y[Ve + 3] * 1, ke += Y[Ve + 4] * 1, ut.push(Re, T, ge + (rt - ge) * Le, ke + (He - ke) * Le, ge, ke), Ve += 4;
                else if (ot === "T") Re = ge - ut[ut.length - 4], T = ke - ut[ut.length - 3], ut.push(ge + Re, ke + T, rt + (ge + Re * 1.5 - rt) * Le, He + (ke + T * 1.5 - He) * Le, ge = rt, ke = He), Ve += 2;
                else if (ot === "H") Fe(ge, ke, ge = rt, ke), Ve += 1;
                else if (ot === "V") Fe(ge, ke, ge, ke = rt + (Mt ? ke - ge : 0)), Ve += 1;
                else if (ot === "L" || ot === "Z") ot === "Z" && (rt = pt, He = Qe, ut.closed = !0), (ot === "L" || d(ge - rt) > .5 || d(ke - He) > .5) && (Fe(ge, ke, rt, He), ot === "L" && (Ve += 2)), ge = rt, ke = He;
                else if (ot === "A") {
                    if (ee = Y[Ve + 4], ae = Y[Ve + 5], Re = Y[Ve + 6], T = Y[Ve + 7], yt = 7, ee.length > 1 && (ee.length < 3 ? (T = Re, Re = ae, yt--) : (T = ae, Re = ee.substr(2), yt -= 2), ae = ee.charAt(1), ee = ee.charAt(0)), z = X(ge, ke, +Y[Ve + 1], +Y[Ve + 2], +Y[Ve + 3], +ee, +ae, (Mt ? ge : 0) + Re * 1, (Mt ? ke : 0) + T * 1), Ve += yt, z)
                        for (yt = 0; yt < z.length; yt++) ut.push(z[yt]);
                    ge = ut[ut.length - 2], ke = ut[ut.length - 1]
                } else console.log(qe);
                return Ve = ut.length, Ve < 6 ? (ie.pop(), Ve = 0) : ut[0] === ut[Ve - 2] && ut[1] === ut[Ve - 1] && (ut.closed = !0), ie.totalPoints = Ne + Ve, ie
            }

            function xe(ft) {
                E(ft[0]) && (ft = [ft]);
                var Y = "",
                    ie = ft.length,
                    ge, ke, Le, Ee;
                for (ke = 0; ke < ie; ke++) {
                    for (Ee = ft[ke], Y += "M" + b(Ee[0]) + "," + b(Ee[1]) + " C", ge = Ee.length, Le = 2; Le < ge; Le++) Y += b(Ee[Le++]) + "," + b(Ee[Le++]) + " " + b(Ee[Le++]) + "," + b(Ee[Le++]) + " " + b(Ee[Le++]) + "," + b(Ee[Le]) + " ";
                    Ee.closed && (Y += "z")
                }
                return Y
            }
            /*!
             * MorphSVGPlugin 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var he, me, Q, ne, re, K = function() {
                    return he || typeof window < "u" && (he = window.gsap) && he.registerPlugin && he
                },
                te = function(Y) {
                    return typeof Y == "function"
                },
                G = Math.atan2,
                ce = Math.cos,
                le = Math.sin,
                ve = Math.sqrt,
                tt = Math.PI,
                ht = tt * 2,
                lt = tt * .3,
                _t = tt * .7,
                mt = 1e20,
                Pt = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
                St = /(^[#\.][a-z]|[a-y][a-z])/i,
                de = /[achlmqstvz]/i,
                ye = function(Y) {
                    return console && console.warn(Y)
                },
                oe = 1,
                ze = function(Y) {
                    var ie = Y.length,
                        ge = 0,
                        ke = 0,
                        Le;
                    for (Le = 0; Le < ie; Le++) ge += Y[Le++], ke += Y[Le];
                    return [ge / (ie / 2), ke / (ie / 2)]
                },
                Se = function(Y) {
                    var ie = Y.length,
                        ge = Y[0],
                        ke = ge,
                        Le = Y[1],
                        Ee = Le,
                        Ne, qe, Ve;
                    for (Ve = 6; Ve < ie; Ve += 6) Ne = Y[Ve], qe = Y[Ve + 1], Ne > ge ? ge = Ne : Ne < ke && (ke = Ne), qe > Le ? Le = qe : qe < Ee && (Ee = qe);
                    return Y.centerX = (ge + ke) / 2, Y.centerY = (Le + Ee) / 2, Y.size = (ge - ke) * (Le - Ee)
                },
                Ke = function(Y, ie) {
                    ie === void 0 && (ie = 3);
                    for (var ge = Y.length, ke = Y[0][0], Le = ke, Ee = Y[0][1], Ne = Ee, qe = 1 / ie, Ve, yt, rt, He, ot, Mt, ut, pt, Qe, Re, T, z, R, ee, ae, Fe; --ge > -1;)
                        for (ot = Y[ge], Ve = ot.length, He = 6; He < Ve; He += 6)
                            for (Qe = ot[He], Re = ot[He + 1], T = ot[He + 2] - Qe, ee = ot[He + 3] - Re, z = ot[He + 4] - Qe, ae = ot[He + 5] - Re, R = ot[He + 6] - Qe, Fe = ot[He + 7] - Re, Mt = ie; --Mt > -1;) ut = qe * Mt, pt = 1 - ut, yt = (ut * ut * R + 3 * pt * (ut * z + pt * T)) * ut + Qe, rt = (ut * ut * Fe + 3 * pt * (ut * ae + pt * ee)) * ut + Re, yt > ke ? ke = yt : yt < Le && (Le = yt), rt > Ee ? Ee = rt : rt < Ne && (Ne = rt);
                    return Y.centerX = (ke + Le) / 2, Y.centerY = (Ee + Ne) / 2, Y.left = Le, Y.width = ke - Le, Y.top = Ne, Y.height = Ee - Ne, Y.size = (ke - Le) * (Ee - Ne)
                },
                M = function(Y, ie) {
                    return ie.length - Y.length
                },
                I = function(Y, ie) {
                    var ge = Y.size || Se(Y),
                        ke = ie.size || Se(ie);
                    return Math.abs(ke - ge) < (ge + ke) / 20 ? ie.centerX - Y.centerX || ie.centerY - Y.centerY : ke - ge
                },
                fe = function(Y, ie) {
                    var ge = Y.slice(0),
                        ke = Y.length,
                        Le = ke - 2,
                        Ee, Ne;
                    for (ie = ie | 0, Ee = 0; Ee < ke; Ee++) Ne = (Ee + ie) % Le, Y[Ee++] = ge[Ne], Y[Ee] = ge[Ne + 1]
                },
                Oe = function(Y, ie, ge, ke, Le) {
                    var Ee = Y.length,
                        Ne = 0,
                        qe = Ee - 2,
                        Ve, yt, rt, He;
                    for (ge *= 6, yt = 0; yt < Ee; yt += 6) Ve = (yt + ge) % qe, He = Y[Ve] - (ie[yt] - ke), rt = Y[Ve + 1] - (ie[yt + 1] - Le), Ne += ve(rt * rt + He * He);
                    return Ne
                },
                Te = function(Y, ie, ge) {
                    var ke = Y.length,
                        Le = ze(Y),
                        Ee = ze(ie),
                        Ne = Ee[0] - Le[0],
                        qe = Ee[1] - Le[1],
                        Ve = Oe(Y, ie, 0, Ne, qe),
                        yt = 0,
                        rt, He, ot;
                    for (ot = 6; ot < ke; ot += 6) He = Oe(Y, ie, ot / 6, Ne, qe), He < Ve && (Ve = He, yt = ot);
                    if (ge)
                        for (rt = Y.slice(0), A(rt), ot = 6; ot < ke; ot += 6) He = Oe(rt, ie, ot / 6, Ne, qe), He < Ve && (Ve = He, yt = -ot);
                    return yt / 6
                },
                Ie = function(Y, ie, ge) {
                    for (var ke = Y.length, Le = mt, Ee = 0, Ne = 0, qe, Ve, yt, rt, He, ot; --ke > -1;)
                        for (qe = Y[ke], ot = qe.length, He = 0; He < ot; He += 6) Ve = qe[He] - ie, yt = qe[He + 1] - ge, rt = ve(Ve * Ve + yt * yt), rt < Le && (Le = rt, Ee = qe[He], Ne = qe[He + 1]);
                    return [Ee, Ne]
                },
                st = function(Y, ie, ge, ke, Le, Ee) {
                    var Ne = ie.length,
                        qe = 0,
                        Ve = Math.min(Y.size || Se(Y), ie[ge].size || Se(ie[ge])) * ke,
                        yt = mt,
                        rt = Y.centerX + Le,
                        He = Y.centerY + Ee,
                        ot, Mt, ut, pt, Qe;
                    for (Mt = ge; Mt < Ne && (ot = ie[Mt].size || Se(ie[Mt]), !(ot < Ve)); Mt++) ut = ie[Mt].centerX - rt, pt = ie[Mt].centerY - He, Qe = ve(ut * ut + pt * pt), Qe < yt && (qe = Mt, yt = Qe);
                    return Qe = ie[qe], ie.splice(qe, 1), Qe
                },
                nt = function(Y, ie) {
                    var ge = 0,
                        ke = .999999,
                        Le = Y.length,
                        Ee = ie / ((Le - 2) / 6),
                        Ne, qe, Ve, yt, rt, He, ot, Mt, ut, pt, Qe, Re, T, z;
                    for (T = 2; T < Le; T += 6)
                        for (ge += Ee; ge > ke;) Ne = Y[T - 2], qe = Y[T - 1], Ve = Y[T], yt = Y[T + 1], rt = Y[T + 2], He = Y[T + 3], ot = Y[T + 4], Mt = Y[T + 5], z = 1 / ((Math.floor(ge) || 1) + 1), ut = Ne + (Ve - Ne) * z, Qe = Ve + (rt - Ve) * z, ut += (Qe - ut) * z, Qe += (rt + (ot - rt) * z - Qe) * z, pt = qe + (yt - qe) * z, Re = yt + (He - yt) * z, pt += (Re - pt) * z, Re += (He + (Mt - He) * z - Re) * z, Y.splice(T, 4, Ne + (Ve - Ne) * z, qe + (yt - qe) * z, ut, pt, ut + (Qe - ut) * z, pt + (Re - pt) * z, Qe, Re, rt + (ot - rt) * z, He + (Mt - He) * z), T += 6, Le += 6, ge--;
                    return Y
                },
                je = function(Y, ie, ge, ke, Le) {
                    var Ee = ie.length - Y.length,
                        Ne = Ee > 0 ? ie : Y,
                        qe = Ee > 0 ? Y : ie,
                        Ve = 0,
                        yt = ke === "complexity" ? M : I,
                        rt = ke === "position" ? 0 : typeof ke == "number" ? ke : .8,
                        He = qe.length,
                        ot = typeof ge == "object" && ge.push ? ge.slice(0) : [ge],
                        Mt = ot[0] === "reverse" || ot[0] < 0,
                        ut = ge === "log",
                        pt, Qe, Re, T, z, R, ee;
                    if (qe[0]) {
                        if (Ne.length > 1 && (Y.sort(yt), ie.sort(yt), R = Ne.size || Ke(Ne), R = qe.size || Ke(qe), R = Ne.centerX - qe.centerX, ee = Ne.centerY - qe.centerY, yt === I))
                            for (He = 0; He < qe.length; He++) Ne.splice(He, 0, st(qe[He], Ne, He, rt, R, ee));
                        if (Ee)
                            for (Ee < 0 && (Ee = -Ee), Ne[0].length > qe[0].length && nt(qe[0], (Ne[0].length - qe[0].length) / 6 | 0), He = qe.length; Ve < Ee;) T = Ne[He].size || Se(Ne[He]), Re = Ie(qe, Ne[He].centerX, Ne[He].centerY), T = Re[0], z = Re[1], qe[He++] = [T, z, T, z, T, z, T, z], qe.totalPoints += 8, Ve++;
                        for (He = 0; He < Y.length; He++) pt = ie[He], Qe = Y[He], Ee = pt.length - Qe.length, Ee < 0 ? nt(pt, -Ee / 6 | 0) : Ee > 0 && nt(Qe, Ee / 6 | 0), Mt && Le !== !1 && !Qe.reversed && A(Qe), ge = ot[He] || ot[He] === 0 ? ot[He] : "auto", ge && (Qe.closed || Math.abs(Qe[0] - Qe[Qe.length - 2]) < .5 && Math.abs(Qe[1] - Qe[Qe.length - 1]) < .5 ? ge === "auto" || ge === "log" ? (ot[He] = ge = Te(Qe, pt, !He || Le === !1), ge < 0 && (Mt = !0, A(Qe), ge = -ge), fe(Qe, ge * 6)) : ge !== "reverse" && (He && ge < 0 && A(Qe), fe(Qe, (ge < 0 ? -ge : ge) * 6)) : !Mt && (ge === "auto" && Math.abs(pt[0] - Qe[0]) + Math.abs(pt[1] - Qe[1]) + Math.abs(pt[pt.length - 2] - Qe[Qe.length - 2]) + Math.abs(pt[pt.length - 1] - Qe[Qe.length - 1]) > Math.abs(pt[0] - Qe[Qe.length - 2]) + Math.abs(pt[1] - Qe[Qe.length - 1]) + Math.abs(pt[pt.length - 2] - Qe[0]) + Math.abs(pt[pt.length - 1] - Qe[1]) || ge % 2) ? (A(Qe), ot[He] = -1, Mt = !0) : ge === "auto" ? ot[He] = 0 : ge === "reverse" && (ot[He] = -1), Qe.closed !== pt.closed && (Qe.closed = pt.closed = !1));
                        return ut && ye("shapeIndex:[" + ot.join(",") + "]"), Y.shapeIndex = ot, ot
                    }
                },
                We = function(Y, ie, ge, ke, Le) {
                    var Ee = J(Y[0]),
                        Ne = J(Y[1]);
                    je(Ee, Ne, ie || ie === 0 ? ie : "auto", ge, Le) && (Y[0] = xe(Ee), Y[1] = xe(Ne), (ke === "log" || ke === !0) && ye('precompile:["' + Y[0] + '","' + Y[1] + '"]'))
                },
                bt = function(Y, ie) {
                    if (!ie) return Y;
                    var ge = Y.match(Pt) || [],
                        ke = ge.length,
                        Le = "",
                        Ee, Ne, qe;
                    for (ie === "reverse" ? (Ne = ke - 1, Ee = -2) : (Ne = ((parseInt(ie, 10) || 0) * 2 + 1 + ke * 100) % ke, Ee = 2), qe = 0; qe < ke; qe += 2) Le += ge[Ne - 1] + "," + ge[Ne] + " ", Ne = (Ne + Ee) % ke;
                    return Le
                },
                Ze = function(Y, ie) {
                    var ge = 0,
                        ke = parseFloat(Y[0]),
                        Le = parseFloat(Y[1]),
                        Ee = ke + "," + Le + " ",
                        Ne = .999999,
                        qe, Ve, yt, rt, He, ot, Mt;
                    for (yt = Y.length, qe = ie * .5 / (yt * .5 - 1), Ve = 0; Ve < yt - 2; Ve += 2) {
                        if (ge += qe, ot = parseFloat(Y[Ve + 2]), Mt = parseFloat(Y[Ve + 3]), ge > Ne)
                            for (He = 1 / (Math.floor(ge) + 1), rt = 1; ge > Ne;) Ee += (ke + (ot - ke) * He * rt).toFixed(2) + "," + (Le + (Mt - Le) * He * rt).toFixed(2) + " ", ge--, rt++;
                        Ee += ot + "," + Mt + " ", ke = ot, Le = Mt
                    }
                    return Ee
                },
                wt = function(Y) {
                    var ie = Y[0].match(Pt) || [],
                        ge = Y[1].match(Pt) || [],
                        ke = ge.length - ie.length;
                    ke > 0 ? Y[0] = Ze(ie, ke) : Y[1] = Ze(ge, -ke)
                },
                Et = function(Y) {
                    return isNaN(Y) ? wt : function(ie) {
                        wt(ie), ie[1] = bt(ie[1], parseInt(Y, 10))
                    }
                },
                Ot = function(Y, ie, ge) {
                    var ke = typeof Y == "string",
                        Le, Ee;
                    return (!ke || St.test(Y) || (Y.match(Pt) || []).length < 3) && (Le = me(Y)[0], Le ? (Ee = (Le.nodeName + "").toUpperCase(), ie && Ee !== "PATH" && (Le = S(Le, !1), Ee = "PATH"), Y = Le.getAttribute(Ee === "PATH" ? "d" : "points") || "", Le === ge && (Y = Le.getAttributeNS(null, "data-original") || Y)) : (ye("WARNING: invalid morph to: " + Y), Y = !1)), Y
                },
                qt = function(Y, ie) {
                    for (var ge = Y.length, ke = .2 * (ie || 1), Le, Ee, Ne, qe, Ve, yt, rt, He, ot, Mt, ut, pt; --ge > -1;) {
                        for (Ee = Y[ge], ut = Ee.isSmooth = Ee.isSmooth || [0, 0, 0, 0], pt = Ee.smoothData = Ee.smoothData || [0, 0, 0, 0], ut.length = 4, He = Ee.length - 2, rt = 6; rt < He; rt += 6) Ne = Ee[rt] - Ee[rt - 2], qe = Ee[rt + 1] - Ee[rt - 1], Ve = Ee[rt + 2] - Ee[rt], yt = Ee[rt + 3] - Ee[rt + 1], ot = G(qe, Ne), Mt = G(yt, Ve), Le = Math.abs(ot - Mt) < ke, Le && (pt[rt - 2] = ot, pt[rt + 2] = Mt, pt[rt - 1] = ve(Ne * Ne + qe * qe), pt[rt + 3] = ve(Ve * Ve + yt * yt)), ut.push(Le, Le, 0, 0, Le, Le);
                        Ee[He] === Ee[0] && Ee[He + 1] === Ee[1] && (Ne = Ee[0] - Ee[He - 2], qe = Ee[1] - Ee[He - 1], Ve = Ee[2] - Ee[0], yt = Ee[3] - Ee[1], ot = G(qe, Ne), Mt = G(yt, Ve), Math.abs(ot - Mt) < ke && (pt[He - 2] = ot, pt[2] = Mt, pt[He - 1] = ve(Ne * Ne + qe * qe), pt[3] = ve(Ve * Ve + yt * yt), ut[He - 2] = ut[He - 1] = !0))
                    }
                    return Y
                },
                an = function(Y) {
                    var ie = Y.trim().split(" "),
                        ge = ~Y.indexOf("left") ? 0 : ~Y.indexOf("right") ? 100 : isNaN(parseFloat(ie[0])) ? 50 : parseFloat(ie[0]),
                        ke = ~Y.indexOf("top") ? 0 : ~Y.indexOf("bottom") ? 100 : isNaN(parseFloat(ie[1])) ? 50 : parseFloat(ie[1]);
                    return {
                        x: ge / 100,
                        y: ke / 100
                    }
                },
                Rn = function(Y) {
                    return Y !== Y % tt ? Y + (Y < 0 ? ht : -ht) : Y
                },
                un = "Use MorphSVGPlugin.convertToPath() to convert to a path before morphing.",
                An = function(Y, ie, ge, ke) {
                    var Le = this._origin,
                        Ee = this._eOrigin,
                        Ne = Y[ge] - Le.x,
                        qe = Y[ge + 1] - Le.y,
                        Ve = ve(Ne * Ne + qe * qe),
                        yt = G(qe, Ne),
                        rt, He;
                    return Ne = ie[ge] - Ee.x, qe = ie[ge + 1] - Ee.y, rt = G(qe, Ne) - yt, He = Rn(rt), !ke && Q && Math.abs(He + Q.ca) < lt && (ke = Q), this._anchorPT = Q = {
                        _next: this._anchorPT,
                        t: Y,
                        sa: yt,
                        ca: ke && He * ke.ca < 0 && Math.abs(He) > _t ? rt : He,
                        sl: Ve,
                        cl: ve(Ne * Ne + qe * qe) - Ve,
                        i: ge
                    }
                },
                Un = function(Y) {
                    he = K(), re = re || he && he.plugins.morphSVG, he && re ? (me = he.utils.toArray, re.prototype._tweenRotation = An, ne = 1) : Y && ye("Please gsap.registerPlugin(MorphSVGPlugin)")
                },
                er = {
                    version: "3.13.0",
                    name: "morphSVG",
                    rawVars: 1,
                    register: function(Y, ie) {
                        he = Y, re = ie, Un()
                    },
                    init: function(Y, ie, ge, ke, Le) {
                        if (ne || Un(1), !ie) return ye("invalid shape"), !1;
                        te(ie) && (ie = ie.call(ge, ke, Y, Le));
                        var Ee, Ne, qe, Ve, yt, rt, He, ot, Mt, ut, pt, Qe, Re, T, z, R, ee, ae, Fe, at, O, y;
                        if (typeof ie == "string" || ie.getBBox || ie[0]) ie = {
                            shape: ie
                        };
                        else if (typeof ie == "object") {
                            Ee = {};
                            for (Ne in ie) Ee[Ne] = te(ie[Ne]) && Ne !== "render" ? ie[Ne].call(ge, ke, Y, Le) : ie[Ne];
                            ie = Ee
                        }
                        var x = Y.nodeType ? window.getComputedStyle(Y) : {},
                            P = x.fill + "",
                            B = !(P === "none" || (P.match(Pt) || [])[3] === "0" || x.fillRule === "evenodd"),
                            q = (ie.origin || "50 50").split(",");
                        if (Ee = (Y.nodeName + "").toUpperCase(), yt = Ee === "POLYLINE" || Ee === "POLYGON", Ee !== "PATH" && !yt && !ie.prop) return ye("Cannot morph a <" + Ee + "> element. " + un), !1;
                        if (Ne = Ee === "PATH" ? "d" : "points", !ie.prop && !te(Y.setAttribute)) return !1;
                        if (Ve = Ot(ie.shape || ie.d || ie.points || "", Ne === "d", Y), yt && de.test(Ve)) return ye("A <" + Ee + "> cannot accept path data. " + un), !1;
                        if (rt = ie.shapeIndex || ie.shapeIndex === 0 ? ie.shapeIndex : "auto", He = ie.map || er.defaultMap, this._prop = ie.prop, this._render = ie.render || er.defaultRender, this._apply = "updateTarget" in ie ? ie.updateTarget : er.defaultUpdateTarget, this._rnd = Math.pow(10, isNaN(ie.precision) ? 2 : +ie.precision), this._tween = ge, Ve) {
                            if (this._target = Y, ee = typeof ie.precompile == "object", ut = this._prop ? Y[this._prop] : Y.getAttribute(Ne), !this._prop && !Y.getAttributeNS(null, "data-original") && Y.setAttributeNS(null, "data-original", ut), Ne === "d" || this._prop) {
                                if (ut = J(ee ? ie.precompile[0] : ut), pt = J(ee ? ie.precompile[1] : Ve), !ee && !je(ut, pt, rt, He, B)) return !1;
                                for ((ie.precompile === "log" || ie.precompile === !0) && ye('precompile:["' + xe(ut) + '","' + xe(pt) + '"]'), O = (ie.type || er.defaultType) !== "linear", O && (ut = qt(ut, ie.smoothTolerance), pt = qt(pt, ie.smoothTolerance), ut.size || Ke(ut), pt.size || Ke(pt), at = an(q[0]), this._origin = ut.origin = {
                                        x: ut.left + at.x * ut.width,
                                        y: ut.top + at.y * ut.height
                                    }, q[1] && (at = an(q[1])), this._eOrigin = {
                                        x: pt.left + at.x * pt.width,
                                        y: pt.top + at.y * pt.height
                                    }), this._rawPath = Y._gsRawPath = ut, Re = ut.length; --Re > -1;)
                                    for (z = ut[Re], R = pt[Re], ot = z.isSmooth || [], Mt = R.isSmooth || [], T = z.length, Q = 0, Qe = 0; Qe < T; Qe += 2)(R[Qe] !== z[Qe] || R[Qe + 1] !== z[Qe + 1]) && (O ? ot[Qe] && Mt[Qe] ? (ae = z.smoothData, Fe = R.smoothData, y = Qe + (Qe === T - 4 ? 7 - T : 5), this._controlPT = {
                                        _next: this._controlPT,
                                        i: Qe,
                                        j: Re,
                                        l1s: ae[Qe + 1],
                                        l1c: Fe[Qe + 1] - ae[Qe + 1],
                                        l2s: ae[y],
                                        l2c: Fe[y] - ae[y]
                                    }, qe = this._tweenRotation(z, R, Qe + 2), this._tweenRotation(z, R, Qe, qe), this._tweenRotation(z, R, y - 1, qe), Qe += 4) : this._tweenRotation(z, R, Qe) : (qe = this.add(z, Qe, z[Qe], R[Qe], 0, 0, 0, 0, 0, 1), qe = this.add(z, Qe + 1, z[Qe + 1], R[Qe + 1], 0, 0, 0, 0, 0, 1) || qe))
                            } else qe = this.add(Y, "setAttribute", Y.getAttribute(Ne) + "", Ve + "", ke, Le, 0, Et(rt), Ne);
                            O && (this.add(this._origin, "x", this._origin.x, this._eOrigin.x, 0, 0, 0, 0, 0, 1), qe = this.add(this._origin, "y", this._origin.y, this._eOrigin.y, 0, 0, 0, 0, 0, 1)), qe && (this._props.push("morphSVG"), qe.end = Ve, qe.endProp = Ne)
                        }
                        return oe
                    },
                    render: function(Y, ie) {
                        for (var ge = ie._rawPath, ke = ie._controlPT, Le = ie._anchorPT, Ee = ie._rnd, Ne = ie._target, qe = ie._pt, Ve, yt, rt, He, ot, Mt, ut, pt, Qe, Re, T, z, R; qe;) qe.r(Y, qe.d), qe = qe._next;
                        if (Y === 1 && ie._apply)
                            for (qe = ie._pt; qe;) qe.end && (ie._prop ? Ne[ie._prop] = qe.end : Ne.setAttribute(qe.endProp, qe.end)), qe = qe._next;
                        else if (ge) {
                            for (; Le;) Mt = Le.sa + Y * Le.ca, ot = Le.sl + Y * Le.cl, Le.t[Le.i] = ie._origin.x + ce(Mt) * ot, Le.t[Le.i + 1] = ie._origin.y + le(Mt) * ot, Le = Le._next;
                            for (rt = Y < .5 ? 2 * Y * Y : (4 - 2 * Y) * Y - 1; ke;) ut = ke.i, He = ge[ke.j], R = ut + (ut === He.length - 4 ? 7 - He.length : 5), Mt = G(He[R] - He[ut + 1], He[R - 1] - He[ut]), T = le(Mt), z = ce(Mt), Qe = He[ut + 2], Re = He[ut + 3], ot = ke.l1s + rt * ke.l1c, He[ut] = Qe - z * ot, He[ut + 1] = Re - T * ot, ot = ke.l2s + rt * ke.l2c, He[R - 1] = Qe + z * ot, He[R] = Re + T * ot, ke = ke._next;
                            if (Ne._gsRawPath = ge, ie._apply) {
                                for (Ve = "", yt = " ", pt = 0; pt < ge.length; pt++)
                                    for (He = ge[pt], ot = He.length, Ve += "M" + (He[0] * Ee | 0) / Ee + yt + (He[1] * Ee | 0) / Ee + " C", ut = 2; ut < ot; ut++) Ve += (He[ut] * Ee | 0) / Ee + yt;
                                ie._prop ? Ne[ie._prop] = Ve : Ne.setAttribute("d", Ve)
                            }
                        }
                        ie._render && ge && ie._render.call(ie._tween, ge, Ne)
                    },
                    kill: function(Y) {
                        this._pt = this._rawPath = 0
                    },
                    getRawPath: j,
                    stringToRawPath: J,
                    rawPathToString: xe,
                    normalizeStrings: function(Y, ie, ge) {
                        var ke = ge.shapeIndex,
                            Le = ge.map,
                            Ee = [Y, ie];
                        return We(Ee, ke, Le), Ee
                    },
                    pathFilter: We,
                    pointsFilter: wt,
                    getTotalSize: Ke,
                    equalizeSegmentQuantity: je,
                    convertToPath: function(Y, ie) {
                        return me(Y).map(function(ge) {
                            return S(ge, ie !== !1)
                        })
                    },
                    defaultType: "linear",
                    defaultUpdateTarget: !0,
                    defaultMap: "size"
                };
            K() && he.registerPlugin(er), n.MorphSVGPlugin = er, n.default = er, Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(Cl, Cl.exports)), Cl.exports
}
var _S = gS();
const mS = Go(_S);
var Sl = {
        exports: {}
    },
    yS = Sl.exports,
    Wp;

function vS() {
    return Wp || (Wp = 1, function(e, t) {
        (function(n, r) {
            r(t)
        })(yS, function(n) {
            var r = /(?:^\s+|\s+$)/g,
                i = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2642\u2640]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDD27\uDCBC\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCC\uDFCB]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

            function s(w) {
                var k = w.nodeType,
                    S = "";
                if (k === 1 || k === 9 || k === 11) {
                    if (typeof w.textContent == "string") return w.textContent;
                    for (w = w.firstChild; w; w = w.nextSibling) S += s(w)
                } else if (k === 3 || k === 4) return w.nodeValue;
                return S
            }

            function a(w, k, S, X, J) {
                if (w += "", S && (w = w.trim ? w.trim() : w.replace(r, "")), k && k !== "") return w.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(k);
                for (var xe = [], he = w.length, me = 0, Q, ne; me < he; me++) ne = w.charAt(me), (ne.charCodeAt(0) >= 55296 && ne.charCodeAt(0) <= 56319 || w.charCodeAt(me + 1) >= 65024 && w.charCodeAt(me + 1) <= 65039) && (Q = ((w.substr(me, 12).split(i) || [])[1] || "").length || 2, ne = w.substr(me, Q), xe.emoji = 1, me += Q - 1), xe.push(J ? ne : ne === ">" ? "&gt;" : ne === "<" ? "&lt;" : X && ne === " " && (w.charAt(me - 1) === " " || w.charAt(me + 1) === " ") ? "&nbsp;" : ne);
                return xe
            }
            /*!
             * ScrambleTextPlugin 3.13.0
             * https://gsap.com
             *
             * @license Copyright 2008-2025, GreenSock. All rights reserved.
             * Subject to the terms at https://gsap.com/standard-license
             * @author: Jack Doyle, jack@greensock.com
             */
            var c = function() {
                    function w(S) {
                        this.chars = a(S), this.sets = [], this.length = 50;
                        for (var X = 0; X < 20; X++) this.sets[X] = E(80, this.chars)
                    }
                    var k = w.prototype;
                    return k.grow = function(X) {
                        for (var J = 0; J < 20; J++) this.sets[J] += E(X - this.length, this.chars);
                        this.length = X
                    }, w
                }(),
                u, p, d = function() {
                    return u || typeof window < "u" && (u = window.gsap) && u.registerPlugin && u
                },
                g = 1,
                m = /\s+/g,
                E = function(k, S) {
                    for (var X = S.length, J = ""; --k > -1;) J += S[~~(Math.random() * X)];
                    return J
                },
                L = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                b = L.toLowerCase(),
                j = {
                    upperCase: new c(L),
                    lowerCase: new c(b),
                    upperAndLowerCase: new c(L + b)
                },
                A = function() {
                    p = u = d()
                },
                $ = {
                    version: "3.13.0",
                    name: "scrambleText",
                    register: function(k, S, X) {
                        u = k, A()
                    },
                    init: function(k, S, X, J, xe) {
                        if (p || A(), this.prop = "innerHTML" in k ? "innerHTML" : "textContent" in k ? "textContent" : 0, !!this.prop) {
                            this.target = k, typeof S != "object" && (S = {
                                text: S
                            });
                            var he = S.text || S.value || "",
                                me = S.trim !== !1,
                                Q = this,
                                ne, re, K, te;
                            return Q.delimiter = ne = S.delimiter || "", Q.original = a(s(k).replace(m, " ").split("&nbsp;").join(""), ne, me), (he === "{original}" || he === !0 || he == null) && (he = Q.original.join(ne)), Q.text = a((he || "").replace(m, " "), ne, me), Q.hasClass = !!(S.newClass || S.oldClass), Q.newClass = S.newClass, Q.oldClass = S.oldClass, te = ne === "", Q.textHasEmoji = te && !!Q.text.emoji, Q.charsHaveEmoji = !!S.chars && !!a(S.chars).emoji, Q.length = te ? Q.original.length : Q.original.join(ne).length, Q.lengthDif = (te ? Q.text.length : Q.text.join(ne).length) - Q.length, Q.fillChar = S.fillChar || S.chars && ~S.chars.indexOf(" ") ? "&nbsp;" : "", Q.charSet = K = j[S.chars || "upperCase"] || new c(S.chars), Q.speed = .05 / (S.speed || 1), Q.prevScrambleTime = 0, Q.setIndex = Math.random() * 20 | 0, re = Q.length + Math.max(Q.lengthDif, 0), re > K.length && K.grow(re), Q.chars = K.sets[Q.setIndex], Q.revealDelay = S.revealDelay || 0, Q.tweenLength = S.tweenLength !== !1, Q.tween = X, Q.rightToLeft = !!S.rightToLeft, Q._props.push("scrambleText", "text"), g
                        }
                    },
                    render: function(k, S) {
                        var X = S.target,
                            J = S.prop,
                            xe = S.text,
                            he = S.delimiter,
                            me = S.tween,
                            Q = S.prevScrambleTime,
                            ne = S.revealDelay,
                            re = S.setIndex,
                            K = S.chars,
                            te = S.charSet,
                            G = S.length,
                            ce = S.textHasEmoji,
                            le = S.charsHaveEmoji,
                            ve = S.lengthDif,
                            tt = S.tweenLength,
                            ht = S.oldClass,
                            lt = S.newClass,
                            _t = S.rightToLeft,
                            mt = S.fillChar,
                            Pt = S.speed,
                            St = S.original,
                            de = S.hasClass,
                            ye = xe.length,
                            oe = me._time,
                            ze = oe - Q,
                            Se, Ke, M, I, fe, Oe, Te, Ie, st, nt, je;
                        ne && (me._from && (oe = me._dur - oe), k = oe === 0 ? 0 : oe < ne ? 1e-6 : oe === me._dur ? 1 : me._ease((oe - ne) / (me._dur - ne))), k < 0 ? k = 0 : k > 1 && (k = 1), _t && (k = 1 - k), Se = ~~(k * ye + .5), k ? ((ze > Pt || ze < -Pt) && (S.setIndex = re = (re + (Math.random() * 19 | 0)) % 20, S.chars = te.sets[re], S.prevScrambleTime += ze), I = K) : I = St.join(he), je = me._from ? k : 1 - k, nt = G + (tt ? me._from ? je * je * je : 1 - je * je * je : 1) * ve, _t ? k === 1 && (me._from || me.data === "isFromStart") ? (M = "", I = St.join(he)) : (Te = xe.slice(Se).join(he), le ? M = a(I).slice(0, nt - (ce ? a(Te) : Te).length + .5 | 0).join("") : M = I.substr(0, nt - (ce ? a(Te) : Te).length + .5 | 0), I = Te) : (M = xe.slice(0, Se).join(he), Ke = (ce ? a(M) : M).length, le ? I = a(I).slice(Ke, nt + .5 | 0).join("") : I = I.substr(Ke, nt - Ke + .5 | 0)), de ? (Ie = _t ? ht : lt, st = _t ? lt : ht, fe = Ie && Se !== 0, Oe = st && Se !== ye, Te = (fe ? "<span class='" + Ie + "'>" : "") + M + (fe ? "</span>" : "") + (Oe ? "<span class='" + st + "'>" : "") + he + I + (Oe ? "</span>" : "")) : Te = M + he + I, X[J] = mt === "&nbsp;" && ~Te.indexOf("  ") ? Te.split("  ").join("&nbsp;&nbsp;") : Te
                    }
                };
            $.emojiSafeSplit = a, $.getText = s, d() && u.registerPlugin($), n.ScrambleTextPlugin = $, n.default = $, Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(Sl, Sl.exports)), Sl.exports
}
var bS = vS();
const wS = Go(bS);
var Jl = (e, t, n) => (1 - n) * e + n * t,
    DS = (e, t, n) => {
        const r = Jl(Math.cos(e), Math.cos(t), n),
            i = Jl(Math.sin(e), Math.sin(t), n);
        return Math.atan2(i, r)
    },
    xS = (e, t, n, r) => Jl(e, t, 1 - Math.exp(-n * r)),
    K0 = (e, t, n) => Math.max(Math.min(e, n), t),
    Q0 = (e, t, n, r) => {
        const i = (e - t) / (n - t);
        return (r == null ? void 0 : r.clamp) === !0 ? K0(i, 0, 1) : i
    },
    ES = (e, t, n, r, i, s) => Jl(r, i, Q0(e, t, n, s)),
    dh = (e, t) => (t = t === void 0 ? 100 : 10 ** t, Math.round(e * t) / t),
    CS = (e, t, n) => dh(e, n) === dh(t, n) ? Math.round(t) : e,
    dc = {
        int: (e, t) => Math.floor(t === void 0 ? dc.range(0, e) : dc.range(e, t)),
        range: (e, t) => Math.random() * (t - e),
        arr: e => e[Math.floor(Math.random() * e.length)]
    },
    SS = {
        create: e => [...Array(e).keys()],
        shuffle: e => {
            for (let t = e.length - 1; t > 0; t--) {
                const n = Math.floor(Math.random() * (t + 1));
                [e[t], e[n]] = [e[n], e[t]]
            }
            return e
        },
        rand: dc.arr,
        shift: (e, t) => e.length === 0 || t < 0 || t >= e.length ? e : [...e.slice(t), ...e.slice(0, t)],
        spliceNth: (e, t) => {
            if (t <= 0) throw new Error("Step size must be greater than 0");
            const n = [];
            let r = 0;
            for (let i = 0; i < e.length; i++) i % t === 0 ? n.push(e[i]) : e[r++] = e[i];
            return e.length = r, n
        }
    },
    TS = e => 9 < e ? "" + e : "0" + e,
    PS = {
        add: (e, t) => {
            e.classList.add(t)
        },
        remove: (e, t) => {
            e.classList.remove(t)
        },
        toggle: (e, t, n) => {
            e.classList.toggle(t, n)
        }
    };

function kS(e, t) {
    return t in e && e[t] != null
}
var AS = (e, t) => (e % t + t) % t,
    RS = {
        expo: {
            expo: On.gsap.parseEase("expo"),
            expoInOut: On.gsap.parseEase("expo.inOut"),
            expoIn: On.gsap.parseEase("expo.in"),
            expoOut: On.gsap.parseEase("expo.out")
        },
        pow1: {
            in: On.gsap.parseEase("power1.in"),
            out: On.gsap.parseEase("power1.out"),
            inOut: On.gsap.parseEase("power1.inOut")
        },
        pow2: {
            in: On.gsap.parseEase("power2.in"),
            out: On.gsap.parseEase("power2.out"),
            inOut: On.gsap.parseEase("power2.inOut")
        },
        pow3: {
            in: On.gsap.parseEase("power3.in"),
            out: On.gsap.parseEase("power3.out"),
            inOut: On.gsap.parseEase("power3.inOut")
        },
        pow4: {
            in: On.gsap.parseEase("power4.in"),
            out: On.gsap.parseEase("power4.out"),
            inOut: On.gsap.parseEase("power4.inOut")
        }
    },
    Xa = {
        Lerp: Jl,
        rLerp: DS,
        iLerp: Q0,
        Damp: xS,
        map: ES,
        Clamp: K0,
        Round: dh,
        RoundWhenClose: CS,
        Rand: dc,
        Arr: SS,
        Digit: TS,
        isKeyOf: kS,
        Class: PS,
        mod: AS,
        Ease: RS
    },
    OS = (e, t, n) => {
        const {
            noTrailing: r = !1,
            noLeading: i = !1,
            debounceMode: s = void 0
        } = {};
        let a, c = !1,
            u = 0;
        const p = () => {
                a && clearTimeout(a)
            },
            d = m => {
                const {
                    upcomingOnly: E = !1
                } = m || {};
                p(), c = !E
            };

        function g(...m) {
            const E = this,
                L = Date.now() - u;
            if (c) return;
            const b = () => {
                    u = Date.now(), t.apply(E, m)
                },
                j = () => {
                    a = void 0
                };
            !i && s && !a && b(), p(), s === void 0 && L > e ? i ? (u = Date.now(), r || (a = setTimeout(s ? j : b, e))) : b() : r !== !0 && (a = setTimeout(s ? j : b, s === void 0 ? e - L : e))
        }
        return g.cancel = d, g
    };
class MS {
    constructor() {
        Ct(this, "width", 0);
        Ct(this, "height", 0);
        Ct(this, "previousWidth", 0);
        Ct(this, "previousHeight", 0);
        Ct(this, "fakeFullHeight", 0);
        Ct(this, "iOS", !1);
        Ct(this, "isMobile", !1);
        Ct(this, "isWindows", !1);
        Ct(this, "breakpoints", []);
        Ct(this, "pointerMatchMedia", null);
        Ct(this, "updateFns", []);
        Ct(this, "internalResize", () => {
            let t = !1;
            return this.previousWidth = this.width, this.previousHeight = this.height, this.width = window.innerWidth, this.height = window.innerHeight, this.isMobile && this.previousWidth === this.width && this.previousHeight <= this.height ? this.height = this.previousHeight : t = !0, this.isMobile && this.width > this.height && (this.height = window.innerHeight, t = !0), this.checkBreakpoints(), t && this.setProperties(), t
        });
        Ct(this, "onResize", () => {
            this.internalResize() && (this.updateNoThrottle(), this.updateThrottled())
        });
        Ct(this, "updateNoThrottle", () => {
            this.updateFns.filter(t => t.noThrottle).forEach(t => t.fn({
                width: this.width,
                height: this.height
            }, this))
        });
        Ct(this, "updateThrottled", OS(200, () => {
            this.updateFns.filter(t => !t.noThrottle).forEach(t => t.fn({
                width: this.width,
                height: this.height
            }, this)), setTimeout(() => {
                da.refresh()
            }, 1)
        }));
        Ct(this, "onPointerChange", t => {
            this.isMobile = !t.matches || this.iOS
        });
        typeof window < "u" && (this.pointerMatchMedia = window.matchMedia("(hover: hover)"), this.checkDevice())
    }
    checkDevice() {
        this.iOS = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document, this.isWindows = navigator.userAgent.includes("Windows"), this.isMobile = !this.pointerMatchMedia.matches || this.iOS
    }
    getFullVh() {
        const t = document.createElement("div");
        t.style.cssText = "position:fixed;top:0;left:0;height:100vh;visibility:hidden;pointer-events:none;", document.body.appendChild(t);
        const n = t.offsetHeight;
        return document.body.removeChild(t), n
    }
    setProperties() {
        if (this.isMobile) {
            document.documentElement.style.setProperty("--vw", document.documentElement.clientWidth * .01 + "px"), document.documentElement.style.setProperty("--vh", `${(window.screen.height||window.innerHeight)/100}px`), document.documentElement.style.setProperty("--dvh", window.innerHeight * .01 + "px"), document.documentElement.style.setProperty("--svh", document.documentElement.clientHeight * .01 + "px"), document.documentElement.style.setProperty("--lvh", `${(window.screen.height||window.innerHeight)/100}px`);
            return
        }
        document.documentElement.style.setProperty("--vw", "1vw"), document.documentElement.style.setProperty("--vh", "1vh"), document.documentElement.style.setProperty("--dvh", "1dvh"), document.documentElement.style.setProperty("--svh", "1svh"), document.documentElement.style.setProperty("--lvh", "1lvh")
    }
    checkBreakpoints() {
        for (const t of this.breakpoints) t.active = this.width >= t.size
    }
    setBreakpoints(t) {
        this.breakpoints = t.map(n => ({
            ...n,
            active: !1
        }))
    }
    add(t, n = 0, r = !1, i = !1) {
        const s = {
            fn: t,
            priority: n,
            noThrottle: r
        };
        return this.updateFns.push(s), this.updateFns.sort((a, c) => a.priority - c.priority), i && s.fn({
            width: this.width,
            height: this.height
        }, this), () => {
            this.remove(t)
        }
    }
    remove(t) {
        const n = this.updateFns.findIndex(r => r.fn === t);
        n !== -1 && this.updateFns.splice(n, 1)
    }
    start() {
        this.stop(), window.addEventListener("resize", this.onResize, !1), this.pointerMatchMedia.addEventListener("change", this.onPointerChange), this.internalResize(), setTimeout(() => {
            da.refresh()
        }, 1)
    }
    stop() {
        window.removeEventListener("resize", this.onResize, !1), this.pointerMatchMedia.removeEventListener("change", this.onPointerChange)
    }
}
var yf = null,
    lu = () => (yf || (yf = new MS), yf);
class LS {
    constructor() {
        Ct(this, "gsapTicker");
        Ct(this, "updateFns");
        Ct(this, "time", 0);
        Ct(this, "update", (t, n) => {
            this.time = t, this.updateFns.forEach(r => r.fn({
                et: t,
                dt: n / 1e3
            }))
        });
        this.gsapTicker = On.gsap.ticker, this.updateFns = []
    }
    add(t, n = 0) {
        const r = {
            fn: t,
            priority: n
        };
        return this.updateFns.push(r), this.updateFns.sort((i, s) => i.priority - s.priority), () => {
            this.remove(t)
        }
    }
    remove(t) {
        const n = this.updateFns.findIndex(r => r.fn === t);
        n !== -1 && this.updateFns.splice(n, 1)
    }
    start() {
        this.stop(), this.gsapTicker.add(this.update)
    }
    stop() {
        this.gsapTicker.remove(this.update)
    }
}
var vf = null,
    J0 = () => (vf || (vf = new LS), vf);
const FS = Di(() => {
        const e = lu();
        e.setBreakpoints([{
            name: "xs",
            size: 0
        }, {
            name: "sm",
            size: 480
        }, {
            name: "md",
            size: 768
        }, {
            name: "lg",
            size: 1024
        }, {
            name: "xlg",
            size: 1280
        }, {
            name: "xl",
            size: 1440
        }, {
            name: "xxl",
            size: 1680
        }, {
            name: "xxxl",
            size: 1920
        }]);
        const t = J0();
        return e.start(), t.start(), {
            provide: {
                viewport: e,
                ticker: t
            }
        }
    }),
    IS = Di(() => (On.gsap.registerPlugin(da, hh, Lu, Hp, mS, dS, eS, wS), da.config({
        ignoreMobileResize: !0
    }), On.gsap.ticker.lagSmoothing(0), Lu.create("custom.fastInOut", ".52,0,0,1"), Lu.create("easeCustomNotch", ".67,.05,.43,1"), Lu.create("menuEase", "M0,0 L0.009,0.012 L0.02,0.049 L0.093,0.409 L0.119,0.513 L0.147,0.606 L0.179,0.691 L0.213,0.762 L0.25,0.82 L0.291,0.868 L0.336,0.907 L0.387,0.937 L0.513,0.976 L0.688,0.994 L1,1"), {
        provide: {
            gsap: On.gsap,
            ScrollTrigger: da,
            SplitText: hh,
            Flip: Hp
        }
    })),
    NS = [Dw, Ew, $w, sx, Dx, xx, Ex, Cx, Sx, Ux, Wx, QE, JE, tC, MC, WC, FS, IS],
    ba = (e, t) => {
        const n = e.__vccOpts || e;
        for (const [r, i] of t) n[r] = i;
        return n
    },
    BS = {},
    $S = {
        viewBox: "0 0 215 49",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    };

function HS(e, t) {
    return Mn(), Br("svg", $S, t[0] || (t[0] = [v_('<path d="M9.16512 0C8.26239 0 7.39524 0.369725 6.75488 1.02245L1.00056 6.92436C0.360201 7.58165 0 8.47629 0 9.40289V48.0871C0 48.5892 0.400223 49 0.889385 49H34.3481C35.2508 49 36.1179 48.6303 36.7583 47.973L46.7416 37.7211C47.382 37.0684 47.7422 36.1737 47.7422 35.2471V0.912902C47.7422 0.410806 47.342 0 46.8528 0H9.16512ZM40.9206 16.0123C40.9206 16.8339 40.2714 17.5003 39.4709 17.5003H22.1324C21.3586 17.5003 20.6604 18.1531 20.6827 18.9473C20.696 19.2942 20.8339 19.6137 21.0518 19.8556C21.074 19.8784 21.0918 19.9013 21.1185 19.9241L28.5626 27.5696C28.8339 27.8481 28.9895 28.2269 28.9895 28.6195V40.5191C28.9895 41.3408 28.3403 42.0072 27.5398 42.0072H20.2068C19.4064 42.0072 18.7571 41.3408 18.7571 40.5191V18.9929C18.7571 18.1713 18.1079 17.5049 17.3074 17.5049H8.27128C7.47084 17.5049 6.82159 16.8385 6.82159 16.0169V8.48999C6.82159 7.66838 7.47084 7.00196 8.27128 7.00196H18.1568C18.5437 7.00196 18.9128 7.15715 19.184 7.44015L26.6149 15.0674C26.6415 15.0994 26.6771 15.1359 26.7082 15.1633C26.9306 15.3733 27.2241 15.5056 27.5487 15.5285C28.3403 15.5741 28.9895 14.8529 28.9895 14.0404V8.49455C28.9895 7.67294 29.6388 7.00652 30.4392 7.00652H39.4754C40.2758 7.00652 40.9251 7.67294 40.9251 8.49455V16.0214L40.9206 16.0123Z" fill="currentColor"></path><path d="M57.9746 14.2048V9.35724H81.988V14.2048H72.8718V39.6473H67.0508V14.2048H57.9746Z" fill="currentColor"></path><path d="M89.3921 35.7173C91.0997 35.7173 92.8518 35.0919 93.9902 33.1292H99.7712C98.5928 36.4704 95.3777 40.1905 89.4321 40.1905C82.3927 40.1905 78.2793 34.7998 78.2793 28.3273C78.2793 21.8549 82.7973 16.6696 89.2676 16.6696C95.7379 16.6696 100.256 22.0603 100.011 29.998H83.8557C84.1403 33.8413 86.7462 35.7218 89.3921 35.7218V35.7173ZM94.3193 26.0268C94.1992 22.2246 91.5933 20.8872 89.232 20.8872C87.1153 20.8872 84.3893 22.2657 83.9402 26.0268H94.3193Z" fill="currentColor"></path><path d="M113.001 22.6034C110.235 22.6034 108.403 23.6487 108.403 27.8663V39.6473H102.786V17.1717H108.323V21.0972C109.586 18.3402 111.578 17.2128 114.104 17.2128C114.468 17.2128 114.957 17.2538 115.327 17.2949V22.7267C114.513 22.6445 113.819 22.6034 113.005 22.6034H113.001Z" fill="currentColor"></path><path d="M137.583 27.9485V39.6473H131.967V26.57C131.967 24.1052 131.762 21.3071 128.467 21.3071C124.723 21.3071 124.114 24.5251 124.114 27.9485V39.6473H118.497V17.1717H124.114V20.1386C125.337 17.9248 127.573 16.6696 130.219 16.6696C133.964 16.6696 135.591 18.7191 136.445 20.344C138.153 17.8381 140.354 16.6696 143.649 16.6696C149.145 16.6696 151.058 20.1797 151.058 25.4837V39.6473H145.441V26.57C145.441 24.1052 145.237 21.3071 141.941 21.3071C138.197 21.3071 137.588 24.5251 137.588 27.9485H137.583Z" fill="currentColor"></path><path d="M159.969 14.7068H154.353V9.36181H159.969V14.7068ZM159.969 39.6473H154.353V17.1717H159.969V39.6473Z" fill="currentColor"></path><path d="M175.56 16.6696C180.812 16.6696 183.129 19.9697 183.129 25.4837V39.6473H177.512V26.7389C177.512 23.813 176.903 21.3071 173.728 21.3071C170.024 21.3071 169.21 24.3973 169.21 27.9485V39.6473H163.594V17.1717H169.21V20.1386C170.473 17.8837 172.874 16.6696 175.56 16.6696Z" fill="currentColor"></path><path d="M185.815 33.5902C185.815 28.2863 191.636 26.6978 200.223 25.6936V25.3193C200.223 21.8503 198.391 20.6407 196.114 20.6407C193.957 20.6407 192.165 21.8092 192.045 24.2741H186.793C187.202 19.8465 190.782 16.5874 196.399 16.5874C201.606 16.5874 205.839 18.8834 205.839 26.4878C205.839 27.1999 205.759 30.1623 205.759 32.2117C205.759 35.7629 206.004 37.7668 206.409 39.6473H201.241C201.077 38.9353 200.957 37.9356 200.877 36.8493C199.329 39.1863 197.012 40.1905 193.713 40.1905C189.519 40.1905 185.815 37.6846 185.815 33.5902ZM191.596 33.2981C191.596 34.9276 192.859 36.265 195.38 36.265C198.88 36.265 200.387 34.3023 200.387 31.0432V29.3726C194.122 30.039 191.596 30.7922 191.596 33.2981Z" fill="currentColor"></path><path d="M209.384 39.6473V9.35724H215V39.6428H209.384V39.6473Z" fill="currentColor"></path>', 9)]))
}
const Z0 = ba(BS, [
        ["render", HS]
    ]),
    VS = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Z0
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    zS = {
        class: "site-grid | w-full mx-auto"
    },
    em = {
        __name: "Container",
        props: {
            tag: {
                type: String,
                default: "section",
                validator: e => ["section", "div", "header", "footer", "nav"].includes(e)
            }
        },
        setup(e) {
            return (t, n) => (Mn(), cs(Al(e.tag), {
                class: "site-container"
            }, {
                default: Ki(() => [Xt("div", zS, [Xg(t.$slots, "default")])]),
                _: 3
            }))
        }
    },
    jS = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: em
    }, Symbol.toStringTag, {
        value: "Module"
    }));
var US;
(e => {
    e.watcher = "watcher", e.instance = "instance", e.scope = "scope"
})(US || (US = {}));
var uu = (e, t) => {
    const n = (t == null ? void 0 : t.unsafe) || !1,
        r = (t == null ? void 0 : t.forceMode) || !1,
        i = Ur(null),
        s = Uo(),
        a = ey(),
        c = wi();
    switch (r) {
        case "instance": {
            if (!c) throw "useSafeClient is called outside an instance";
            const u = go();
            c.isMounted ? i.value = u.run(() => e()) : $i(() => {
                i.value = u.run(() => e())
            });
            break
        }
        case "scope": {
            if (!s) throw "useSafeClient is called outside a scope";
            const u = go();
            i.value = u.run(() => e());
            break
        }
        case "watcher": {
            if (!a) throw "useSafeClient is called outside a watcher";
            const u = go();
            za(() => {
                u.stop()
            }), i.value = u.run(() => e());
            break
        }
        default: {
            if (!n && !s && !a && !c) throw "useSafeClient is called outside a scope or watcher";
            const u = go();
            a && za(() => {
                u.stop()
            }), c && !c.isMounted && !a ? $i(() => {
                i.value = u.run(() => e())
            }) : i.value = u.run(() => e())
        }
        return i
    }
};

function $c(e, t, n) {
    return uu(() => {
        const r = lu();
        r.add(e, t, n, !0), fs(() => {
            r.remove(e)
        })
    })
}

function WS(e, t) {
    const n = lu(),
        r = kn(),
        i = Qr(r, a => {
            t(a)
        }, {
            flush: "sync"
        });
    return $c(() => {
        r.value = n.breakpoints.find(a => a.name === e).active
    }, -1, !0), i
}

function qS(e) {
    const t = lu(),
        n = go(),
        r = i => {
            e(i.matches)
        };
    typeof window < "u" && n.run(() => {
        t.pointerMatchMedia.addEventListener("change", r), e(t.pointerMatchMedia.matches), fs(() => {
            t.pointerMatchMedia.removeEventListener("change", r)
        })
    })
}

function cu() {
    const e = kn(!1);
    return WS("lg", t => {
        e.value = t
    }), e
}

function GS() {
    const e = kn(!1);
    return qS(t => {
        e.value = t
    }), e
}

function bP() {
    const e = GS(),
        t = cu();
    return xn(() => !e.value || !t.value)
}

function Hc(e, t) {
    return uu(() => {
        const n = J0();
        n.add(e, t), fs(() => {
            n.remove(e)
        })
    })
}
var tm = (e, t = !1, n) => uu(() => {
        const r = On.gsap.context(i => e == null ? void 0 : e(i));
        return fs(() => {
            r.kill(t)
        }), r
    }, {
        forceMode: n
    }),
    wP = (e, t = !1) => {
        if (!Uo()) throw new Error("useGSAPMatchMedia must be called within a scope");
        const n = lu();
        return uu(() => {
            const r = go(),
                i = On.gsap.matchMedia(),
                s = n.breakpoints.reduce((a, c) => (a[`is${eu(c.name)}`] = `(min-width: ${c.size}px)`, a), {});
            return s.isPointerFine = "(hover: hover)", i.add(s, a => r.run(() => e == null ? void 0 : e(a))), fs(() => {
                i.kill(t)
            }), i
        })
    },
    DP = ({
        target: e = kn(0),
        damped: t = kn(0),
        lambda: n = kn(8)
    } = {}) => (e = Na(e), n = Na(n), t = Na(t), Hc(({
        dt: r
    }) => {
        t.value = Xa.Damp(t.value, e.value, n.value, r)
    }), {
        target: e,
        damped: t
    });

function xP(e, t) {
    let n, r, i;
    const s = Ur(!0),
        a = () => {
            s.value = !0, i()
        };
    Qr(e, a, {
        flush: "sync"
    });
    const c = typeof t == "function" ? t : t.get,
        u = typeof t == "function" ? void 0 : t.set,
        p = Sg((d, g) => (r = d, i = g, {
            get() {
                return s.value && (n = c(n), s.value = !1), r(), n
            },
            set(m) {
                u == null || u(m)
            }
        }));
    return Object.isExtensible(p) && (p.trigger = a), p
}

function YS(e) {
    return Uo() ? (fs(e), !0) : !1
}

function XS(e, t) {
    return Kt(e)
}
const nm = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const EP = e => e != null,
    KS = Object.prototype.toString,
    CP = e => KS.call(e) === "[object Object]",
    pc = () => {},
    SP = QS();

function QS() {
    var e, t;
    return nm && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent))
}

function rm(e, t) {
    function n(...r) {
        return new Promise((i, s) => {
            Promise.resolve(e(() => t.apply(this, r), {
                fn: t,
                thisArg: this,
                args: r
            })).then(i).catch(s)
        })
    }
    return n
}

function JS(e, t = {}) {
    let n, r, i = pc;
    const s = u => {
        clearTimeout(u), i(), i = pc
    };
    let a;
    return u => {
        const p = pa(e),
            d = pa(t.maxWait);
        return n && s(n), p <= 0 || d !== void 0 && d <= 0 ? (r && (s(r), r = null), Promise.resolve(u())) : new Promise((g, m) => {
            i = t.rejectOnCancel ? m : g, a = u, d && !r && (r = setTimeout(() => {
                n && s(n), r = null, g(a())
            }, d)), n = setTimeout(() => {
                r && s(r), r = null, g(u())
            }, p)
        })
    }
}

function ZS(...e) {
    let t = 0,
        n, r = !0,
        i = pc,
        s, a, c, u, p;
    !mr(e[0]) && typeof e[0] == "object" ? {
        delay: a,
        trailing: c = !0,
        leading: u = !0,
        rejectOnCancel: p = !1
    } = e[0] : [a, c = !0, u = !0, p = !1] = e;
    const d = () => {
        n && (clearTimeout(n), n = void 0, i(), i = pc)
    };
    return m => {
        const E = pa(a),
            L = Date.now() - t,
            b = () => s = m();
        return d(), E <= 0 ? (t = Date.now(), b()) : (L > E && (u || !r) ? (t = Date.now(), b()) : c && (s = new Promise((j, A) => {
            i = p ? A : j, n = setTimeout(() => {
                t = Date.now(), r = !0, j(b()), d()
            }, Math.max(0, E - L))
        })), !u && !n && (n = setTimeout(() => r = !0, E)), r = !1, s)
    }
}

function TP(e) {
    let t;

    function n() {
        return t || (t = e()), t
    }
    return n.reset = async () => {
        const r = t;
        t = void 0, r && await r
    }, n
}

function PP(e) {
    return Array.isArray(e) ? e : [e]
}

function eT(e) {
    return wi()
}

function kP(e, t = 200, n = {}) {
    return rm(JS(t, n), e)
}

function AP(e, t = 200, n = !1, r = !0, i = !1) {
    return rm(ZS(t, n, r, i), e)
}

function qp(...e) {
    if (e.length === 2) {
        const [t, n] = e;
        t.value = n
    }
    if (e.length === 3) {
        const [t, n, r] = e;
        t[n] = r
    }
}

function RP(e, t = !0, n) {
    eT() ? $i(e, n) : t ? e() : ss(e)
}

function OP(e, t, n = {}) {
    const {
        immediate: r = !0,
        immediateCallback: i = !1
    } = n, s = Ur(!1);
    let a = null;

    function c() {
        a && (clearTimeout(a), a = null)
    }

    function u() {
        s.value = !1, c()
    }

    function p(...d) {
        i && e(), c(), s.value = !0, a = setTimeout(() => {
            s.value = !1, a = null, e(...d)
        }, pa(t))
    }
    return r && (s.value = !0, nm && p()), YS(u), {
        isPending: la(s),
        start: p,
        stop: u
    }
}

function MP(e, t, n) {
    return Qr(e, t, {
        ...n,
        immediate: !0
    })
}

function LP(e, t, n) {
    const r = Qr(e, (...i) => (ss(() => r()), t(...i)), n);
    return r
}
const tT = {
        class: "site-header"
    },
    nT = {
        class: "inner"
    },
    rT = {
        class: "nav | font-nav"
    },
    iT = ["aria-expanded"],
    sT = {
        ref: "mobileMenuRef",
        class: "mobile-menu"
    },
    oT = ["aria-hidden"],
    aT = Jr({
        __name: "SiteHeader",
        setup(e) {
            const t = Bc(),
                n = Mc(),
                {
                    data: r
                } = ux("config:storyblok"),
                i = xn(() => n.path.startsWith("/blog/")),
                s = k => !k || k === "home" ? "/" : `/${k}`,
                a = Wn("mobileMenuRef"),
                c = Ur(!0),
                u = Ur(!1),
                p = Wn("link");
            let d = null,
                g = null,
                m = null;
            const E = () => {
                    XS(u) ? (u.value = !1, w()) : (u.value = !0, $())
                },
                L = () => {
                    qp(c, !1), qp(u, !1), w()
                },
                b = () => {
                    var k;
                    n.name === "index" && ((k = t.value) == null || k.scrollTo(0))
                };
            $i(() => {
                j(), On.gsap.set(a.value, {
                    autoAlpha: 1,
                    clipPath: "inset(0% 0% 100% 0%)"
                })
            });
            const j = () => {
                    tm(() => {
                        m = hh.create(p.value, {
                            type: "lines, chars",
                            charsClass: "--char"
                        }), On.gsap.set(m.chars, {
                            xPercent: 50
                        })
                    })
                },
                A = {
                    from: "start",
                    amount: .3
                },
                $ = () => {
                    var k, S;
                    (k = t.value) == null || k.stop(), d == null || d.kill(), g == null || g.kill(), d = On.gsap.timeline({
                        defaults: {
                            overwrite: "auto"
                        }
                    }), d.fromTo(a.value, {
                        opacity: 0
                    }, {
                        opacity: 1,
                        duration: .3,
                        ease: "expo.out"
                    }, 0), d.to(a.value, {
                        clipPath: "inset(0% 0% 0% 0%)",
                        duration: 1.4,
                        ease: "menuEase"
                    }, 0), (S = p.value) == null || S.forEach((X, J) => {
                        const xe = X.querySelectorAll(".--char");
                        d == null || d.to(xe, {
                            opacity: 1,
                            stagger: A,
                            ease: "expo.out",
                            duration: 1.4
                        }, J * .11), d == null || d.to(xe, {
                            stagger: A,
                            xPercent: 0,
                            ease: "expo.out",
                            duration: .6
                        }, J * .11), d == null || d.to(xe, {
                            color: "var(--c-lime)",
                            stagger: A,
                            duration: .1,
                            ease: "expo.out"
                        }, J * .11), d == null || d.to(xe, {
                            color: "white",
                            stagger: A,
                            duration: .1,
                            ease: "expo.out"
                        }, J * .11 + .2)
                    })
                },
                w = () => {
                    var k, S;
                    (k = t.value) == null || k.start(), d == null || d.kill(), g == null || g.kill(), g = On.gsap.timeline({
                        defaults: {
                            overwrite: "auto"
                        }
                    }), g.to(a.value, {
                        clipPath: "inset(0% 0% 100% 0%)",
                        duration: .75,
                        ease: "power2.inOut"
                    }, 0), g.to(a.value, {
                        opacity: 0,
                        duration: .15
                    }, .55), (S = p.value) == null || S.forEach((X, J) => {
                        const xe = X.querySelectorAll(".--char");
                        g == null || g.set(xe, {
                            color: "var(--c-lime)",
                            stagger: .05
                        }, J * .05), g == null || g.to(xe, {
                            opacity: 0,
                            stagger: .05,
                            duration: .1
                        }, J * .05)
                    })
                };
            return (k, S) => {
                const X = _x,
                    J = Z0,
                    xe = em;
                return Mn(), Br("header", tT, [wn(xe, {
                    tag: "div"
                }, {
                    default: Ki(() => {
                        var he, me, Q, ne, re, K;
                        return [Kt(i) ? (Mn(), cs(X, {
                            key: 0,
                            to: "/resources",
                            class: "back-to-resources-button | font-nav",
                            "aria-label": "Back to Resources"
                        }, {
                            default: Ki(() => S[1] || (S[1] = [Xt("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                width: "24",
                                height: "25",
                                viewBox: "0 0 24 25",
                                fill: "currentColor"
                            }, [Xt("path", {
                                d: "M20 11.5H7.83L13.42 5.91L12 4.5L4 12.5L12 20.5L13.41 19.09L7.83 13.5H20V11.5Z",
                                fill: "currentColor"
                            })], -1), Xt("span", null, "Back to Resources", -1)])),
                            _: 1
                        })) : b_("", !0), Xt("div", nT, [wn(X, {
                            to: "/",
                            class: "logo-link",
                            "aria-label": "Go to homepage",
                            onClick: S[0] || (S[0] = () => {
                                L(), b()
                            })
                        }, {
                            default: Ki(() => [wn(J, {
                                class: "logo"
                            })]),
                            _: 1
                        }), Xt("nav", rT, [Xt("ul", null, [(Mn(!0), Br(zr, null, Qu(((Q = (me = (he = Kt(r)) == null ? void 0 : he.story) == null ? void 0 : me.content) == null ? void 0 : Q.navigation_items) || [], te => {
                            var G;
                            return Mn(), Br("li", {
                                key: te._uid
                            }, [wn(X, {
                                to: s((G = te.link.story) == null ? void 0 : G.slug)
                            }, {
                                default: Ki(() => [Gl(Uu(te.label), 1)]),
                                _: 2
                            }, 1032, ["to"])])
                        }), 128))])]), Xt("button", {
                            class: ya(["toggle-mobile-menu-button | label-6", {
                                active: Kt(u)
                            }]),
                            "aria-label": "Toggle menu",
                            "aria-expanded": Kt(u) ? "true" : "false",
                            "aria-haspopup": "true",
                            "aria-controls": "mobile-menu",
                            onClick: E
                        }, S[2] || (S[2] = [Xt("span", {
                            class: "wrapper"
                        }, [Xt("span", {
                            class: "hl --1 t"
                        }), Xt("span", {
                            class: "hl --2 t"
                        }), Xt("span", {
                            class: "cl --1 t"
                        }, [Xt("span", {
                            class: "cli --g t"
                        }), Xt("span", {
                            class: "cli t"
                        })]), Xt("span", {
                            class: "cl --2 t"
                        }, [Xt("span", {
                            class: "cli --g t"
                        }), Xt("span", {
                            class: "cli t"
                        })])], -1)]), 10, iT)]), Xt("div", sT, [Xt("nav", {
                            id: "mobile-menu",
                            ref: "mobileMenuItemsRef",
                            class: "mobile-menu-items | menu-typo",
                            "aria-hidden": Kt(u) ? "false" : "true"
                        }, [Xt("ul", null, [(Mn(!0), Br(zr, null, Qu(((K = (re = (ne = Kt(r)) == null ? void 0 : ne.story) == null ? void 0 : re.content) == null ? void 0 : K.navigation_items) || [], te => {
                            var G;
                            return Mn(), Br("li", {
                                ref_for: !0,
                                ref: "link",
                                key: te._uid
                            }, [wn(X, {
                                to: s((G = te.link.story) == null ? void 0 : G.slug),
                                onClick: L
                            }, {
                                default: Ki(() => [Gl(Uu(te.label), 1)]),
                                _: 2
                            }, 1032, ["to"])])
                        }), 128))])], 8, oT)], 512)]
                    }),
                    _: 1
                })])
            }
        }
    }),
    im = ba(aT, [
        ["__scopeId", "data-v-322736a5"]
    ]),
    lT = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: im
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    sm = (e = "RouteProvider") => Jr({
        name: e,
        props: {
            vnode: {
                type: Object,
                required: !0
            },
            route: {
                type: Object,
                required: !0
            },
            vnodeRef: Object,
            renderKey: String,
            trackRootNodes: Boolean
        },
        setup(t) {
            const n = t.renderKey,
                r = t.route,
                i = {};
            for (const s in t.route) Object.defineProperty(i, s, {
                get: () => n === t.renderKey ? t.route[s] : r[s],
                enumerable: !0
            });
            return ws(su, Ms(i)), () => jr(t.vnode, {
                ref: t.vnodeRef
            })
        }
    }),
    uT = sm(),
    Gp = new WeakMap,
    cT = Jr({
        name: "NuxtPage",
        inheritAttrs: !1,
        props: {
            name: {
                type: String
            },
            transition: {
                type: [Boolean, Object],
                default: void 0
            },
            keepalive: {
                type: [Boolean, Object],
                default: void 0
            },
            route: {
                type: Object
            },
            pageKey: {
                type: [Function, String],
                default: null
            }
        },
        setup(e, {
            attrs: t,
            slots: n,
            expose: r
        }) {
            const i = vr(),
                s = kn(),
                a = Er(su, null);
            let c;
            r({
                pageRef: s
            });
            const u = Er(a0, null);
            let p;
            const d = i.deferHydration();
            if (i.isHydrating) {
                const m = i.hooks.hookOnce("app:error", d);
                Qi().beforeEach(m)
            }
            e.pageKey && Qr(() => e.pageKey, (m, E) => {
                m !== E && i.callHook("page:loading:start")
            });
            let g = !1;
            {
                const m = Qi().beforeResolve(() => {
                    g = !1
                });
                va(() => {
                    m()
                })
            }
            return () => jr($0, {
                name: e.name,
                route: e.route,
                ...t
            }, {
                default: m => {
                    const E = hT(a, m.route, m.Component),
                        L = a && a.matched.length === m.route.matched.length;
                    if (!m.Component) {
                        if (p && !L) return p;
                        d();
                        return
                    }
                    if (p && u && !u.isCurrent(m.route)) return p;
                    if (E && a && (!u || u != null && u.isCurrent(a))) return L ? p : null;
                    const b = sh(m, e.pageKey),
                        j = dT(a, m.route, m.Component);
                    !i.isHydrating && c === b && !j && ss(() => {
                        g = !0, i.callHook("page:loading:end")
                    }), c = b;
                    const A = !!(e.transition ?? m.route.meta.pageTransition ?? qd),
                        $ = A && fT([e.transition, m.route.meta.pageTransition, qd, {
                            onBeforeLeave() {
                                i._runningTransition = !0
                            },
                            onAfterLeave() {
                                delete i._runningTransition, i.callHook("page:transition:finish", m.Component)
                            }
                        }]),
                        w = e.keepalive ?? m.route.meta.keepalive ?? ab;
                    return p = H0(A && $, YD(w, jr(Mh, {
                        suspensible: !0,
                        onPending: () => i.callHook("page:start", m.Component),
                        onResolve: () => {
                            ss(() => i.callHook("page:finish", m.Component).then(() => {
                                if (!g && !j) return g = !0, i.callHook("page:loading:end")
                            }).finally(d))
                        }
                    }, {
                        default: () => {
                            const k = {
                                key: b || void 0,
                                vnode: n.default ? pT(n.default, m) : m.Component,
                                route: m.route,
                                renderKey: b || void 0,
                                trackRootNodes: A,
                                vnodeRef: s
                            };
                            if (!w) return jr(uT, k);
                            const S = m.Component.type,
                                X = S;
                            let J = Gp.get(X);
                            return J || (J = sm(S.name || S.__name), Gp.set(X, J)), jr(J, k)
                        }
                    }))).default(), p
                }
            })
        }
    });

function fT(e) {
    const t = e.filter(Boolean).map(n => ({
        ...n,
        onAfterLeave: n.onAfterLeave ? Gh(n.onAfterLeave) : void 0
    }));
    return Oc(...t)
}

function hT(e, t, n) {
    if (!e) return !1;
    const r = t.matched.findIndex(i => {
        var s;
        return ((s = i.components) == null ? void 0 : s.default) === (n == null ? void 0 : n.type)
    });
    return !r || r === -1 ? !1 : t.matched.slice(0, r).some((i, s) => {
        var a, c, u;
        return ((a = i.components) == null ? void 0 : a.default) !== ((u = (c = e.matched[s]) == null ? void 0 : c.components) == null ? void 0 : u.default)
    }) || n && sh({
        route: t,
        Component: n
    }) !== sh({
        route: e,
        Component: n
    })
}

function dT(e, t, n) {
    return e ? t.matched.findIndex(i => {
        var s;
        return ((s = i.components) == null ? void 0 : s.default) === (n == null ? void 0 : n.type)
    }) < t.matched.length - 1 : !1
}

function pT(e, t) {
    const n = e(t);
    return n.length === 1 ? jr(n[0]) : jr(zr, void 0, n)
}
const gT = Jr({
        name: "LayoutLoader",
        inheritAttrs: !1,
        props: {
            name: String,
            layoutProps: Object
        },
        setup(e, t) {
            return () => jr(Io[e.name], e.layoutProps, t.slots)
        }
    }),
    _T = {
        name: {
            type: [String, Boolean, Object],
            default: null
        },
        fallback: {
            type: [String, Object],
            default: null
        }
    },
    mT = Jr({
        name: "NuxtLayout",
        inheritAttrs: !1,
        props: _T,
        setup(e, t) {
            const n = vr(),
                r = Er(su),
                i = r === Mc() ? jD() : r,
                s = xn(() => {
                    let u = Kt(e.name) ?? i.meta.layout ?? "default";
                    return u && !(u in Io) && e.fallback && (u = Kt(e.fallback)), u
                }),
                a = kn();
            t.expose({
                layoutRef: a
            });
            const c = n.deferHydration();
            if (n.isHydrating) {
                const u = n.hooks.hookOnce("app:error", c);
                Qi().beforeEach(u)
            }
            return () => {
                const u = s.value && s.value in Io,
                    p = i.meta.layoutTransition ?? ob;
                return H0(u && p, {
                    default: () => jr(Mh, {
                        suspensible: !0,
                        onResolve: () => {
                            ss(c)
                        }
                    }, {
                        default: () => jr(yT, {
                            layoutProps: Fh(t.attrs, {
                                ref: a
                            }),
                            key: s.value || void 0,
                            name: s.value,
                            shouldProvide: !e.name,
                            hasTransition: !!p
                        }, t.slots)
                    })
                }).default()
            }
        }
    }),
    yT = Jr({
        name: "NuxtLayoutProvider",
        inheritAttrs: !1,
        props: {
            name: {
                type: [String, Boolean]
            },
            layoutProps: {
                type: Object
            },
            hasTransition: {
                type: Boolean
            },
            shouldProvide: {
                type: Boolean
            }
        },
        setup(e, t) {
            const n = e.name;
            return e.shouldProvide && ws(a0, {
                isCurrent: r => n === (r.meta.layout ?? "default")
            }), () => {
                var r, i;
                return !n || typeof n == "string" && !(n in Io) ? (i = (r = t.slots).default) == null ? void 0 : i.call(r) : jr(gT, {
                    key: n,
                    layoutProps: e.layoutProps,
                    name: n
                }, t.slots)
            }
        }
    });
var Pn = (e => (e[e.top = 0] = "top", e[e.right = 1] = "right", e[e.bottom = 2] = "bottom", e[e.left = 3] = "left", e))(Pn || {});
const si = e => Math.round(e * 100) / 100,
    bf = (e, t) => ({
        x: e.x - t.x,
        y: e.y - t.y
    }),
    vT = (e, t) => ({
        x: e.x + t.x,
        y: e.y + t.y
    }),
    Yp = (e, t) => ({
        x: e.x * t,
        y: e.y * t
    }),
    Xp = e => {
        const t = Math.hypot(e.x, e.y);
        return t === 0 ? {
            x: 0,
            y: 0
        } : {
            x: e.x / t,
            y: e.y / t
        }
    },
    Kp = (e, t) => Math.hypot(t.x - e.x, t.y - e.y),
    Qp = (e, t, n) => {
        const r = Xp(bf(e, t)),
            i = Xp(bf(n, e)),
            s = -(r.x * i.x + r.y * i.y),
            a = Math.acos(Math.min(Math.max(s, -1), 1)) / 2,
            c = Kp(t, e),
            u = Kp(e, n),
            p = Math.min(c, u) / 2;
        let d = e.radius || 0;
        d > p && (d = p);
        const g = d * Math.tan(a),
            m = bf(e, Yp(r, d)),
            E = vT(e, Yp(i, d)),
            b = r.x * i.y - r.y * i.x < 0 ? 0 : 1;
        return {
            startPoint: m,
            endPoint: E,
            actualRadius: g,
            sweepFlag: b,
            isTooLarge: g >= 1e3
        }
    },
    gc = e => {
        if (e.length < 2) return "";
        const t = e[0],
            n = e[e.length - 1];
        let r = "";
        if (t.radius && e.length > 2) {
            const i = Qp(t, n, e[1]);
            r = `M ${si(i.startPoint.x)},${si(i.startPoint.y)}`, i.isTooLarge ? r += ` L ${si(i.endPoint.x)},${si(i.endPoint.y)}` : r += ` A ${si(i.actualRadius)},${si(i.actualRadius)} 0 0 ${i.sweepFlag} ${si(i.endPoint.x)},${si(i.endPoint.y)}`
        } else r = `M ${si(t.x)},${si(t.y)}`;
        for (let i = 1; i < e.length; i++) {
            const s = e[i];
            if (s.radius) {
                const a = e[i - 1],
                    c = i === e.length - 1 ? e[0] : e[i + 1],
                    u = Qp(s, a, c);
                u.isTooLarge ? r += ` L ${si(u.startPoint.x)},${si(u.startPoint.y)}` : r += ` L ${si(u.startPoint.x)},${si(u.startPoint.y)} A ${si(u.actualRadius)},${si(u.actualRadius)} 0 0 ${u.sweepFlag} ${si(u.endPoint.x)},${si(u.endPoint.y)}`
            } else r += ` L ${si(s.x)},${si(s.y)}`
        }
        return r
    },
    bT = {
        class: "svg-mask"
    },
    wT = ["width", "height", "viewBox"],
    DT = ["id"],
    xT = ["d"],
    ET = ["id"],
    CT = ["d"],
    So = .5,
    ST = Jr({
        __name: "SVGMask",
        props: {
            notches: {
                default: () => []
            },
            useClip: {
                type: Boolean,
                default: !0
            }
        },
        setup(e) {
            C1(b => ({
                d27fb6da: Kt(c),
                b18bdda2: Kt(a)
            }));
            const t = e,
                n = mi({
                    width: 0,
                    height: 0
                }),
                r = kn(!1),
                i = Wn("el"),
                s = cy(),
                a = xn(() => `url(#mask-${s})`),
                c = xn(() => `url(#clip-${s})`),
                u = xn(() => 1);
            xn(() => u.value * .5);
            const p = xn(() => ({
                    [Pn.top]: t.notches.filter(b => b.direction === Pn.top).map(b => ({
                        radius: b.radius ?? 8,
                        notchWidth: b.notchWidth ?? .9,
                        ...b
                    })).sort((b, j) => b.position - j.position),
                    [Pn.right]: t.notches.filter(b => b.direction === Pn.right).map(b => ({
                        radius: b.radius ?? 8,
                        notchWidth: b.notchWidth ?? .9,
                        ...b
                    })).sort((b, j) => b.position - j.position),
                    [Pn.bottom]: t.notches.filter(b => b.direction === Pn.bottom).map(b => ({
                        radius: b.radius ?? 8,
                        notchWidth: b.notchWidth ?? .9,
                        ...b
                    })).sort((b, j) => j.position - b.position),
                    [Pn.left]: t.notches.filter(b => b.direction === Pn.left).map(b => ({
                        radius: b.radius ?? 8,
                        notchWidth: b.notchWidth ?? .9,
                        ...b
                    })).sort((b, j) => j.position - b.position)
                })),
                d = xn(() => ({
                    [Pn.top]: E(Pn.top),
                    [Pn.right]: E(Pn.right),
                    [Pn.bottom]: E(Pn.bottom),
                    [Pn.left]: E(Pn.left)
                })),
                g = xn(() => {
                    const b = Math.max(-.5, d.value[Pn.left] - So),
                        j = Math.max(-.5, d.value[Pn.top] - So),
                        A = Math.min(n.width + So, n.width - d.value[Pn.right] + So),
                        $ = Math.min(n.height + So, n.height - d.value[Pn.bottom] + So);
                    return [{
                        x: b,
                        y: j
                    }, ...p.value[Pn.top].map(w => m(w)), {
                        x: A,
                        y: j
                    }, ...p.value[Pn.right].map(w => m(w)), {
                        x: A,
                        y: $
                    }, ...p.value[Pn.bottom].map(w => m(w)), {
                        x: b,
                        y: $
                    }, ...p.value[Pn.left].map(w => m(w)), {
                        x: b,
                        y: j
                    }].flat()
                });
            $i(() => {
                r.value = !0
            });

            function m(b) {
                const j = Xa.Arr.create(4).map(() => ({
                        x: 0,
                        y: 0,
                        radius: 40 / b.size * b.radius * .01
                    })),
                    A = (1 - b.notchWidth) * n.width * .25;
                switch (b.direction) {
                    case Pn.top: {
                        const $ = d.value[Pn.top];
                        j[0].x = n.width * (b.position - b.size * .5) - A, j[0].y = $, j[1].x = n.width * (b.position - b.size * .5) + A, j[1].y = $ + u.value * b.offset, j[2].x = n.width * (b.position + b.size * .5) - A, j[2].y = $ + u.value * b.offset, j[3].x = n.width * (b.position + b.size * .5) + A, j[3].y = $;
                        break
                    }
                    case Pn.right: {
                        const $ = d.value[Pn.right];
                        j[0].x = n.width - $, j[0].y = n.height * (b.position - b.size * .5) - A, j[1].x = n.width - $ - u.value * b.offset, j[1].y = n.height * (b.position - b.size * .5) + A, j[2].x = n.width - $ - u.value * b.offset, j[2].y = n.height * (b.position + b.size * .5) - A, j[3].x = n.width - $, j[3].y = n.height * (b.position + b.size * .5) + A;
                        break
                    }
                    case Pn.bottom: {
                        const $ = d.value[Pn.bottom];
                        j[0].x = n.width * (b.position + b.size * .5) + A, j[0].y = n.height - $, j[1].x = n.width * (b.position + b.size * .5) - A, j[1].y = n.height - $ - u.value * b.offset, j[2].x = n.width * (b.position - b.size * .5) + A, j[2].y = n.height - $ - u.value * b.offset, j[3].x = n.width * (b.position - b.size * .5) - A, j[3].y = n.height - $;
                        break
                    }
                    case Pn.left: {
                        const $ = d.value[Pn.left];
                        j[0].x = $, j[0].y = n.height * (b.position + b.size * .5) + A, j[1].x = $ + u.value * b.offset, j[1].y = n.height * (b.position + b.size * .5) - A, j[2].x = $ + u.value * b.offset, j[2].y = n.height * (b.position - b.size * .5) + A, j[3].x = $, j[3].y = n.height * (b.position - b.size * .5) - A;
                        break
                    }
                }
                return j
            }

            function E(b) {
                return Math.abs(p.value[b].reduce((j, A) => (b === Pn.bottom || b === Pn.top, Math.min(j, u.value * A.offset)), 0))
            }
            const L = Ur("");
            return Qr(g, () => {
                L.value = gc(g.value)
            }, {
                immediate: !0
            }), Hc(() => {}), $c(() => {
                var b, j;
                n.width = ((b = i.value) == null ? void 0 : b.offsetWidth) || 1, n.height = ((j = i.value) == null ? void 0 : j.offsetHeight) || 1
            }, void 0, !0), (b, j) => (Mn(), Br("div", bT, [(Mn(), Br("svg", {
                width: Kt(n).width,
                height: Kt(n).height,
                viewBox: `${-.5} ${-.5} ${Kt(n).width+So*2} ${Kt(n).height+So*2}`,
                class: "svg",
                "shape-rendering": "geometricPrecision"
            }, [Xt("defs", null, [t.useClip ? (Mn(), Br("clipPath", {
                key: 0,
                id: `clip-${Kt(s)}`,
                clipPathUnits: "userSpaceOnUse"
            }, [Xt("path", {
                d: Kt(L)
            }, null, 8, xT)], 8, DT)) : (Mn(), Br("mask", {
                key: 1,
                id: `mask-${Kt(s)}`
            }, [Xt("path", {
                d: Kt(L),
                fill: "white"
            }, null, 8, CT)], 8, ET))])], 8, wT)), Xt("div", {
                ref_key: "el",
                ref: i,
                class: ya(["slot", {
                    ssr: !Kt(r),
                    "use-clip": t.useClip
                }])
            }, [Xg(b.$slots, "default", {}, void 0, !0)], 2)]))
        }
    }),
    om = ba(ST, [
        ["__scopeId", "data-v-ebd3c3c9"]
    ]),
    TT = {
        xmlns: "http://www.w3.org/2000/svg",
        width: "1920",
        height: "1080",
        fill: "none",
        viewBox: "0 0 1920 1080"
    };

function PT(e, t) {
    return Mn(), Br("svg", TT, t[0] || (t[0] = [v_('<path stroke="url(#a)" d="M-700.91 637.033c-35.991 0-65.09-29.072-65.09-65.03V243.03c0-35.958 29.099-65.03 65.09-65.03h443.989c17.306 0 33.846 6.885 46.099 19.126l333.719 333.258a53 53 0 0 0 4.135 4.132c10.261 9.333 23.739 15.301 38.748 15.913 35.071 1.377 63.711-29.99 63.711-65.03V243.03c0-35.958 29.099-65.03 65.09-65.03H696.5c38.66 0 70-31.34 70-70v-298" opacity=".15"></path><path stroke="url(#b)" d="M1243-383v495.474c0 35.957 29.1 65.029 65.09 65.029h275.35c35.99 0 65.09 29.072 65.09 65.03V436.5c0 33.137 26.87 60 60 60H2002" opacity=".15"></path><path stroke="#052424" d="m284 1160.5 252.476-251.616a26 26 0 0 0 2.91-2.908c9.802-10.557 15.928-24.481 16.54-39.782C557.152 831.46 525.602 803 490.837 803H-7M1270 1115V913.089c0-35.99 29.07-65.089 65.03-65.089h429.55a79.98 79.98 0 0 1 46.91 15.195L2082 1059" opacity=".15"></path><defs><linearGradient id="a" x1="384.5" x2="384.5" y1="53.5" y2="-181" gradientUnits="userSpaceOnUse"><stop stop-color="#052424"></stop><stop offset="1" stop-color="#052424" stop-opacity="0"></stop></linearGradient><linearGradient id="b" x1="1445.77" x2="1445.77" y1="-389.5" y2="726" gradientUnits="userSpaceOnUse"><stop stop-color="#052424" stop-opacity="0"></stop><stop offset=".25" stop-color="#052424"></stop><stop offset=".75" stop-color="#052424"></stop><stop offset="1" stop-color="#052424" stop-opacity="0"></stop></linearGradient></defs>', 4)]))
}
const Jp = {
        render: PT
    },
    kT = {
        ref: "topMask",
        class: "top-mask"
    },
    AT = {
        ref: "fullWrapperTop",
        class: "full-wrapper"
    },
    RT = {
        ref: "backgroundWrapperTop",
        class: "background-wrapper"
    },
    OT = {
        ref: "bottomMask",
        class: "bottom-mask"
    },
    MT = {
        ref: "fullWrapperBottom",
        class: "full-wrapper"
    },
    LT = {
        ref: "backgroundWrapperBottom",
        class: "background-wrapper"
    },
    FT = Jr({
        __name: "AppTransition",
        setup(e, {
            expose: t
        }) {
            const n = Wn("el"),
                r = Wn("bgOverlayEl"),
                i = Wn("overlayEl"),
                s = Wn("loaderEl"),
                a = Wn("topEl"),
                c = Wn("bottomEl"),
                u = Wn("fullWrapperTop"),
                p = Wn("fullWrapperBottom");
            Wn("backgroundWrapperTop"), Wn("backgroundWrapperBottom");
            const d = cu(),
                g = mi([{
                    direction: Pn.bottom,
                    notchWidth: .95,
                    offset: 0,
                    position: .5,
                    radius: 40,
                    size: .75
                }]),
                m = mi([{
                    direction: Pn.top,
                    notchWidth: .95,
                    offset: 0,
                    position: .5,
                    radius: 40,
                    size: .75
                }]),
                E = kn(!1),
                L = xn(() => d.value ? 40 : 20);
            return t({
                show: () => {
                    E.value = !0;
                    const A = On.gsap.timeline();
                    return On.gsap.set(n.value, {
                        autoAlpha: 1
                    }), On.gsap.set(s.value, {
                        opacity: 0
                    }), A.to(i.value, {
                        opacity: 1,
                        ease: "power1.out",
                        duration: .4
                    }), A
                },
                hide: () => {
                    E.value = !1;
                    const A = On.gsap.timeline();
                    return On.gsap.set(i.value, {
                        opacity: 0
                    }), On.gsap.set(s.value, {
                        opacity: 1
                    }), A.fromTo(r.value, {
                        opacity: 1
                    }, {
                        opacity: 0,
                        ease: "power1.in",
                        duration: .8
                    }, 0), A.fromTo(a.value, {
                        yPercent: 0
                    }, {
                        yPercent: -100,
                        ease: "expo.inOut",
                        duration: 1.2
                    }, 0), A.fromTo(c.value, {
                        yPercent: 0
                    }, {
                        yPercent: 100,
                        ease: "expo.inOut",
                        duration: 1.2
                    }, "<"), A.fromTo(u.value, {
                        yPercent: 0
                    }, {
                        yPercent: 50,
                        ease: "expo.inOut",
                        duration: 1.2
                    }, "<"), A.fromTo(p.value, {
                        yPercent: 0
                    }, {
                        yPercent: -50,
                        ease: "expo.inOut",
                        duration: 1.2
                    }, "<"), A.fromTo([g, m], {
                        offset: 0,
                        size: .5
                    }, {
                        offset: L.value,
                        size: .9,
                        ease: "custom.fastInOut",
                        duration: .6
                    }, "<"), A.to([g, m], {
                        offset: -L.value,
                        ease: "expo.out",
                        duration: .6
                    }, "<0.6"), A.set(n.value, {
                        autoAlpha: 0
                    }), A
                }
            }), (A, $) => {
                const w = om;
                return Mn(), Br("div", {
                    ref_key: "el",
                    ref: n,
                    class: ya(["app-transition", {
                        active: Kt(E)
                    }])
                }, [Xt("div", {
                    ref_key: "bgOverlayEl",
                    ref: r,
                    class: "bg-overlay"
                }, null, 512), Xt("div", {
                    ref_key: "loaderEl",
                    ref: s,
                    class: "loader"
                }, [Xt("div", {
                    ref_key: "topEl",
                    ref: a,
                    class: "top"
                }, [wn(w, {
                    "use-clip": "",
                    notches: Kt(g)
                }, {
                    default: Ki(() => [Xt("div", kT, [Xt("div", AT, [Xt("div", RT, [wn(Kt(Jp))], 512)], 512)], 512)]),
                    _: 1
                }, 8, ["notches"])], 512), Xt("div", {
                    ref_key: "bottomEl",
                    ref: c,
                    class: "bottom"
                }, [wn(w, {
                    "use-clip": "",
                    notches: Kt(m)
                }, {
                    default: Ki(() => [Xt("div", OT, [Xt("div", MT, [Xt("div", LT, [wn(Kt(Jp))], 512)], 512)], 512)]),
                    _: 1
                }, 8, ["notches"])], 512)], 512), Xt("div", {
                    ref_key: "overlayEl",
                    ref: i,
                    class: "overlay"
                }, null, 512)], 2)
            }
        }
    }),
    am = ba(FT, [
        ["__scopeId", "data-v-2a5cb2b0"]
    ]),
    IT = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: am
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    NT = ["viewBox"],
    BT = {
        id: "mask",
        x: "0",
        y: "0",
        width: "100",
        height: "100",
        maskUnits: "userSpaceOnUse",
        maskContentUnits: "userSpaceOnUse"
    },
    $T = ["d"],
    HT = ["d"],
    VT = ["d"],
    zT = ["d"],
    To = 10,
    pl = 100,
    wf = 100,
    Kr = 100 / 3,
    Li = 3,
    Pa = 2,
    jT = Jr({
        __name: "Logo",
        setup(e, {
            expose: t
        }) {
            const n = Wn("el"),
                r = Wn("svgEl"),
                i = Wn("textEl"),
                s = Wn("maskEl"),
                a = Wn("letterEl"),
                c = Wn("charWrapperEls"),
                u = Wn("charEls"),
                p = mi([{
                    x: 0,
                    y: 0,
                    radius: Li
                }, {
                    x: Kr * 1,
                    y: 0,
                    radius: Li
                }, {
                    x: Kr * 2,
                    y: 0,
                    radius: Li
                }, {
                    x: Kr * 2,
                    y: 0,
                    radius: Li
                }, {
                    x: Kr * 3,
                    y: 0,
                    radius: Li
                }, {
                    x: Kr * 3,
                    y: Kr,
                    radius: Li
                }, {
                    x: Kr * 2,
                    y: Kr,
                    radius: Li
                }, {
                    x: Kr * 2,
                    y: Kr * 2,
                    radius: Li
                }, {
                    x: Kr * 2,
                    y: Kr * 3,
                    radius: Li
                }, {
                    x: Kr,
                    y: Kr * 3,
                    radius: Li
                }, {
                    x: Kr,
                    y: Kr,
                    radius: Li
                }, {
                    x: 0,
                    y: Kr,
                    radius: Li
                }]),
                d = mi([{
                    x: To,
                    y: 0,
                    radius: Pa
                }, {
                    x: 100,
                    y: 0,
                    radius: Pa
                }, {
                    x: 100,
                    y: 100 - To,
                    radius: Pa
                }, {
                    x: 100 - To,
                    y: 100,
                    radius: Pa
                }, {
                    x: 0,
                    y: 100,
                    radius: Pa
                }, {
                    x: 0,
                    y: To,
                    radius: Pa
                }]),
                g = xn(() => p.map(b => ({
                    x: Xa.map(b.x, 0, pl, To, pl - To),
                    y: Xa.map(b.y, 0, wf, To, pl - To),
                    radius: b.radius
                })));
            Ol(() => {});
            const m = Ur(""),
                E = Ur("");
            return Ol(() => {
                m.value = gc(g.value)
            }), Ol(() => {
                E.value = gc(d)
            }), t({
                play: () => {
                    const b = On.gsap.timeline();
                    return b.set(n.value, {
                        autoAlpha: 1
                    }, 0), b.set(r.value, {
                        x: () => (n.value.offsetWidth - r.value.clientWidth) * .5
                    }), b.set(i.value, {
                        x: () => -(n.value.offsetWidth - i.value.offsetWidth) * .5
                    }), b.fromTo(a.value, {
                        scale: 0,
                        transformOrigin: "center center"
                    }, {
                        scale: 1,
                        ease: "custom.fastInOut",
                        duration: 1
                    }, "<"), b.fromTo(p, {
                        radius: 0
                    }, {
                        radius: Li,
                        ease: "custom.fastInOut",
                        duration: 1.4
                    }, "<0.1"), b.fromTo(p[2], {
                        y: 0
                    }, {
                        y: Kr - Li,
                        ease: "custom.fastInOut",
                        duration: 1
                    }, "<"), b.fromTo(p[3], {
                        x: Kr * 2 + Li
                    }, {
                        x: Kr * 2,
                        ease: "custom.fastInOut",
                        duration: 1
                    }, "<"), b.to(p[6], {
                        x: Kr + Li,
                        ease: "custom.fastInOut",
                        duration: 1
                    }, "<"), b.to([i.value, r.value], {
                        x: 0,
                        ease: "expo.inOut",
                        duration: 1.2
                    }, "<0.8"), b.fromTo(s.value, {
                        scale: 0,
                        transformOrigin: "top right"
                    }, {
                        scale: 1,
                        ease: "expo.inOut",
                        duration: 1.2
                    }, "<"), b.fromTo(c.value, {
                        yPercent: 100
                    }, {
                        yPercent: 0,
                        ease: "expo.out",
                        duration: 1,
                        stagger: {
                            each: .04,
                            from: "end"
                        }
                    }, "<0.4"), b.fromTo(u.value, {
                        yPercent: -100
                    }, {
                        yPercent: 0,
                        ease: "expo.out",
                        duration: 1,
                        stagger: {
                            each: .04,
                            from: "end"
                        }
                    }, "<"), b
                }
            }), (b, j) => (Mn(), Br("div", {
                ref_key: "el",
                ref: n,
                class: "animated-logo"
            }, [(Mn(), Br("svg", {
                ref_key: "svgEl",
                ref: r,
                width: pl,
                height: wf,
                viewBox: `0 0 ${pl} ${wf}`,
                xmlns: "http://www.w3.org/2000/svg"
            }, [Xt("defs", null, [Xt("mask", BT, [Xt("path", {
                ref_key: "maskEl",
                ref: s,
                d: Kt(E),
                fill: "white"
            }, null, 8, $T)])]), Xt("path", {
                mask: "url(#mask)",
                d: Kt(E),
                fill: "var(--c-dark-green)"
            }, null, 8, HT), Xt("g", {
                ref_key: "letterEl",
                ref: a
            }, [Xt("path", {
                d: Kt(m),
                fill: "var(--c-dark-green)"
            }, null, 8, VT), Xt("path", {
                d: Kt(m),
                fill: "#ededed",
                mask: "url(#mask)"
            }, null, 8, zT)], 512)], 8, NT)), Xt("span", {
                ref_key: "textEl",
                ref: i,
                class: "text"
            }, [(Mn(), Br(zr, null, Qu("Terminal", (A, $) => Xt("span", {
                key: $,
                ref_for: !0,
                ref_key: "charWrapperEls",
                ref: c,
                class: "char-wrapper"
            }, [Xt("span", {
                ref_for: !0,
                ref_key: "charEls",
                ref: u,
                class: "char"
            }, Uu(A), 513)])), 64))], 512)], 512))
        }
    }),
    UT = ba(jT, [
        ["__scopeId", "data-v-b5fe9da5"]
    ]),
    WT = ["width", "height", "viewBox"],
    qT = ["d", "stroke"],
    GT = Jr({
        __name: "Background",
        props: {
            strokeColor: {
                default: void 0
            },
            shapeOpacity: {
                default: 1
            }
        },
        setup(e) {
            const t = e,
                n = Wn("el"),
                r = mi({
                    width: 0,
                    height: 0
                }),
                i = cu(),
                s = xn(() => i.value ? [
                    [{
                        x: r.width * .4,
                        y: 0,
                        radius: 0
                    }, {
                        x: r.width * .4,
                        y: r.height * .15,
                        radius: 50
                    }, {
                        x: r.width * .25,
                        y: r.height * .15,
                        radius: 50
                    }, {
                        x: r.width * .1,
                        y: r.height * .15,
                        radius: 50
                    }, {
                        x: r.width * .1,
                        y: r.height * .55,
                        radius: 75
                    }, {
                        x: 0,
                        y: r.height * .37,
                        radius: 0
                    }],
                    [{
                        x: r.width * .6,
                        y: 0,
                        radius: 0
                    }, {
                        x: r.width * .6,
                        y: r.height * .23,
                        radius: 50
                    }, {
                        x: r.width * .9,
                        y: r.height * .23,
                        radius: 50
                    }, {
                        x: r.width * .9,
                        y: r.height * .45,
                        radius: 50
                    }, {
                        x: r.width,
                        y: r.height * .45,
                        radius: 0
                    }],
                    [{
                        x: r.width,
                        y: r.height * .9,
                        radius: 0
                    }, {
                        x: r.width * .95,
                        y: r.height * .8,
                        radius: 20
                    }, {
                        x: r.width * .7,
                        y: r.height * .8,
                        radius: 50
                    }, {
                        x: r.width * .7,
                        y: r.height,
                        radius: 0
                    }],
                    [{
                        x: 0,
                        y: r.height * .8,
                        radius: 0
                    }, {
                        x: r.width * .25,
                        y: r.height * .8,
                        radius: 75
                    }, {
                        x: r.width * .15,
                        y: r.height,
                        radius: 0
                    }]
                ] : [
                    [{
                        x: 0,
                        y: r.height * .05,
                        radius: 0
                    }, {
                        x: r.width * .2,
                        y: r.height * .05,
                        radius: 20
                    }, {
                        x: r.width * .7,
                        y: r.height * .3,
                        radius: 60
                    }, {
                        x: r.width * .7,
                        y: r.height * .05,
                        radius: 30
                    }, {
                        x: r.width,
                        y: r.height * .05,
                        radius: 0
                    }],
                    [{
                        x: r.width,
                        y: r.height * .8,
                        radius: 0
                    }, {
                        x: r.width * .7,
                        y: r.height * .8,
                        radius: 30
                    }, {
                        x: r.width * .7,
                        y: r.height,
                        radius: 0
                    }],
                    [{
                        x: 0,
                        y: r.height * .75,
                        radius: 0
                    }, {
                        x: r.width * .3,
                        y: r.height * .75,
                        radius: 75
                    }, {
                        x: 0,
                        y: r.height * .95,
                        radius: 0
                    }]
                ]),
                a = xn(() => s.value.map(c => gc(c)));
            return $c(() => {
                var c, u;
                r.width = ((c = n.value) == null ? void 0 : c.clientWidth) || 1, r.height = ((u = n.value) == null ? void 0 : u.clientHeight) || 1
            }, void 0, !0), (c, u) => (Mn(), Br("svg", {
                ref_key: "el",
                ref: n,
                width: Kt(r).width,
                height: Kt(r).height,
                viewBox: `0 0 ${Kt(r).width} ${Kt(r).height}`,
                class: "svg"
            }, [(Mn(!0), Br(zr, null, Qu(Kt(a), (p, d) => (Mn(), Br("path", {
                key: d,
                ref_for: !0,
                ref: "fullPath",
                d: p,
                stroke: t.strokeColor || "#052424",
                fill: "none",
                "stroke-opacity": "0.15",
                "stroke-width": "1"
            }, null, 8, qT))), 128))], 8, WT))
        }
    }),
    Zp = ba(GT, [
        ["__scopeId", "data-v-aaa1b985"]
    ]),
    YT = {
        class: "app-loader"
    },
    XT = {
        ref: "loader",
        class: "loader"
    },
    KT = {
        ref: "topMask",
        class: "top-mask"
    },
    QT = {
        ref: "fullWrapperTop",
        class: "full-wrapper"
    },
    JT = {
        ref: "backgroundWrapperTop",
        class: "background-wrapper"
    },
    ZT = {
        class: "logo-wrapper"
    },
    e2 = {
        ref: "bottomMask",
        class: "bottom-mask"
    },
    t2 = {
        ref: "fullWrapperBottom",
        class: "full-wrapper"
    },
    n2 = {
        ref: "backgroundWrapperBottom",
        class: "background-wrapper"
    },
    r2 = {
        class: "logo-wrapper"
    },
    i2 = Jr({
        __name: "AppLoader",
        emits: ["loaded", "animate"],
        setup(e, {
            emit: t
        }) {
            const n = t,
                r = Wn("overlayEl"),
                i = Wn("topEl"),
                s = Wn("bottomEl"),
                a = Wn("fullWrapperTop"),
                c = Wn("fullWrapperBottom"),
                u = Wn("backgroundWrapperTop"),
                p = Wn("backgroundWrapperBottom"),
                d = Wn("svgLogoTop"),
                g = Wn("svgLogoBottom"),
                m = cu(),
                E = xn(() => m.value ? 40 : 20),
                L = mi([{
                    direction: Pn.bottom,
                    notchWidth: .95,
                    offset: 0,
                    position: .5,
                    radius: 40,
                    size: .75
                }]),
                b = mi([{
                    direction: Pn.top,
                    notchWidth: .95,
                    offset: 0,
                    position: .5,
                    radius: 40,
                    size: .75
                }]),
                j = Bc();
            return $i(() => {
                var A;
                (A = j.value) == null || A.stop(), tm(() => {
                    const $ = On.gsap.timeline({
                        delay: .2
                    });
                    $.add(d.value.play(), 0), $.add(g.value.play(), 0), $.fromTo([u.value, p.value], {
                        scale: 2,
                        opacity: 0,
                        rotate: 20
                    }, {
                        scale: 1,
                        opacity: 1,
                        rotate: 0,
                        ease: "expo.out",
                        duration: 2
                    }, "<"), $.fromTo(i.value, {
                        yPercent: 0
                    }, {
                        yPercent: -100,
                        ease: "expo.inOut",
                        duration: 1.2
                    }), $.fromTo(s.value, {
                        yPercent: 0
                    }, {
                        yPercent: 100,
                        ease: "expo.inOut",
                        duration: 1.2
                    }, "<"), $.fromTo(a.value, {
                        yPercent: 0
                    }, {
                        yPercent: 50,
                        ease: "expo.inOut",
                        duration: 1.2
                    }, "<"), $.to(r.value, {
                        opacity: 0,
                        ease: "power1.in",
                        duration: .8
                    }, "<"), $.call(() => {
                        var w;
                        (w = j.value) == null || w.scrollTo(0, {
                            immediate: !0,
                            force: !0
                        })
                    }, [], "<"), $.fromTo(c.value, {
                        yPercent: 0
                    }, {
                        yPercent: -50,
                        ease: "expo.inOut",
                        duration: 1.2
                    }, "<"), $.fromTo([L, b], {
                        offset: 0,
                        size: .5
                    }, {
                        offset: E.value,
                        size: .9,
                        ease: "expo.out",
                        duration: .6
                    }, "<"), $.to([L, b], {
                        offset: -E.value,
                        ease: "expo.out",
                        duration: .6
                    }, "<0.6"), $.call(() => {
                        var w;
                        n("animate"), (w = j.value) == null || w.start()
                    }, [], "<"), $.call(() => {
                        n("loaded")
                    })
                })
            }), (A, $) => {
                const w = UT,
                    k = om;
                return Mn(), Br("div", YT, [Xt("div", {
                    ref_key: "overlayEl",
                    ref: r,
                    class: "overlay"
                }, null, 512), Xt("div", XT, [Xt("div", {
                    ref_key: "topEl",
                    ref: i,
                    class: "top"
                }, [wn(k, {
                    "use-clip": "",
                    notches: Kt(L)
                }, {
                    default: Ki(() => [Xt("div", KT, [Xt("div", QT, [Xt("div", JT, [wn(Kt(Zp))], 512), Xt("div", ZT, [wn(w, {
                        ref_key: "svgLogoTop",
                        ref: d
                    }, null, 512)])], 512)], 512)]),
                    _: 1
                }, 8, ["notches"])], 512), Xt("div", {
                    ref_key: "bottomEl",
                    ref: s,
                    class: "bottom"
                }, [wn(k, {
                    "use-clip": "",
                    notches: Kt(b)
                }, {
                    default: Ki(() => [Xt("div", e2, [Xt("div", t2, [Xt("div", n2, [wn(Kt(Zp))], 512), Xt("div", r2, [wn(w, {
                        ref_key: "svgLogoBottom",
                        ref: g
                    }, null, 512)])], 512)], 512)]),
                    _: 1
                }, 8, ["notches"])], 512)], 512)])
            }
        }
    }),
    lm = ba(i2, [
        ["__scopeId", "data-v-068da249"]
    ]),
    s2 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: lm
    }, Symbol.toStringTag, {
        value: "Module"
    }));

function um(e) {
    const t = Symbol();
    return [i => {
        const s = e(i),
            a = Object.assign(s, i);
        return ws(t, a), a
    }, i => Er(t, i), t]
}
const [o2, FP] = um(() => {
    const e = kn(1),
        t = kn(1),
        n = xn(() => t.value / e.value),
        r = kn(0),
        i = kn(0),
        s = kn(void 0);
    return uu(() => {
        const a = cu();
        Qr(a, c => s.value = c, {
            immediate: !0
        }), Bc(c => {
            r.value = c.animatedScroll, i.value = c.direction
        })
    }), $c(a => {
        t.value = document.documentElement.clientWidth, e.value = a.height, document.documentElement.style.setProperty("--svw", t.value / 100 + "px")
    }), {
        vh: la(e),
        vw: la(t),
        isLg: la(s),
        aspectRatio: la(n),
        lenisScroll: la(r),
        lenisDirection: la(i)
    }
}), [a2, IP] = um(() => {
    const e = kn(!1),
        t = Ms({
            x: 0,
            y: 0
        }),
        n = Ms({
            x: 0,
            y: 0
        });
    Hc(({
        dt: s
    }) => {
        n.x = Xa.Damp(n.x, t.x, 6, s), n.y = Xa.Damp(n.y, t.y, 6, s)
    });
    const r = s => {
            t.x = s.clientX, t.y = s.clientY, e.value || (n.x = t.x, n.y = t.y, e.value = !0)
        },
        i = s => {
            if (s.touches.length > 0) {
                const a = s.touches[0];
                a && (t.x = a.clientX, t.y = a.clientY, e.value || (n.x = t.x, n.y = t.y, e.value = !0))
            }
        };
    return $i(() => {
        document.addEventListener("mousemove", r), document.addEventListener("dragover", r), document.addEventListener("touchstart", i), document.addEventListener("touchmove", i)
    }), va(() => {
        document.removeEventListener("dragover", r), document.removeEventListener("mousemove", r), document.removeEventListener("touchstart", i), document.removeEventListener("touchmove", i)
    }), {
        mouse: t,
        mouseDamp: n,
        hasMoved: e
    }
});
async function l2() {
    const e = RC(),
        {
            public: {
                storyblokVersion: t
            }
        } = Bs(),
        {
            data: n
        } = await e.get("cdn/stories/config", {
            version: t,
            resolve_links: "url"
        });
    return n
}
const u2 = Nb("loader", () => {
        const t = !Bs().public.IS_PRODUCTION,
            n = kn(t),
            r = kn(t);
        return {
            loaded: n,
            animate: r
        }
    }),
    c2 = {
        id: "app"
    },
    f2 = Jr({
        __name: "app",
        async setup(e) {
            let t, n;
            o2({}), a2({}), [t, n] = Ty(() => lx("config:storyblok", () => l2())), await t, n();
            const r = u2(),
                i = Wn("lenisRef"),
                s = Wn("appTransitionComp");
            Ol(() => {
                Hc(({
                    et: p
                }) => {
                    var d, g;
                    (g = (d = i.value) == null ? void 0 : d.lenis) == null || g.raf(p * 1e3)
                }, 9999)
            }), $i(() => {
                ss(() => {
                    da.refresh()
                }), Bc(() => {
                    da.update()
                })
            });
            const a = () => {
                    r.loaded = !0
                },
                c = () => {
                    r.animate = !0
                },
                u = {
                    mode: "out-in",
                    onBeforeEnter: p => {
                        var d;
                        (d = i.value) == null || d.lenis.scrollTo(0, {
                            immediate: !0,
                            force: !0
                        })
                    },
                    onLeave: (p, d) => {
                        const g = On.gsap.timeline();
                        g.add(s.value.show()), g.call(d)
                    },
                    onEnter: (p, d) => {
                        const g = On.gsap.timeline();
                        g.add(s.value.hide()), g.call(d)
                    }
                };
            return D0({
                link: [{
                    rel: "preload",
                    href: "/static/fonts/SuisseIntl-Regular.woff2",
                    crossorigin: "",
                    as: "font",
                    type: "font/woff2"
                }, {
                    rel: "preload",
                    href: "/static/fonts/SuisseIntl-Medium.woff2",
                    crossorigin: "",
                    as: "font",
                    type: "font/woff2"
                }, {
                    rel: "apple-touch-icon",
                    sizes: "180x180",
                    href: "/static/apple-touch-icon.png"
                }, {
                    rel: "icon",
                    type: "image/png",
                    sizes: "96x96",
                    href: "/static/favicon-96x96.png"
                }, {
                    rel: "icon",
                    type: "image/png",
                    sizes: "192x192",
                    href: "/static/favicon-192x192.png"
                }, {
                    rel: "icon",
                    type: "image/png",
                    sizes: "512x512",
                    href: "/static/favicon-512x512.png"
                }, {
                    rel: "icon",
                    type: "image/svg+xml",
                    href: "/static/favicon.svg"
                }, {
                    rel: "shortcut icon",
                    href: "/static/favicon.ico"
                }, {
                    rel: "manifest",
                    href: "/static/site.webmanifest"
                }]
            }), (p, d) => {
                const g = im,
                    m = cT,
                    E = mT,
                    L = am,
                    b = lm;
                return Mn(), Br("div", null, [wn(Kt(Y0), {
                    ref_key: "lenisRef",
                    ref: i,
                    root: "",
                    "auto-raf": !1
                }, {
                    default: Ki(() => [Xt("div", c2, [wn(g), wn(E, null, {
                        default: Ki(() => [wn(m, {
                            transition: u
                        })]),
                        _: 1
                    })])]),
                    _: 1
                }, 512), wn(L, {
                    ref_key: "appTransitionComp",
                    ref: s
                }, null, 512), Kt(r).loaded ? b_("", !0) : (Mn(), cs(b, {
                    key: 0,
                    onLoaded: a,
                    onAnimate: c
                }))])
            }
        }
    }),
    h2 = {
        __name: "error",
        setup(e) {
            const t = zD();
            return $i(() => {
                t.push("/")
            }), (n, r) => (Mn(), Br("div"))
        }
    },
    d2 = {
        key: 0
    },
    eg = {
        __name: "nuxt-root",
        setup(e) {
            const t = () => null,
                n = vr(),
                r = n.deferHydration();
            if (n.isHydrating) {
                const u = n.hooks.hookOnce("app:error", r);
                Qi().beforeEach(u)
            }
            const i = !1;
            ws(su, Mc()), n.hooks.callHookWith(u => u.map(p => p()), "vue:setup");
            const s = Lc(),
                a = !1;
            Gg((u, p, d) => {
                if (n.hooks.callHook("vue:error", u, p, d).catch(g => console.error("[nuxt] Error in `vue:error` hook", g)), u0(u) && (u.fatal || u.unhandled)) return n.runWithContext(() => ua(u)), !1
            });
            const c = !1;
            return (u, p) => (Mn(), cs(Mh, {
                onResolve: Kt(r)
            }, {
                default: Ki(() => [Kt(a) ? (Mn(), Br("div", d2)) : Kt(s) ? (Mn(), cs(Kt(h2), {
                    key: 1,
                    error: Kt(s)
                }, null, 8, ["error"])) : Kt(c) ? (Mn(), cs(Kt(t), {
                    key: 2,
                    context: Kt(c)
                }, null, 8, ["context"])) : Kt(i) ? (Mn(), cs(Al(Kt(i)), {
                    key: 3
                })) : (Mn(), cs(Kt(f2), {
                    key: 4
                }))]),
                _: 1
            }, 8, ["onResolve"]))
        }
    };
let tg;
{
    let e;
    tg = async function() {
        var a, c;
        if (e) return e;
        const r = !!(((a = window.__NUXT__) == null ? void 0 : a.serverRendered) ?? ((c = document.getElementById("__NUXT_DATA__")) == null ? void 0 : c.dataset.ssr) === "true") ? z_(eg) : zf(eg),
            i = db({
                vueApp: r
            });
        async function s(u) {
            var p;
            await i.callHook("app:error", u), (p = i.payload).error || (p.error = Bo(u))
        }
        r.config.errorHandler = s, i.hook("app:suspense:resolve", () => {
            r.config.errorHandler === s && (r.config.errorHandler = void 0)
        });
        try {
            await _b(i, NS)
        } catch (u) {
            s(u)
        }
        try {
            await i.hooks.callHook("app:created", r), await i.hooks.callHook("app:beforeMount", r), r.mount(cb), await i.hooks.callHook("app:mounted", r), await ss()
        } catch (u) {
            s(u)
        }
        return r
    }, e = tg().catch(t => {
        throw console.error("Error while mounting app:", t), t
    })
}
export {
    vr as $, ya as A, S2 as B, O2 as C, vP as D, Wn as E, zr as F, mi as G, $c as H, wP as I, RC as J, tm as K, uu as L, om as M, Pn as N, Gl as O, _x as P, Xa as Q, pa as R, da as S, bc as T, Al as U, Xg as V, hh as W, On as X, C1 as Y, j2 as Z, ba as _, Xt as a, fs as a$, Fh as a0, g2 as a1, cu as a2, Qr as a3, DP as a4, Bc as a5, Hc as a6, cy as a7, gc as a8, jr as a9, nm as aA, PP as aB, EP as aC, kP as aD, OP as aE, CP as aF, Ol as aG, TP as aH, wi as aI, Bn as aJ, WS as aK, v1 as aL, XS as aM, Qi as aN, bP as aO, x1 as aP, dP as aQ, mr as aR, Vf as aS, Qt as aT, Ht as aU, v_ as aV, hi as aW, hP as aX, um as aY, GS as aZ, J0 as a_, us as aa, go as ab, ss as ac, Oc as ad, _P as ae, Qs as af, Rc as ag, K_ as ah, Sv as ai, u2 as aj, IP as ak, FP as al, lu as am, Wg as an, W2 as ao, Y2 as ap, pc as aq, SP as ar, MP as as, YS as at, Ur as au, LP as av, xP as aw, Sh as ax, AP as ay, RP as az, wn as b, Dh as b$, qp as b0, uy as b1, Bg as b2, pi as b3, aP as b4, ag as b5, D2 as b6, tP as b7, by as b8, Wu as b9, B2 as bA, F2 as bB, lP as bC, $2 as bD, nP as bE, _2 as bF, Uo as bG, ey as bH, Eh as bI, o1 as bJ, Qa as bK, Ja as bL, pP as bM, P2 as bN, R2 as bO, A2 as bP, k2 as bQ, J2 as bR, gP as bS, Er as bT, h1 as bU, wh as bV, mo as bW, Ho as bX, Q2 as bY, bs as bZ, zo as b_, Ha as ba, Mh as bb, T2 as bc, ha as bd, v2 as be, fP as bf, b2 as bg, Ih as bh, w2 as bi, Is as bj, tu as bk, Bi as bl, eu as bm, yo as bn, oP as bo, zf as bp, zy as bq, q2 as br, Vy as bs, z_ as bt, M2 as bu, Sg as bv, B1 as bw, I2 as bx, N2 as by, H2 as bz, Br as c, U2 as c0, zg as c1, va as c2, qg as c3, jg as c4, Gg as c5, Ey as c6, xy as c7, Dy as c8, za as c9, uP as cA, z2 as cB, Ng as cC, F_ as cD, X1 as cE, I_ as cF, Y1 as cG, d1 as cH, eP as cI, G2 as cJ, qy as cK, V2 as cL, Z2 as cM, C2 as cN, em as cO, yP as cP, E2 as ca, Cg as cb, x2 as cc, Xu as cd, xg as ce, K2 as cf, ev as cg, sP as ch, jl as ci, yd as cj, rP as ck, Vo as cl, Ms as cm, la as cn, Uy as co, iP as cp, m2 as cq, Fu as cr, L2 as cs, Na as ct, Xm as cu, X2 as cv, y2 as cw, cP as cx, H1 as cy, Wy as cz, cs as d, b_ as e, Jr as f, kn as g, xn as h, Ki as i, lx as j, Qu as k, Bs as l, Mc as m, Bo as n, Mn as o, Sb as p, ws as q, cd as r, hx as s, Uu as t, Kt as u, $i as v, Ty as w, ux as x, mP as y, Pc as z
};